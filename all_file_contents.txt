
### File: __init__.py ###

--------------------------------------------------------------------------------

### File: directory_structure.txt ###
📁 .
  📄 __init__.py
  📄 directory_structure.txt
  📄 requirements.txt
  📄 d_chapter.py
  📄 app.py
  📄 chapter_sidebar.py
  📄 README.md
  📄 .env
  📄 chapter11_structure.txt
  📄 d.py
  📁 utils
    📄 sanitizer.py
    📁 __pycache__
      📄 sanitizer.cpython-310.pyc
      📄 sanitizer.cpython-312.pyc
  📁 topic_handlers
    📄 chapter2_polynomials_handler.py
    📄 chapter6_triangles_handler.py
    📄 chapter11_areas_circles_handler.py
    📄 chapter12_surface_areas_handler.py
    📁 __pycache__
      📄 chapter6_triangles_handler.cpython-310.pyc
      📄 chapter11_areas_circles_handler.cpython-310.pyc
      📄 chapter2_polynomials_handler.cpython-310.pyc
      📄 chapter12_surface_areas_handler.cpython-310.pyc
  📁 static
    📁 plots
      📄 right_triangle_auto.png
  📁 Math
    📄 ch05_arithmetic_progressions.pdf
    📄 ch06_triangles.pdf
    📄 ch10_circles.pdf
    📄 ch01_real_numbers.pdf
    📄 ch12_surface_areas_and_volumes.pdf
    📄 ch09_some_applications_of_trigonometry.pdf
    📄 ch14_probability.pdf
    📄 ch13_statistics.pdf
    📄 ch08_introduction_to_trigonometry.pdf
    📄 ch07_ coordinate_geometry.pdf
    📄 ch02_polynomials.pdf
    📄 ch04_quadratic_equations.pdf
    📄 ch03_pair_of_linear_equations.pdf
    📄 Math Book Format.txt
    📄 ch11_areas_related_to_circles.pdf
  📁 config
    📄 knowledge_base_config.json
    📄 chapters_config.json
  📁 __pycache__
    📄 chapter_sidebar.cpython-310.pyc
  📁 chapters
    📄 __init__.py
    📁 chapter4_quadratic_equations
      📁 config
    📁 chapter13_statistics
      📁 config
    📁 chapter7_coordinate_geometry
      📁 config
    📁 chapter9_circles
      📁 config
    📁 chapter3_linear_equations
      📄 __init__.py
      📁 sub_chapters
        📄 __init__.py
        📁 graphical_method
          📄 __init__.py
        📁 elimination_method
          📄 __init__.py
        📁 cross_multiplication
          📄 __init__.py
        📁 substitution_method
          📄 __init__.py
      📁 config
      📁 plots
      📁 practice_tests
        📁 solutions
    📁 __pycache__
      📄 __init__.cpython-310.pyc
      📄 __init__.cpython-312.pyc
    📁 chapter11_areas_volumes
      📁 config
    📁 chapter12_surface_areas_and_volumes
      📄 plot_solids.py
      📄 main_router.py
      📄 narrator_solids.py
      📄 interpret_query_solids.py
      📁 sub_chapters
        📁 cylinder
          📄 solver_cylinder.py
          📁 __pycache__
            📄 solver_cylinder.cpython-310.pyc
        📁 sphere
          📄 solver_sphere.py
          📁 __pycache__
            📄 solver_sphere.cpython-310.pyc
        📁 cuboid
          📄 solver_cuboid.py
          📁 __pycache__
            📄 solver_cuboid.cpython-310.pyc
        📁 cone
          📄 solver_cone.py
          📁 __pycache__
            📄 solver_cone.cpython-310.pyc
        📁 combined_solids
          📄 solver_combined.py
          📁 __pycache__
            📄 solver_combined.cpython-310.pyc
      📁 config
      📁 plots
        📄 net_diagram.png
        📄 cuboid_plot.png
        📄 cone_plot.png
        📄 sphere_plot.png
        📄 cylinder_plot.png
      📁 __pycache__
        📄 interpret_query_solids.cpython-310.pyc
        📄 main_router.cpython-310.pyc
        📄 plot_solids.cpython-310.pyc
    📁 chapter8_trigonometry
      📁 config
    📁 chapter14_probability
      📁 config
    📁 chapter1_real_numbers
      📄 __init__.py
      📁 sub_chapters
        📄 __init__.py
        📁 euclid_division
          📄 __init__.py
        📁 irrationality_proofs
          📄 __init__.py
      📁 config
      📁 plots
      📁 practice_tests
        📁 solutions
    📁 chapter6_triangles
      📄 test_triangle_calc.py
      📄 __init__.py
      📄 main_router.py
      📄 plot_triangles.py
      📄 interpret_query_triangles.py
      📁 utils
        📄 triangle_base.py
        📄 triangle_plotter.py
        📁 __pycache__
          📄 triangle_base.cpython-310.pyc
          📄 triangle_plotter.cpython-310.pyc
      📁 sub_chapters
        📄 __init__.py
        📁 triangle_similarity
          📄 __init__.py
        📁 basic_proportionality
          📄 solver_bpt.py
          📁 __pycache__
            📄 solver_bpt.cpython-310.pyc
        📁 right_triangle
          📄 solver_right_triangle.py
          📁 __pycache__
            📄 solver_right_triangle.cpython-310.pyc
        📁 similar_triangles
          📄 solver.py
          📄 solver_similar.py
          📁 __pycache__
            📄 solver_similar.cpython-310.pyc
        📁 __pycache__
          📄 __init__.cpython-310.pyc
        📁 pythagoras
          📄 solver_pythagoras.py
          📁 __pycache__
            📄 solver_pythagoras.cpython-310.pyc
        📁 area
          📄 solver.py
          📄 solver_area.py
          📁 __pycache__
            📄 solver_area.cpython-310.pyc
        📁 triangle_properties
          📄 __init__.py
      📁 config
        📄 triangle_config.json
      📁 plots
        📄 test_right_triangle1.png
        📄 right_triangle_plot.png
        📄 general_triangle_plot.png
        📄 test_right_triangle2.png
        📄 similar_triangles_plot.png
        📄 test_right_triangle3.png
      📁 __pycache__
        📄 plot_triangles.cpython-310.pyc
        📄 interpret_query_triangles.cpython-310.pyc
        📄 __init__.cpython-310.pyc
        📄 main_router.cpython-310.pyc
      📁 chapters
        📁 chapter6_triangles
          📁 plots
            📄 test_right_triangle1.png
            📄 test_right_triangle2.png
            📄 test_right_triangle3.png
      📁 practice_tests
        📁 solutions
    📁 chapter2_polynomials
      📄 __init__.py
      📄 main_router.py
      📄 interpret_query_polynomial.py
      📁 logic_templates
        📄 factor_polynomial.json
      📁 sub_chapters
        📄 __init__.py
        📁 polynomial_factoring
          📄 interpret_query_factoring.py
          📄 __init__.py
          📄 solver_factoring.py
          📄 narrator_polynomial.py
          📄 query_router_factoring.py
          📄 plot_polynomial.py
          📄 test_polynomial_factoring.py
          📁 plots
            📄 polynomial_plot.png
          📁 __pycache__
            📄 narrator_polynomial.cpython-310.pyc
            📄 query_router_factoring.cpython-312.pyc
            📄 interpret_query_factoring.cpython-312.pyc
            📄 plot_polynomial.cpython-310.pyc
            📄 __init__.cpython-310.pyc
            📄 query_router_factoring.cpython-310.pyc
            📄 interpret_query_factoring.cpython-310.pyc
            📄 solver_factoring.cpython-310.pyc
            📄 solver_factoring.cpython-312.pyc
            📄 __init__.cpython-312.pyc
        📁 quadratic_construction
          📄 __init__.py
        📁 __pycache__
          📄 __init__.cpython-310.pyc
          📄 __init__.cpython-312.pyc
        📁 zeroes_relationship
          📄 __init__.py
      📁 config
      📁 plots
      📁 __pycache__
        📄 interpret_query_polynomial.cpython-310.pyc
        📄 __init__.cpython-310.pyc
        📄 main_router.cpython-310.pyc
        📄 __init__.cpython-312.pyc
      📁 practice_tests
        📁 solutions
    📁 chapter11_areas_circles
      📄 plot_circles.py
      📁 plots
        📄 sector_plot.png
      📁 __pycache__
        📄 plot_circles.cpython-310.pyc
    📁 chapter10_constructions
      📁 config
    📁 chapter5_arithmetic_progressions
      📁 config
  📁 knowledge_base
    📄 __init__.py
    📁 search_engine
      📄 __init__.py
    📁 question_bank
      📁 chapter4_quadratic_equations
      📁 chapter13_statistics
      📁 chapter7_coordinate_geometry
      📁 chapter9_circles
      📁 chapter3_linear_equations
        📄 concept_explanations.json
        📄 long_answer_questions.json
        📄 numerical_problems.json
        📄 short_answer_questions.json
        📄 mcq_questions.json
      📁 chapter11_areas_volumes
      📁 chapter8_trigonometry
      📁 chapter14_probability
      📁 chapter1_real_numbers
        📄 concept_explanations.json
        📄 long_answer_questions.json
        📄 numerical_problems.json
        📄 short_answer_questions.json
        📄 mcq_questions.json
      📁 chapter6_triangles
        📄 concept_explanations.json
        📄 long_answer_questions.json
        📄 numerical_problems.json
        📄 short_answer_questions.json
        📄 mcq_questions.json
      📁 chapter2_polynomials
        📄 concept_explanations.json
        📄 long_answer_questions.json
        📄 numerical_problems.json
        📄 short_answer_questions.json
        📄 mcq_questions.json
      📁 chapter10_constructions
      📁 chapter12_surface_areas
      📁 chapter5_arithmetic_progressions
    📁 generators
      📄 __init__.py

--------------------------------------------------------------------------------

### File: requirements.txt ###
# CBSE Math Solver Dependencies
streamlit>=1.28.0
matplotlib>=3.7.0
sympy>=1.12
numpy>=1.24.0
pandas>=2.0.0
plotly>=5.15.0
scipy>=1.11.0

# Optional: For enhanced functionality
# Pillow>=10.0.0          # Image processing
# requests>=2.31.0        # HTTP requests
# beautifulsoup4>=4.12.0  # Web scraping (if needed)

--------------------------------------------------------------------------------

### File: d_chapter.py ###
# File: cbse_math_solver/chapter_structure_extractor.py

import os

def write_line(f, indent_level, prefix, name):
    indent = "  " * indent_level
    f.write(f"{indent}{prefix} {name}\n")

def scan_directory(base_path, f, filter_keyword=None, indent_level=0):
    for dirpath, dirnames, filenames in os.walk(base_path):
        rel_dir = os.path.relpath(dirpath, base_path)
        if "__pycache__" in rel_dir or rel_dir.startswith("."):
            continue
        if filter_keyword and filter_keyword not in dirpath.lower():
            continue
        depth = rel_dir.count(os.sep) if rel_dir != "." else 0
        write_line(f, indent_level + depth, "📁", os.path.basename(dirpath))
        for file in sorted(filenames):
            if file.endswith((".py", ".json", ".txt", ".md", ".pdf")):
                write_line(f, indent_level + depth + 1, "📄", file)

def find_matching_chapter_folder(base_path, keyword):
    """
    Find the full folder name under 'chapters/' that matches the chapter keyword (e.g., chapter12)
    """
    chapters_path = os.path.join(base_path, "chapters")
    for name in os.listdir(chapters_path):
        if keyword in name.lower() and os.path.isdir(os.path.join(chapters_path, name)):
            return name
    return None

def generate_chapter_structure(chapter_num: str):
    root_dir = "."
    chapter_keyword = f"chapter{chapter_num}"

    output_file = f"{chapter_keyword}_structure.txt"

    with open(output_file, "w", encoding="utf-8") as f:
        f.write(f"# Structure for {chapter_keyword}\n\n")

        # 1. Root files
        f.write("📁 Root Files in cbse_math_solver\n")
        for item in sorted(os.listdir(root_dir)):
            if os.path.isfile(item) and item.endswith((".py", ".txt", ".md", ".env")):
                write_line(f, 1, "📄", item)
        f.write("\n")

        # 2. topic_handlers
        topic_dir = os.path.join(root_dir, "topic_handlers")
        f.write("📁 topic_handlers (filtered)\n")
        scan_directory(topic_dir, f, filter_keyword=chapter_keyword)

        # 3. utils
        utils_dir = os.path.join(root_dir, "utils")
        f.write("\n📁 utils (filtered)\n")
        scan_directory(utils_dir, f, filter_keyword=chapter_keyword)

        # 4. chapters
        matched_folder = find_matching_chapter_folder(root_dir, chapter_keyword)
        if matched_folder:
            chapter_dir = os.path.join(root_dir, "chapters", matched_folder)
            f.write(f"\n📁 chapters/{matched_folder}\n")
            scan_directory(chapter_dir, f)
        else:
            f.write(f"\n⚠️ Folder chapters/*{chapter_keyword}* not found\n")

    print(f"✅ Structure saved to: {output_file}")


# === MAIN ===
if __name__ == "__main__":
    chapter_input = input("Enter chapter number (e.g., 12 for chapter12_surface_areas_and_volumes): ").strip()
    if not chapter_input.isdigit():
        print("❌ Invalid chapter number")
    else:
        generate_chapter_structure(chapter_input)

--------------------------------------------------------------------------------

### File: app.py ###
# File: cbse_math_solver/app.py

import streamlit as st
import sys, os

# Must be first Streamlit command
st.set_page_config(page_title='CBSE Math Solver', layout='wide')

# Add root for local imports
sys.path.append(os.path.abspath('.'))

# Imports
from chapter_sidebar import render_chapter_sidebar
from topic_handlers.chapter2_polynomials_handler import handle_chapter2_polynomials
from topic_handlers.chapter6_triangles_handler import handle_chapter6_triangles
from topic_handlers.chapter11_areas_circles_handler import handle_chapter11_areas_circles
from topic_handlers.chapter12_surface_areas_handler import handle_chapter12_surface_areas

# Sidebar
render_chapter_sidebar()

# Title
st.title('📘 CBSE Class X – Math Query Solver')

# Selected Topic
topic = st.session_state.get('selected_topic', '')

if topic:
    if topic.startswith('Chapter 2: Polynomials'):
        handle_chapter2_polynomials(topic)
    elif topic.startswith('Chapter 6: Triangles'):
        handle_chapter6_triangles(topic)
    elif topic.startswith('Chapter 11: Areas Related to Circles'):
        handle_chapter11_areas_circles(topic)
    elif topic.startswith('Chapter 12: Surface Areas and Volumes'):
        handle_chapter12_surface_areas(topic)

    elif 'Question Bank' in topic:
        st.markdown(f'📚 Displaying questions for **{topic}** (static placeholder)')
        st.markdown('- Q1: Example question\n- Q2: Another question')

    else:
        st.info('⚠️ This topic is not yet implemented.')

else:
    st.info('Please select a topic from the sidebar.')
    
    # Show welcome message
    st.markdown("""
    ### Welcome to CBSE Math Solver! 🎯
    
    This interactive tool helps you:
    - 🧮 Solve mathematical problems step-by-step
    - 📊 Visualize concepts with graphs and 3D models
    - 📚 Access formulas and explanations
    - 🎯 Practice with guided examples
    
    **Currently Available Chapters:**
    - ✅ Chapter 2: Polynomials (Factoring, Graphing)
    - ✅ Chapter 6: Triangles
    - ✅ Chapter 11: Areas Related to Circles
    - ✅ Chapter 12: Surface Areas and Volumes (3D Visualization, Calculations)
    - 🔄 More chapters coming soon...
    
    👈 **Select a topic from the sidebar to begin!**
    """)
    
    # Add sample problems
    with st.expander("📝 Sample Problems You Can Try"):
        st.markdown("""
        **Polynomials:**
        - `factor x^2 - 5x + 6`
        - `y = x^3 - 4x`
        - `factorize x^2 + 7x + 12`
        
        **Surface Areas and Volumes:**
        - `Find volume of cylinder with radius 7 cm and height 10 cm`
        - `Calculate surface area of cone with radius 5 cm and height 12 cm`
        - `Find TSA of sphere with radius 14 cm`
        """)

# Footer
st.markdown("---")
st.markdown("📚 *CBSE Class X Mathematics Solver - Making Math Visual and Interactive*")
--------------------------------------------------------------------------------

### File: chapter_sidebar.py ###
# File: cbse_math_solver/chapter_sidebar.py

import streamlit as st

def render_chapter_sidebar():
    st.sidebar.title('📘 CBSE Class X – Math Topics')
    if 'selected_topic' not in st.session_state:
        st.session_state['selected_topic'] = ''

    chapters = {
        "Chapter 1: Real Numbers": [
            "Irrationality Proofs",
            "Euclid Division Lemma",
            "Question Bank"
        ],
        "Chapter 2: Polynomials": [
            "Polynomial Factoring",
            "Zeroes Relationship",
            "Quadratic Construction",
            "Question Bank"
        ],
        "Chapter 3: Linear Equations": [
            "Graphical Method",
            "Algebraic Method",
            "Question Bank"
        ],
        "Chapter 4: Quadratic Equations": [
            "Factorization Method",
            "Completing Square Method",
            "Question Bank"
        ],
        "Chapter 5: Arithmetic Progressions": [
            "Nth Term",
            "Sum of Terms",
            "Question Bank"
        ],
        "Chapter 6: Triangles": [
            "Right Triangles",
            "Similar Triangles",
            "Area Calculations",
            "Question Bank"
        ],
        "Chapter 7: Coordinate Geometry": [
            "Distance Formula",
            "Section Formula",
            "Midpoint",
            "Question Bank"
        ],
        "Chapter 8: Introduction to Trigonometry": [
            "Ratios",
            "Identities",
            "Question Bank"
        ],
        "Chapter 9: Applications of Trigonometry": [
            "Heights and Distances",
            "Question Bank"
        ],
        "Chapter 10: Circles": [
            "Tangent Properties",
            "Angle Formations",
            "Question Bank"
        ],
        "Chapter 11: Areas Related to Circles": [
            "Sector Area",
            "Segment Area",
            "Question Bank"
        ],
        "Chapter 12: Surface Areas and Volumes": [
            "Cube & Cuboid",
            "Sphere & Cone",
            "Question Bank"
        ],
        "Chapter 13: Statistics": [
            "Mean/Median/Mode",
            "Question Bank"
        ],
        "Chapter 14: Probability": [
            "Simple Probability",
            "Question Bank"
        ],
    }

    for chapter, topics in chapters.items():
        with st.sidebar.expander(f"➕ {chapter}", expanded=False):
            for topic in topics:
                btn_label = f"📌 {topic}" if topic != "Question Bank" else "📚 Question Bank"
                btn_key = chapter.replace(" ", "_") + "_" + topic.replace(" ", "_")
                if st.button(btn_label, key=btn_key):
                    st.session_state['selected_topic'] = f"{chapter} > {topic}"

    # Removed duplicate sidebar logic for Chapter 6 and other chapters

--------------------------------------------------------------------------------

### File: README.md ###
# 🧠 CBSE Math Solver

A comprehensive, modular mathematics problem solver designed specifically for CBSE Class 10 curriculum with step-by-step solutions, knowledge base, and practice tests.

## 🌟 Features

- **📚 Complete CBSE Coverage**: All 14 chapters from Class 10 NCERT Mathematics
- **🎯 Step-by-Step Solutions**: Detailed explanations for every problem
- **📊 Interactive Visualizations**: Graphs and plots for better understanding
- **📝 Knowledge Base**: MCQs, short answers, and long answer questions
- **🧪 Practice Tests**: Auto-generated chapter-wise tests
- **🏗️ Modular Architecture**: Clean, maintainable code structure

## 🚀 Quick Start

1. **Install Dependencies**:
   ```bash
   pip install streamlit matplotlib sympy numpy
   ```

2. **Run the Application**:
   ```bash
   streamlit run app.py
   ```

3. **Access the App**: Open your browser to `http://localhost:8501`

## 📚 Available Chapters

### ✅ Ready Now
- **Chapter 1**: Real Numbers (Irrationality proofs, HCF/LCM)
- **Chapter 2**: Polynomials (Factoring, zeroes, construction)
- **Chapter 3**: Linear Equations (4 CBSE solution methods)
- **Chapter 6**: Triangles (Properties, similarity)

### 🚧 Coming Soon
- **Chapter 4**: Quadratic Equations
- **Chapter 5**: Arithmetic Progressions
- **Chapter 7**: Coordinate Geometry
- **Chapter 8**: Trigonometry
- **Chapter 9**: Circles
- **Chapter 10**: Constructions
- **Chapter 11**: Areas Related to Circles
- **Chapter 12**: Surface Areas and Volumes
- **Chapter 13**: Statistics
- **Chapter 14**: Probability

## 🏗️ Project Structure

```
cbse_math_solver/
├── app.py                     # Main Streamlit application
├── config/                    # Configuration files
├── knowledge_base/            # Question bank and search engine
├── chapters/                  # Chapter-wise modules
│   ├── chapter1_real_numbers/
│   ├── chapter2_polynomials/
│   ├── chapter3_linear_equations/
│   └── ...
```

## 🎯 Usage Examples

### Linear Equations
```python
# Example queries:
"Solve x + y = 5 and 2x - y = 1"
"Use substitution method: 2x + 3y = 7 and x - y = 1"
"Find graphical solution of 3x + 2y = 6 and x - y = 2"
```

### Polynomials
```python
# Example queries:
"Factor x^2 + 5x + 6"
"Relationship between zeroes and coefficients of x^2 - 3x + 2"
"Construct quadratic with roots 2 and 3"
```

### Real Numbers
```python
# Example queries:
"Prove root 2 is irrational"
"Find HCF and LCM of 24 and 36"
"Apply Euclid's division algorithm to 867 and 255"
```

## 🔧 Development

### Adding New Chapters
1. Create chapter directory structure
2. Implement chapter-specific solvers
3. Add configuration files
4. Update main router

### Knowledge Base Integration
Each chapter includes:
- MCQ questions with explanations
- Short answer questions with step-by-step solutions
- Long answer questions with detailed solutions
- Practice tests with automatic grading

## 📊 Architecture Benefits

- **🧩 Modular Design**: Each chapter is completely independent
- **📈 Scalable**: Easy to add new chapters and features
- **🔍 Debuggable**: Small, focused modules for easy troubleshooting
- **📚 Educational**: Structure matches CBSE textbook organization
- **🔄 Maintainable**: Clean separation of concerns

## 🤝 Contributing

1. Fork the repository
2. Create a feature branch
3. Implement your changes
4. Add tests and documentation
5. Submit a pull request

## 📜 License

This project is created for educational purposes and follows CBSE curriculum guidelines.

## 🎯 Roadmap

- [ ] Complete all 14 CBSE chapters
- [ ] Advanced knowledge base search
- [ ] Progress tracking and analytics
- [ ] Mobile-responsive design
- [ ] Offline functionality
- [ ] Multi-language support

## 📧 Support

For questions and support, please open an issue in the repository.

---

**Happy Learning! 🎓✨**

--------------------------------------------------------------------------------

### File: all_file_contents.txt ###

### File: __init__.py ###

--------------------------------------------------------------------------------

### File: directory_structure.txt ###
📁 .
  📄 __init__.py
  📄 directory_structure.txt
  📄 requirements.txt
  📄 d_chapter.py
  📄 app.py
  📄 chapter_sidebar.py
  📄 README.md
  📄 .env
  📄 chapter11_structure.txt
  📄 d.py
  📁 utils
    📄 sanitizer.py
    📁 __pycache__
      📄 sanitizer.cpython-310.pyc
      📄 sanitizer.cpython-312.pyc
  📁 topic_handlers
    📄 chapter2_polynomials_handler.py
    📄 chapter6_triangles_handler.py
    📄 chapter11_areas_circles_handler.py
    📄 chapter12_surface_areas_handler.py
    📁 __pycache__
      📄 chapter6_triangles_handler.cpython-310.pyc
      📄 chapter11_areas_circles_handler.cpython-310.pyc
      📄 chapter2_polynomials_handler.cpython-310.pyc
      📄 chapter12_surface_areas_handler.cpython-310.pyc
  📁 static
    📁 plots
      📄 right_triangle_auto.png
  📁 Math
    📄 ch05_arithmetic_progressions.pdf
    📄 ch06_triangles.pdf
    📄 ch10_circles.pdf
    📄 ch01_real_numbers.pdf
    📄 ch12_surface_areas_and_volumes.pdf
    📄 ch09_some_applications_of_trigonometry.pdf
    📄 ch14_probability.pdf
    📄 ch13_statistics.pdf
    📄 ch08_introduction_to_trigonometry.pdf
    📄 ch07_ coordinate_geometry.pdf
    📄 ch02_polynomials.pdf
    📄 ch04_quadratic_equations.pdf
    📄 ch03_pair_of_linear_equations.pdf
    📄 Math Book Format.txt
    📄 ch11_areas_related_to_circles.pdf
  📁 config
    📄 knowledge_base_config.json
    📄 chapters_config.json
  📁 __pycache__
    📄 chapter_sidebar.cpython-310.pyc
  📁 chapters
    📄 __init__.py
    📁 chapter4_quadratic_equations
      📁 config
    📁 chapter13_statistics
      📁 config
    📁 chapter7_coordinate_geometry
      📁 config
    📁 chapter9_circles
      📁 config
    📁 chapter3_linear_equations
      📄 __init__.py
      📁 sub_chapters
        📄 __init__.py
        📁 graphical_method
          📄 __init__.py
        📁 elimination_method
          📄 __init__.py
        📁 cross_multiplication
          📄 __init__.py
        📁 substitution_method
          📄 __init__.py
      📁 config
      📁 plots
      📁 practice_tests
        📁 solutions
    📁 __pycache__
      📄 __init__.cpython-310.pyc
      📄 __init__.cpython-312.pyc
    📁 chapter11_areas_volumes
      📁 config
    📁 chapter12_surface_areas_and_volumes
      📄 plot_solids.py
      📄 main_router.py
      📄 narrator_solids.py
      📄 interpret_query_solids.py
      📁 sub_chapters
        📁 cylinder
          📄 solver_cylinder.py
          📁 __pycache__
            📄 solver_cylinder.cpython-310.pyc
        📁 sphere
          📄 solver_sphere.py
          📁 __pycache__
            📄 solver_sphere.cpython-310.pyc
        📁 cuboid
          📄 solver_cuboid.py
          📁 __pycache__
            📄 solver_cuboid.cpython-310.pyc
        📁 cone
          📄 solver_cone.py
          📁 __pycache__
            📄 solver_cone.cpython-310.pyc
        📁 combined_solids
          📄 solver_combined.py
          📁 __pycache__
            📄 solver_combined.cpython-310.pyc
      📁 config
      📁 plots
        📄 net_diagram.png
        📄 cuboid_plot.png
        📄 cone_plot.png
        📄 sphere_plot.png
        📄 cylinder_plot.png
      📁 __pycache__
        📄 interpret_query_solids.cpython-310.pyc
        📄 main_router.cpython-310.pyc
        📄 plot_solids.cpython-310.pyc
    📁 chapter8_trigonometry
      📁 config
    📁 chapter14_probability
      📁 config
    📁 chapter1_real_numbers
      📄 __init__.py
      📁 sub_chapters
        📄 __init__.py
        📁 euclid_division
          📄 __init__.py
        📁 irrationality_proofs
          📄 __init__.py
      📁 config
      📁 plots
      📁 practice_tests
        📁 solutions
    📁 chapter6_triangles
      📄 test_triangle_calc.py
      📄 __init__.py
      📄 main_router.py
      📄 plot_triangles.py
      📄 interpret_query_triangles.py
      📁 utils
        📄 triangle_base.py
        📄 triangle_plotter.py
        📁 __pycache__
          📄 triangle_base.cpython-310.pyc
          📄 triangle_plotter.cpython-310.pyc
      📁 sub_chapters
        📄 __init__.py
        📁 triangle_similarity
          📄 __init__.py
        📁 basic_proportionality
          📄 solver_bpt.py
          📁 __pycache__
            📄 solver_bpt.cpython-310.pyc
        📁 right_triangle
          📄 solver_right_triangle.py
          📁 __pycache__
            📄 solver_right_triangle.cpython-310.pyc
        📁 similar_triangles
          📄 solver.py
          📄 solver_similar.py
          📁 __pycache__
            📄 solver_similar.cpython-310.pyc
        📁 __pycache__
          📄 __init__.cpython-310.pyc
        📁 pythagoras
          📄 solver_pythagoras.py
          📁 __pycache__
            📄 solver_pythagoras.cpython-310.pyc
        📁 area
          📄 solver.py
          📄 solver_area.py
          📁 __pycache__
            📄 solver_area.cpython-310.pyc
        📁 triangle_properties
          📄 __init__.py
      📁 config
        📄 triangle_config.json
      📁 plots
        📄 test_right_triangle1.png
        📄 right_triangle_plot.png
        📄 general_triangle_plot.png
        📄 test_right_triangle2.png
        📄 similar_triangles_plot.png
        📄 test_right_triangle3.png
      📁 __pycache__
        📄 plot_triangles.cpython-310.pyc
        📄 interpret_query_triangles.cpython-310.pyc
        📄 __init__.cpython-310.pyc
        📄 main_router.cpython-310.pyc
      📁 chapters
        📁 chapter6_triangles
          📁 plots
            📄 test_right_triangle1.png
            📄 test_right_triangle2.png
            📄 test_right_triangle3.png
      📁 practice_tests
        📁 solutions
    📁 chapter2_polynomials
      📄 __init__.py
      📄 main_router.py
      📄 interpret_query_polynomial.py
      📁 logic_templates
        📄 factor_polynomial.json
      📁 sub_chapters
        📄 __init__.py
        📁 polynomial_factoring
          📄 interpret_query_factoring.py
          📄 __init__.py
          📄 solver_factoring.py
          📄 narrator_polynomial.py
          📄 query_router_factoring.py
          📄 plot_polynomial.py
          📄 test_polynomial_factoring.py
          📁 plots
            📄 polynomial_plot.png
          📁 __pycache__
            📄 narrator_polynomial.cpython-310.pyc
            📄 query_router_factoring.cpython-312.pyc
            📄 interpret_query_factoring.cpython-312.pyc
            📄 plot_polynomial.cpython-310.pyc
            📄 __init__.cpython-310.pyc
            📄 query_router_factoring.cpython-310.pyc
            📄 interpret_query_factoring.cpython-310.pyc
            📄 solver_factoring.cpython-310.pyc
            📄 solver_factoring.cpython-312.pyc
            📄 __init__.cpython-312.pyc
        📁 quadratic_construction
          📄 __init__.py
        📁 __pycache__
          📄 __init__.cpython-310.pyc
          📄 __init__.cpython-312.pyc
        📁 zeroes_relationship
          📄 __init__.py
      📁 config
      📁 plots
      📁 __pycache__
        📄 interpret_query_polynomial.cpython-310.pyc
        📄 __init__.cpython-310.pyc
        📄 main_router.cpython-310.pyc
        📄 __init__.cpython-312.pyc
      📁 practice_tests
        📁 solutions
    📁 chapter11_areas_circles
      📄 plot_circles.py
      📁 plots
        📄 sector_plot.png
      📁 __pycache__
        📄 plot_circles.cpython-310.pyc
    📁 chapter10_constructions
      📁 config
    📁 chapter5_arithmetic_progressions
      📁 config
  📁 knowledge_base
    📄 __init__.py
    📁 search_engine
      📄 __init__.py
    📁 question_bank
      📁 chapter4_quadratic_equations
      📁 chapter13_statistics
      📁 chapter7_coordinate_geometry
      📁 chapter9_circles
      📁 chapter3_linear_equations
        📄 concept_explanations.json
        📄 long_answer_questions.json
        📄 numerical_problems.json
        📄 short_answer_questions.json
        📄 mcq_questions.json
      📁 chapter11_areas_volumes
      📁 chapter8_trigonometry
      📁 chapter14_probability
      📁 chapter1_real_numbers
        📄 concept_explanations.json
        📄 long_answer_questions.json
        📄 numerical_problems.json
        📄 short_answer_questions.json
        📄 mcq_questions.json
      📁 chapter6_triangles
        📄 concept_explanations.json
        📄 long_answer_questions.json
        📄 numerical_problems.json
        📄 short_answer_questions.json
        📄 mcq_questions.json
      📁 chapter2_polynomials
        📄 concept_explanations.json
        📄 long_answer_questions.json
        📄 numerical_problems.json
        📄 short_answer_questions.json
        📄 mcq_questions.json
      📁 chapter10_constructions
      📁 chapter12_surface_areas
      📁 chapter5_arithmetic_progressions
    📁 generators
      📄 __init__.py

--------------------------------------------------------------------------------

### File: requirements.txt ###
# CBSE Math Solver Dependencies
streamlit>=1.28.0
matplotlib>=3.7.0
sympy>=1.12
numpy>=1.24.0
pandas>=2.0.0
plotly>=5.15.0
scipy>=1.11.0

# Optional: For enhanced functionality
# Pillow>=10.0.0          # Image processing
# requests>=2.31.0        # HTTP requests
# beautifulsoup4>=4.12.0  # Web scraping (if needed)

--------------------------------------------------------------------------------

### File: d_chapter.py ###
# File: cbse_math_solver/chapter_structure_extractor.py

import os

def write_line(f, indent_level, prefix, name):
    indent = "  " * indent_level
    f.write(f"{indent}{prefix} {name}\n")

def scan_directory(base_path, f, filter_keyword=None, indent_level=0):
    for dirpath, dirnames, filenames in os.walk(base_path):
        rel_dir = os.path.relpath(dirpath, base_path)
        if "__pycache__" in rel_dir or rel_dir.startswith("."):
            continue
        if filter_keyword and filter_keyword not in dirpath.lower():
            continue
        depth = rel_dir.count(os.sep) if rel_dir != "." else 0
        write_line(f, indent_level + depth, "📁", os.path.basename(dirpath))
        for file in sorted(filenames):
            if file.endswith((".py", ".json", ".txt", ".md", ".pdf")):
                write_line(f, indent_level + depth + 1, "📄", file)

def find_matching_chapter_folder(base_path, keyword):
    """
    Find the full folder name under 'chapters/' that matches the chapter keyword (e.g., chapter12)
    """
    chapters_path = os.path.join(base_path, "chapters")
    for name in os.listdir(chapters_path):
        if keyword in name.lower() and os.path.isdir(os.path.join(chapters_path, name)):
            return name
    return None

def generate_chapter_structure(chapter_num: str):
    root_dir = "."
    chapter_keyword = f"chapter{chapter_num}"

    output_file = f"{chapter_keyword}_structure.txt"

    with open(output_file, "w", encoding="utf-8") as f:
        f.write(f"# Structure for {chapter_keyword}\n\n")

        # 1. Root files
        f.write("📁 Root Files in cbse_math_solver\n")
        for item in sorted(os.listdir(root_dir)):
            if os.path.isfile(item) and item.endswith((".py", ".txt", ".md", ".env")):
                write_line(f, 1, "📄", item)
        f.write("\n")

        # 2. topic_handlers
        topic_dir = os.path.join(root_dir, "topic_handlers")
        f.write("📁 topic_handlers (filtered)\n")
        scan_directory(topic_dir, f, filter_keyword=chapter_keyword)

        # 3. utils
        utils_dir = os.path.join(root_dir, "utils")
        f.write("\n📁 utils (filtered)\n")
        scan_directory(utils_dir, f, filter_keyword=chapter_keyword)

        # 4. chapters
        matched_folder = find_matching_chapter_folder(root_dir, chapter_keyword)
        if matched_folder:
            chapter_dir = os.path.join(root_dir, "chapters", matched_folder)
            f.write(f"\n📁 chapters/{matched_folder}\n")
            scan_directory(chapter_dir, f)
        else:
            f.write(f"\n⚠️ Folder chapters/*{chapter_keyword}* not found\n")

    print(f"✅ Structure saved to: {output_file}")


# === MAIN ===
if __name__ == "__main__":
    chapter_input = input("Enter chapter number (e.g., 12 for chapter12_surface_areas_and_volumes): ").strip()
    if not chapter_input.isdigit():
        print("❌ Invalid chapter number")
    else:
        generate_chapter_structure(chapter_input)

--------------------------------------------------------------------------------

### File: app.py ###
# File: cbse_math_solver/app.py

import streamlit as st
import sys, os

# Must be first Streamlit command
st.set_page_config(page_title='CBSE Math Solver', layout='wide')

# Add root for local imports
sys.path.append(os.path.abspath('.'))

# Imports
from chapter_sidebar import render_chapter_sidebar
from topic_handlers.chapter2_polynomials_handler import handle_chapter2_polynomials
from topic_handlers.chapter6_triangles_handler import handle_chapter6_triangles
from topic_handlers.chapter11_areas_circles_handler import handle_chapter11_areas_circles
from topic_handlers.chapter12_surface_areas_handler import handle_chapter12_surface_areas

# Sidebar
render_chapter_sidebar()

# Title
st.title('📘 CBSE Class X – Math Query Solver')

# Selected Topic
topic = st.session_state.get('selected_topic', '')

if topic:
    if topic.startswith('Chapter 2: Polynomials'):
        handle_chapter2_polynomials(topic)
    elif topic.startswith('Chapter 6: Triangles'):
        handle_chapter6_triangles(topic)
    elif topic.startswith('Chapter 11: Areas Related to Circles'):
        handle_chapter11_areas_circles(topic)
    elif topic.startswith('Chapter 12: Surface Areas and Volumes'):
        handle_chapter12_surface_areas(topic)

    elif 'Question Bank' in topic:
        st.markdown(f'📚 Displaying questions for **{topic}** (static placeholder)')
        st.markdown('- Q1: Example question\n- Q2: Another question')

    else:
        st.info('⚠️ This topic is not yet implemented.')

else:
    st.info('Please select a topic from the sidebar.')
    
    # Show welcome message
    st.markdown("""
    ### Welcome to CBSE Math Solver! 🎯
    
    This interactive tool helps you:
    - 🧮 Solve mathematical problems step-by-step
    - 📊 Visualize concepts with graphs and 3D models
    - 📚 Access formulas and explanations
    - 🎯 Practice with guided examples
    
    **Currently Available Chapters:**
    - ✅ Chapter 2: Polynomials (Factoring, Graphing)
    - ✅ Chapter 6: Triangles
    - ✅ Chapter 11: Areas Related to Circles
    - ✅ Chapter 12: Surface Areas and Volumes (3D Visualization, Calculations)
    - 🔄 More chapters coming soon...
    
    👈 **Select a topic from the sidebar to begin!**
    """)
    
    # Add sample problems
    with st.expander("📝 Sample Problems You Can Try"):
        st.markdown("""
        **Polynomials:**
        - `factor x^2 - 5x + 6`
        - `y = x^3 - 4x`
        - `factorize x^2 + 7x + 12`
        
        **Surface Areas and Volumes:**
        - `Find volume of cylinder with radius 7 cm and height 10 cm`
        - `Calculate surface area of cone with radius 5 cm and height 12 cm`
        - `Find TSA of sphere with radius 14 cm`
        """)

# Footer
st.markdown("---")
st.markdown("📚 *CBSE Class X Mathematics Solver - Making Math Visual and Interactive*")
--------------------------------------------------------------------------------

### File: chapter_sidebar.py ###

--------------------------------------------------------------------------------

### File: .env ###
OPENAI_API_KEY=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 
GROQ_API_KEY=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
GOOGLE_CLIENT_ID=812859439465-9u018e3g47tu1lpfutf1mniarm9kf4fj.apps.googleusercontent.com 
GOOGLE_CLIENT_SECRET=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

--------------------------------------------------------------------------------

### File: chapter11_structure.txt ###
# Structure for chapter11

📁 Root Files in cbse_math_solver
  📄 .env
  📄 README.md
  📄 __init__.py
  📄 app.py
  📄 chapter11_structure.txt
  📄 chapter_sidebar.py
  📄 d.py
  📄 d_chapter.py
  📄 directory_structure.txt
  📄 requirements.txt

📁 topic_handlers (filtered)

📁 utils (filtered)

📁 chapters/chapter11_areas_volumes
📁 config

--------------------------------------------------------------------------------

### File: d.py ###
import os

def list_directory_structure(root_dir, output_file):
    with open(output_file, "w", encoding="utf-8") as f:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            depth = dirpath.replace(root_dir, "").count(os.sep)
            indent = "  " * depth
            f.write(f"{indent}📁 {os.path.basename(dirpath)}\n")
            sub_indent = "  " * (depth + 1)
            for file in filenames:
                f.write(f"{sub_indent}📄 {file}\n")

# You are already in cbse_math_solver/
root_directory = "."  # current folder
output_txt = "directory_structure.txt"

list_directory_structure(root_directory, output_txt)
print(f"✅ Directory structure saved to {output_txt}")

--------------------------------------------------------------------------------

### File: export_all_contents.py ###
import os

def export_all_file_contents(root_dir, output_file):
    with open(output_file, "w", encoding="utf-8") as f:
        for dirpath, _, filenames in os.walk(root_dir):
            for filename in filenames:
                file_path = os.path.join(dirpath, filename)
                try:
                    with open(file_path, "r", encoding="utf-8") as file_content:
                        relative_path = os.path.relpath(file_path, root_dir)
                        f.write(f"\n### File: {relative_path} ###\n")
                        f.write(file_content.read())
                        f.write("\n" + "-"*80 + "\n")  # separator between files
                except Exception as e:
                    f.write(f"\n### File: {relative_path} ###\n")
                    f.write(f"[Error reading file: {e}]\n")
                    f.write("\n" + "-"*80 + "\n")

# Set root directory and output file
root_directory = "."  # current directory
output_txt = "all_file_contents.txt"

export_all_file_contents(root_directory, output_txt)
print(f"📄 All file contents saved to: {output_txt}")

--------------------------------------------------------------------------------

### File: utils/sanitizer.py ###
# File: utils/sanitizer.py
import re

def sanitize_expression(expr: str) -> str:
    expr = expr.replace("^", "**")
    expr = re.sub(r'(\d)([a-zA-Z])', r'\1*\2', expr)  # 5x → 5*x
    expr = re.sub(r'([a-zA-Z])(\d)', r'\1*\2', expr)  # x5 → x*5 (if any)
    return expr

def clean_query(text: str) -> str:
    """
    Removes common LLM-style prefixes like 'factor', 'please factor', etc.
    to isolate the pure mathematical expression.
    """
    text = text.lower().strip()
    trigger_phrases = ["factor", "can you factor", "please factor", "find the factors of"]
    for phrase in trigger_phrases:
        if text.startswith(phrase):
            return text.replace(phrase, "").strip()
    return text


--------------------------------------------------------------------------------

### File: utils/__pycache__/sanitizer.cpython-310.pyc ###

### File: utils/__pycache__/sanitizer.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0x83 in position 9: invalid start byte]

--------------------------------------------------------------------------------

### File: utils/__pycache__/sanitizer.cpython-312.pyc ###

### File: utils/__pycache__/sanitizer.cpython-312.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte]

--------------------------------------------------------------------------------

### File: topic_handlers/chapter2_polynomials_handler.py ###
# File: cbse_math_solver/handlers/chapter2_polynomials_handler.py

import streamlit as st
from sympy import symbols, Poly, sympify

from utils.sanitizer import sanitize_expression, clean_query
from chapters.chapter2_polynomials.main_router import route_query
from chapters.chapter2_polynomials.sub_chapters.polynomial_factoring.plot_polynomial import plot_polynomial
from chapters.chapter2_polynomials.sub_chapters.polynomial_factoring.narrator_polynomial import narrate_polynomial_plot

def handle_chapter2_polynomials(topic: str):
    st.subheader(f'Selected: {topic}')

    if topic == 'Chapter 2: Polynomials > Polynomial Factoring':
        st.markdown('### 🧮 Polynomial Factoring (Quadratic & Cubic)')
        
        # Add example buttons for quick testing
        col1, col2, col3 = st.columns(3)
        with col1:
            if st.button("Example: x² - 5x + 6"):
                st.session_state['poly_input'] = "x^2 - 5x + 6"
        with col2:
            if st.button("Example: x³ - 6x² + 11x - 6"):
                st.session_state['poly_input'] = "x^3 - 6x^2 + 11x - 6"
        with col3:
            if st.button("Example: x³ + x² - 4x - 4"):
                st.session_state['poly_input'] = "x^3 + x^2 - 4x - 4"
        
        # Input field
        default_value = st.session_state.get('poly_input', '')
        user_query = st.text_input(
            'Enter polynomial to factor (supports quadratic and cubic):',
            value=default_value,
            placeholder="e.g., x^2 + 5x + 6 or x^3 - 2x^2 - 5x + 6"
        )

        if user_query:
            with st.spinner('Factoring...'):
                # Clean input
                raw_expr = clean_query(user_query)

                # Route to factoring logic
                result = route_query(raw_expr)
                
                # Display result in a nice box
                st.markdown("---")
                st.markdown(result)

                # Try plotting
                try:
                    expr = sanitize_expression(raw_expr)
                    x = symbols('x')
                    poly = Poly(sympify(expr), x)
                    degree = poly.degree()
                    coeffs = poly.all_coeffs()

                    if degree == 2 and len(coeffs) == 3:
                        # Quadratic polynomial
                        a, b, c = map(float, coeffs)
                        plot_path = plot_polynomial([a, b, c], degree=2)
                        st.image(plot_path, caption="Quadratic Polynomial Curve")

                        st.markdown("### 🗣️ Visual Explanation")
                        narration = narrate_polynomial_plot([a, b, c], degree=2)
                        st.info(narration)
                        
                    elif degree == 3 and len(coeffs) == 4:
                        # Cubic polynomial
                        a, b, c, d = map(float, coeffs)
                        plot_path = plot_polynomial([a, b, c, d], degree=3)
                        st.image(plot_path, caption="Cubic Polynomial Curve")

                        st.markdown("### 🗣️ Visual Explanation")
                        narration = narrate_polynomial_plot([a, b, c, d], degree=3)
                        st.info(narration)
                        
                    else:
                        st.warning(f"Plotting is supported only for quadratic (degree 2) and cubic (degree 3) polynomials. Your polynomial has degree {degree}.")

                except Exception as e:
                    st.warning(f"⚠️ Could not extract coefficients for plotting: {e}")
                    
        # Add information box
        with st.expander("ℹ️ About Polynomial Factoring"):
            st.markdown("""
            **Supported polynomial types:**
            - **Quadratic**: ax² + bx + c
            - **Cubic**: ax³ + bx² + cx + d
            
            **How it works:**
            1. For quadratics, we check the discriminant (b² - 4ac)
            2. For cubics, we use the Rational Root Theorem and factor theorem
            3. The graph shows real roots as red dots where the curve crosses the x-axis
            4. Green triangles (for cubics) show critical points (local max/min)
            
            **Tips:**
            - Use ^ for exponents (x^2 means x²)
            - Coefficients can be positive or negative
            - Not all polynomials can be factored over real numbers!
            """)

    elif 'Question Bank' in topic:
        st.markdown(f'📚 Displaying questions for **{topic}** (static placeholder)')
        st.markdown('- Q1: Example question\n- Q2: Another question')
--------------------------------------------------------------------------------

### File: topic_handlers/chapter6_triangles_handler.py ###
# File: topic_handlers/chapter6_triangles_handler.py

import streamlit as st
import math
import os
from chapters.chapter6_triangles.utils.triangle_plotter import TrianglePlotter
from chapters.chapter6_triangles.main_router import route_query

def handle_chapter6_triangles(topic: str):
    st.subheader(f'Selected: {topic}')
    
    if 'Triangles' in topic and 'Question Bank' not in topic:
        st.markdown('### 📐 Triangles Calculator')
        
        # Add tabs for different sections
        tab1, tab2, tab3, tab4 = st.tabs(["🔢 Calculate", "📊 Visualize", "📚 Formulas", "🎯 Practice"])
        
        with tab1:
            st.markdown("#### Enter your query or select a calculation type:")
            trigger_calculation = False
            
            # Quick selection buttons
            col1, col2, col3 = st.columns(3)
            with col1:
                if st.button("📐 Right Triangle"):
                    st.session_state['triangle_input'] = "Find hypotenuse of right triangle with base 3 cm and height 4 cm"
                    trigger_calculation = True
            with col2:
                if st.button("🔄 Similar Triangles"):
                    st.session_state['triangle_input'] = "Check if triangles with sides (3,4,5) and (6,8,10) are similar"
                    trigger_calculation = True
            with col3:
                if st.button("📏 Area"):
                    st.session_state['triangle_input'] = "Find area of triangle with sides 5 cm, 6 cm, and 7 cm"
                    trigger_calculation = True
            
            # Input field
            default_value = st.session_state.get('triangle_input', '')
            user_query = st.text_area(
                'Enter your query:',
                value=default_value,
                placeholder="Examples:\n• Find hypotenuse of right triangle with base 3 cm and height 4 cm\n• Check if triangles with sides (3,4,5) and (6,8,10) are similar\n• Find area of triangle with sides 5 cm, 6 cm, and 7 cm",
                height=100
            )
            
            if user_query and (trigger_calculation or st.button("✅ Solve")):
                with st.spinner('Calculating...'):
                    try:
                        result = route_query(user_query)
                        st.markdown("---")
                        st.markdown(result)
                    except Exception as e:
                        st.error(f"❌ Error processing query: {str(e)}")
                        st.info("💡 Please try one of the example queries or check your input format.")
        
        with tab2:
            st.markdown("#### 📊 Visualize Triangles")
            
            # Initialize plotter
            plotter = TrianglePlotter()
            
            shape_type = st.selectbox(
                "Select type of triangle:",
                ["Right Triangle", "Similar Triangles", "General Triangle"]
            )

            if shape_type == "Right Triangle":
                col1, col2 = st.columns(2)
                with col1:
                    base = st.number_input("Base (cm):", min_value=0.1, max_value=20.0, value=3.0, step=0.5, key="rt_base")
                with col2:
                    height = st.number_input("Height (cm):", min_value=0.1, max_value=20.0, value=4.0, step=0.5, key="rt_height")
                
                if st.button("Generate Right Triangle"):
                    with st.spinner('Generating visualization...'):
                        try:
                            fig = plotter.plot_right_triangle(base, height)
                            st.pyplot(fig)
                            
                            # Show calculations
                            hypotenuse = math.sqrt(base**2 + height**2)
                            area = 0.5 * base * height
                            st.success(f"✅ **Calculations:**\n- Hypotenuse: {hypotenuse:.2f} cm\n- Area: {area:.2f} cm²")
                        except Exception as e:
                            st.error(f"❌ Error generating plot: {str(e)}")

            elif shape_type == "Similar Triangles":
                st.markdown("**First Triangle:**")
                col1, col2, col3 = st.columns(3)
                with col1:
                    a1 = st.number_input("Side a₁ (cm):", min_value=0.1, max_value=20.0, value=3.0, step=0.5, key="st_a1")
                with col2:
                    b1 = st.number_input("Side b₁ (cm):", min_value=0.1, max_value=20.0, value=4.0, step=0.5, key="st_b1")
                with col3:
                    c1 = st.number_input("Side c₁ (cm):", min_value=0.1, max_value=20.0, value=5.0, step=0.5, key="st_c1")
                
                st.markdown("**Second Triangle:**")
                col1, col2, col3 = st.columns(3)
                with col1:
                    a2 = st.number_input("Side a₂ (cm):", min_value=0.1, max_value=20.0, value=6.0, step=0.5, key="st_a2")
                with col2:
                    b2 = st.number_input("Side b₂ (cm):", min_value=0.1, max_value=20.0, value=8.0, step=0.5, key="st_b2")
                with col3:
                    c2 = st.number_input("Side c₂ (cm):", min_value=0.1, max_value=20.0, value=10.0, step=0.5, key="st_c2")
                
                if st.button("Generate Similar Triangles"):
                    with st.spinner('Generating visualization...'):
                        try:
                            # Validate triangles
                            sides1 = [a1, b1, c1]
                            sides2 = [a2, b2, c2]
                            
                            if not is_valid_triangle(sides1):
                                st.error("❌ First triangle is invalid (triangle inequality violated)")
                                return
                            if not is_valid_triangle(sides2):
                                st.error("❌ Second triangle is invalid (triangle inequality violated)")
                                return
                            
                            # Calculate scale factor
                            sorted1 = sorted(sides1)
                            sorted2 = sorted(sides2)
                            scale_factor = sorted2[0] / sorted1[0]
                            
                            fig = plotter.plot_similar_triangles(sides1, sides2, scale_factor)
                            st.pyplot(fig)
                            
                            # Check similarity
                            ratios = [sorted2[i] / sorted1[i] for i in range(3)]
                            is_similar = all(abs(ratios[0] - ratio) < 0.001 for ratio in ratios)
                            
                            if is_similar:
                                st.success(f"✅ **These triangles are similar!**\n- Scale factor: {scale_factor:.3f}")
                            else:
                                st.warning(f"⚠️ **These triangles are NOT similar.**\n- Ratios: {ratios[0]:.3f}, {ratios[1]:.3f}, {ratios[2]:.3f}")
                                
                        except Exception as e:
                            st.error(f"❌ Error generating plot: {str(e)}")

            else:  # General Triangle
                col1, col2, col3 = st.columns(3)
                with col1:
                    a = st.number_input("Side a (cm):", min_value=0.1, max_value=20.0, value=5.0, step=0.5, key="gt_a")
                with col2:
                    b = st.number_input("Side b (cm):", min_value=0.1, max_value=20.0, value=6.0, step=0.5, key="gt_b")
                with col3:
                    c = st.number_input("Side c (cm):", min_value=0.1, max_value=20.0, value=7.0, step=0.5, key="gt_c")
                
                if st.button("Generate Triangle"):
                    with st.spinner('Generating visualization...'):
                        try:
                            sides = [a, b, c]
                            
                            if not is_valid_triangle(sides):
                                st.error("❌ Invalid triangle! The sum of any two sides must be greater than the third side.")
                                return
                            
                            fig = plotter.plot_triangle(sides, "General Triangle")
                            st.pyplot(fig)
                            
                            # Show triangle info
                            angles = calculate_angles(sides)
                            area = calculate_area_heron(sides)
                            triangle_type = get_triangle_type(sides)
                            
                            st.success(f"✅ **Triangle Info:**\n- Type: {triangle_type}\n- Area: {area:.2f} cm²\n- Angles: {angles[0]:.1f}°, {angles[1]:.1f}°, {angles[2]:.1f}°")
                            
                        except Exception as e:
                            st.error(f"❌ Error generating plot: {str(e)}")
        
        with tab3:
            st.markdown("#### 📐 Quick Formula Reference")
            formula_type = st.selectbox(
                "Select formula type:",
                ["All Formulas", "Right Triangle", "Similar Triangles", "Area", "Law of Cosines"]
            )
            if formula_type == "All Formulas":
                display_all_formulas()
            else:
                display_specific_formula(formula_type)
        
        with tab4:
            st.markdown("#### 🎯 Practice Problems")
            difficulty = st.select_slider(
                "Select difficulty:",
                options=["Easy", "Medium", "Hard"],
                value="Medium"
            )
            display_practice_problems(difficulty)
    
    elif 'Question Bank' in topic:
        display_question_bank()

def is_valid_triangle(sides):
    """Check if three sides can form a valid triangle."""
    a, b, c = sides
    return (a + b > c) and (b + c > a) and (a + c > b)

def calculate_angles(sides):
    """Calculate triangle angles using law of cosines."""
    a, b, c = sides
    try:
        A = math.degrees(math.acos((b**2 + c**2 - a**2) / (2 * b * c)))
        B = math.degrees(math.acos((a**2 + c**2 - b**2) / (2 * a * c)))
        C = math.degrees(math.acos((a**2 + b**2 - c**2) / (2 * a * b)))
        return [round(A, 1), round(B, 1), round(C, 1)]
    except:
        return [0, 0, 0]

def calculate_area_heron(sides):
    """Calculate area using Heron's formula."""
    a, b, c = sides
    s = (a + b + c) / 2
    return math.sqrt(s * (s - a) * (s - b) * (s - c))

def get_triangle_type(sides):
    """Determine triangle type."""
    a, b, c = sorted(sides)
    if abs(a**2 + b**2 - c**2) < 0.001:
        return "Right"
    elif a**2 + b**2 < c**2:
        return "Obtuse"
    else:
        return "Acute"

def display_all_formulas():
    st.markdown("""
    ### 📊 Complete Formula Sheet - Triangles
    
    #### 1️⃣ Right Triangle
    - **Pythagorean Theorem:** c² = a² + b² (where c is hypotenuse)
    - **Area:** Area = ½ × base × height
    - **Trigonometric Ratios:**
      - sin θ = opposite / hypotenuse
      - cos θ = adjacent / hypotenuse  
      - tan θ = opposite / adjacent
    
    #### 2️⃣ Similar Triangles
    - **AA Criterion:** Two angles equal → triangles similar
    - **SSS Criterion:** All sides proportional → triangles similar
    - **SAS Criterion:** Two sides proportional + included angle equal → triangles similar
    - **Scale Factor:** ratio of corresponding sides
    - **Area Ratio:** (scale factor)²
    
    #### 3️⃣ Triangle Area
    - **Heron's Formula:** Area = √[s(s-a)(s-b)(s-c)], where s = (a+b+c)/2
    - **Base-Height:** Area = ½ × base × height
    - **Using sine:** Area = ½ab sin C
    
    #### 4️⃣ Law of Cosines
    - **Formula:** c² = a² + b² - 2ab cos C
    - **To find angle:** cos A = (b² + c² - a²) / (2bc)
    
    #### 5️⃣ Law of Sines
    - **Formula:** a/sin A = b/sin B = c/sin C
    """)

def display_specific_formula(formula_type: str):
    formulas = {
        "Right Triangle": """
### 📐 Right Triangle Formulas

**Pythagorean Theorem:**
- c² = a² + b² (where c is hypotenuse)
- c = √(a² + b²)

**Area:**
- Area = ½ × base × height

**Trigonometric Ratios:**
- sin θ = opposite / hypotenuse
- cos θ = adjacent / hypotenuse  
- tan θ = opposite / adjacent

**Special Right Triangles:**
- 30-60-90: sides in ratio 1 : √3 : 2
- 45-45-90: sides in ratio 1 : 1 : √2
        """,
        "Similar Triangles": """
### 🔄 Similar Triangles

**Similarity Criteria:**
- **AA:** Two angles equal
- **SSS:** All sides proportional  
- **SAS:** Two sides proportional + included angle equal

**Properties:**
- Corresponding angles are equal
- Corresponding sides are proportional
- Area ratio = (scale factor)²
- Perimeter ratio = scale factor
        """,
        "Area": """
### 📏 Triangle Area Formulas

**Heron's Formula:**
- Area = √[s(s-a)(s-b)(s-c)]
- where s = (a+b+c)/2 (semi-perimeter)

**Base-Height:**
- Area = ½ × base × height

**Using Sine:**
- Area = ½ab sin C
- Area = ½bc sin A  
- Area = ½ac sin B
        """,
        "Law of Cosines": """
### ⚖️ Law of Cosines

**To find a side:**
- c² = a² + b² - 2ab cos C
- a² = b² + c² - 2bc cos A
- b² = a² + c² - 2ac cos B

**To find an angle:**
- cos A = (b² + c² - a²) / (2bc)
- cos B = (a² + c² - b²) / (2ac)  
- cos C = (a² + b² - c²) / (2ab)
        """
    }
    st.markdown(formulas.get(formula_type, "❌ Unknown formula type"))

def display_practice_problems(difficulty: str):
    problems = {
        "Easy": [
            "Find the hypotenuse of a right triangle with base 3 cm and height 4 cm.",
            "Calculate the area of a triangle with sides 5 cm, 6 cm, and 7 cm.",
            "In a right triangle, if one leg is 5 cm and hypotenuse is 13 cm, find the other leg.",
            "Check if triangles with sides (6,8,10) and (3,4,5) are similar."
        ],
        "Medium": [
            "In a right triangle, if one angle is 30°, and the hypotenuse is 10 cm, find all sides.",
            "Two triangles have sides (5,12,13) and (10,24,26). Find their similarity ratio and area ratio.",
            "Find all angles of a triangle with sides 7 cm, 8 cm, and 9 cm.",
            "If triangles are similar with ratio 2:3 and smaller triangle area is 20 cm², find larger triangle area."
        ],
        "Hard": [
            "In triangle ABC, if AB = 7 cm, BC = 8 cm, and ∠B = 60°, find AC using law of cosines.",
            "If sides are in ratio 3:4:5 and the triangle area is 54 cm², find the actual side lengths.",
            "Prove that triangles with sides (a,b,c) and (ka,kb,kc) are similar for any positive k.",
            "In similar triangles, if perimeters are 30 cm and 45 cm, and area of smaller is 100 cm², find area of larger."
        ]
    }
    st.markdown(f"### 📝 {difficulty} Problems")
    for i, q in enumerate(problems[difficulty], 1):
        st.markdown(f"{i}. {q}")

def display_question_bank():
    st.markdown("""
### 📚 Question Bank - Triangles

#### 🔢 Multiple Choice Questions
1. In a right triangle, if one angle is 45°, the other acute angle is:
   - a) 45°  ✅
   - b) 30°  
   - c) 60°  
   - d) 90°

2. Triangles are similar if:
   - a) Corresponding angles are equal  ✅
   - b) All sides are equal  
   - c) Areas are equal  
   - d) Perimeters are equal

3. The hypotenuse of a right triangle with legs 5 and 12 is:
   - a) 17
   - b) 13  ✅
   - c) 15
   - d) 7

#### ✏️ Short Answer Questions
1. Find the hypotenuse of a right triangle with base 9 cm and height 12 cm.
2. Calculate the area of triangle with sides 8 cm, 15 cm, and 17 cm.
3. If triangles have sides (4,5,6) and (8,10,12), find the similarity ratio.

#### 📝 Long Answer Questions
1. **Triangle Analysis:**
   In triangle ABC, AB = 8 cm, BC = 10 cm, ∠B = 60°  
   a) Find AC using the law of cosines  
   b) Calculate the area using Heron's formula  
   c) Find all angles using law of cosines
   d) Verify angle sum = 180°

2. **Similar Triangles Problem:**
   Two similar triangles have perimeters 24 cm and 36 cm.
   a) Find the similarity ratio
   b) If area of smaller triangle is 32 cm², find area of larger triangle
   c) If one side of smaller triangle is 6 cm, find corresponding side of larger triangle
""")
--------------------------------------------------------------------------------

### File: topic_handlers/chapter11_areas_circles_handler.py ###
# File: topic_handlers/chapter11_areas_circles_handler.py

import streamlit as st
import math
from chapters.chapter11_areas_circles.plot_circles import plot_sector, plot_segment

def handle_chapter11_areas_circles(topic: str):
    st.subheader(f'Selected: {topic}')
    
    if 'Areas Related to Circles' in topic and 'Question Bank' not in topic:
        st.markdown('### 📐 Areas Related to Circles Calculator')
        
        # Add tabs for different sections
        tab1, tab2, tab3, tab4 = st.tabs(["🔢 Calculate", "📊 Visualize", "📚 Formulas", "🎯 Practice"])
        
        with tab1:
            st.markdown("#### Enter your query or select a calculation type:")
            
            # Quick selection buttons
            col1, col2 = st.columns(2)
            with col1:
                if st.button("🍕 Sector Area"):
                    st.session_state['circle_input'] = "Find area of sector with radius 7 cm and angle 60°"
            with col2:
                if st.button("🌙 Segment Area"):
                    st.session_state['circle_input'] = "Calculate area of segment with radius 5 cm and angle 45°"
            
            # Input field
            default_value = st.session_state.get('circle_input', '')
            user_query = st.text_area(
                'Enter your query:',
                value=default_value,
                placeholder="Examples:\n• Find area of sector with radius 7 cm and angle 60°\n• Calculate area of segment with radius 5 cm and angle 45°",
                height=100
            )
            
            if user_query:
                with st.spinner('Calculating...'):
                    result = calculate_area(user_query)
                    st.markdown("---")
                    st.markdown(result)
        
        with tab2:
            st.markdown("#### 📊 Visualize Circle Areas")
            
            # Shape selection
            shape_type = st.selectbox(
                "Select shape to visualize:",
                ["Sector", "Segment"]
            )
            
            # Input fields
            col1, col2 = st.columns(2)
            with col1:
                radius = st.number_input("Radius (cm):", min_value=1.0, max_value=20.0, value=7.0, step=0.5)
            with col2:
                angle = st.number_input("Angle (degrees):", min_value=1.0, max_value=360.0, value=60.0, step=1.0)
            
            if st.button("Generate Visualization"):
                with st.spinner('Generating visualization...'):
                    if shape_type == "Sector":
                        plot_path = plot_sector(radius, angle)
                        st.image(plot_path, caption="Sector Visualization", use_container_width=True)
                    else:  # Segment
                        plot_path = plot_segment(radius, angle)
                        st.image(plot_path, caption="Segment Visualization", use_container_width=True)
        
        with tab3:
            st.markdown("#### 📐 Quick Formula Reference")
            
            formula_type = st.selectbox(
                "Select calculation type:",
                ["All Formulas", "Sector Area", "Segment Area"]
            )
            
            if formula_type == "All Formulas":
                display_all_formulas()
            else:
                display_specific_formula(formula_type)
        
        with tab4:
            st.markdown("#### 🎯 Practice Problems")
            
            difficulty = st.select_slider(
                "Select difficulty:",
                options=["Easy", "Medium", "Hard"],
                value="Medium"
            )
            
            display_practice_problems(difficulty)
    
    elif 'Question Bank' in topic:
        display_question_bank()

def calculate_area(query: str) -> str:
    """Calculate area based on the query."""
    import re
    
    # Extract radius and angle
    radius_match = re.search(r'radius[:\s]+(\d+(?:\.\d+)?)', query, re.IGNORECASE)
    angle_match = re.search(r'angle[:\s]+(\d+(?:\.\d+)?)', query, re.IGNORECASE)
    
    if not (radius_match and angle_match):
        return "❌ Could not extract radius and angle from the query. Please specify both values."
    
    radius = float(radius_match.group(1))
    angle = float(angle_match.group(1))
    
    if radius <= 0 or angle <= 0 or angle > 360:
        return "❌ Invalid values. Radius must be positive and angle must be between 0° and 360°."
    
    # Use π = 22/7 for calculations
    pi = 22/7
    
    if "sector" in query.lower():
        # Sector area = (θ/360°) × πr²
        area = (angle/360) * pi * radius**2
        
        result = f"""
✅ **Sector Area Solution:**

Given:
• Radius (r) = {radius} cm
• Angle (θ) = {angle}°

📝 **Step-by-Step Solution:**

**Area of Sector = (θ/360°) × πr²**
   = ({angle}/360) × {pi:.3f} × {radius}²
   = {angle/360:.3f} × {pi:.3f} × {radius**2:.2f}
   = **{area:.2f} cm²**

💡 **Summary:**
• Area of Sector = {area:.2f} cm²
"""
    else:  # segment area
        # Segment area = (θ/360°) × πr² - ½r²sin(θ)
        sector_area = (angle/360) * pi * radius**2
        triangle_area = 0.5 * radius**2 * math.sin(math.radians(angle))
        area = sector_area - triangle_area
        
        result = f"""
✅ **Segment Area Solution:**

Given:
• Radius (r) = {radius} cm
• Angle (θ) = {angle}°

📝 **Step-by-Step Solution:**

**1. Area of Sector = (θ/360°) × πr²**
   = ({angle}/360) × {pi:.3f} × {radius}²
   = {angle/360:.3f} × {pi:.3f} × {radius**2:.2f}
   = {sector_area:.2f} cm²

**2. Area of Triangle = ½r²sin(θ)**
   = 0.5 × {radius}² × sin({angle}°)
   = 0.5 × {radius**2:.2f} × {math.sin(math.radians(angle)):.3f}
   = {triangle_area:.2f} cm²

**3. Area of Segment = Sector Area - Triangle Area**
   = {sector_area:.2f} - {triangle_area:.2f}
   = **{area:.2f} cm²**

💡 **Summary:**
• Area of Segment = {area:.2f} cm²
"""
    
    return result

def display_all_formulas():
    """Display all formulas in a structured format."""
    st.markdown("""
    ### 📊 Complete Formula Sheet - Areas Related to Circles
    
    #### 1️⃣ **Sector Area**
    - **Area** = (θ/360°) × πr²
    Where:
    - θ = angle in degrees
    - r = radius
    - π ≈ 22/7
    
    #### 2️⃣ **Segment Area**
    - **Area** = (θ/360°) × πr² - ½r²sin(θ)
    Where:
    - θ = angle in degrees
    - r = radius
    - π ≈ 22/7
    
    #### 📌 **Important Notes:**
    - Angle must be in degrees
    - Radius must be positive
    - For segment area, angle must be less than 180°
    """)

def display_specific_formula(formula_type: str):
    """Display specific formula with examples."""
    formulas = {
        "Sector Area": """
        ### 🍕 Sector Area Formula
        
        **Given:** radius (r) and angle (θ)
        
        - **Area** = (θ/360°) × πr²
        
        **Example:** r = 7 cm, θ = 60°
        - Area = (60/360) × 22/7 × 7²
        - Area = 1/6 × 22/7 × 49
        - Area = 25.67 cm²
        """,
        
        "Segment Area": """
        ### 🌙 Segment Area Formula
        
        **Given:** radius (r) and angle (θ)
        
        - **Area** = (θ/360°) × πr² - ½r²sin(θ)
        
        **Example:** r = 5 cm, θ = 45°
        - Sector Area = (45/360) × 22/7 × 5² = 9.82 cm²
        - Triangle Area = 0.5 × 5² × sin(45°) = 8.84 cm²
        - Segment Area = 9.82 - 8.84 = 0.98 cm²
        """
    }
    
    st.markdown(formulas.get(formula_type, "❌ Unknown formula type"))

def display_practice_problems(difficulty: str):
    """Display practice problems based on difficulty."""
    problems = {
        "Easy": [
            "Find area of sector with radius 7 cm and angle 60°",
            "Calculate area of segment with radius 5 cm and angle 45°"
        ],
        "Medium": [
            "A sector has radius 10 cm and area 78.5 cm². Find its angle.",
            "A segment has radius 8 cm and angle 120°. Find its area."
        ],
        "Hard": [
            "A sector has area 154 cm² and angle 90°. Find its radius.",
            "A segment has area 25.67 cm² and radius 7 cm. Find its angle."
        ]
    }
    
    st.markdown(f"### 📝 {difficulty} Problems")
    for i, problem in enumerate(problems[difficulty], 1):
        st.markdown(f"{i}. {problem}")

def display_question_bank():
    """Display question bank for the chapter."""
    st.markdown("""
    ### 📚 Question Bank - Areas Related to Circles
    
    #### Multiple Choice Questions
    1. The area of a sector of angle θ° of a circle with radius r is:
       a) (θ/360°) × πr²
       b) (θ/180°) × πr²
       c) (θ/90°) × πr²
       d) θ × πr²
    
    2. The area of a segment of a circle is:
       a) Always less than the area of the corresponding sector
       b) Always equal to the area of the corresponding sector
       c) Always greater than the area of the corresponding sector
       d) None of these
    
    #### Short Answer Questions
    1. Find the area of a sector of a circle with radius 6 cm and angle 60°.
    2. Calculate the area of a segment of a circle with radius 8 cm and angle 45°.
    
    #### Long Answer Questions
    1. A sector of a circle has radius 10 cm and angle 120°. Find:
       a) The area of the sector
       b) The area of the corresponding segment
       c) The length of the arc
    """)

--------------------------------------------------------------------------------

### File: topic_handlers/chapter12_surface_areas_handler.py ###
# File: topic_handlers/chapter12_surface_areas_handler.py

import streamlit as st
from chapters.chapter12_surface_areas_and_volumes.main_router import route_query
from chapters.chapter12_surface_areas_and_volumes.plot_solids import (
    plot_cylinder, plot_cone, plot_sphere, plot_cuboid, 
    plot_combined_solid, create_2d_net
)

def handle_chapter12_surface_areas(topic: str):
    st.subheader(f'Selected: {topic}')
    
    if 'Surface Areas and Volumes' in topic and 'Question Bank' not in topic:
        st.markdown('### 📐 Surface Areas and Volumes Calculator')
        
        # Add tabs for different sections
        tab1, tab2, tab3, tab4 = st.tabs(["🔢 Calculate", "📊 Visualize", "📚 Formulas", "🎯 Practice"])
        
        with tab1:
            st.markdown("#### Enter your query or select a solid type:")
            
            # Quick selection buttons
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                if st.button("🔵 Cylinder"):
                    st.session_state['solid_input'] = "Find volume and surface area of cylinder with radius 7 cm and height 10 cm"
            with col2:
                if st.button("🔺 Cone"):
                    st.session_state['solid_input'] = "Calculate surface area of cone with radius 5 cm and height 12 cm"
            with col3:
                if st.button("⚪ Sphere"):
                    st.session_state['solid_input'] = "Find volume of sphere with radius 14 cm"
            with col4:
                if st.button("📦 Cube"):
                    st.session_state['solid_input'] = "Calculate TSA of cube with side 8 cm"
            
            # Input field
            default_value = st.session_state.get('solid_input', '')
            user_query = st.text_area(
                'Enter your query:',
                value=default_value,
                placeholder="Examples:\n• Find volume of cylinder with radius 7 cm and height 10 cm\n• What is the formula for surface area of cone?\n• Calculate TSA of sphere with radius 21 cm",
                height=100
            )
            
            if user_query:
                with st.spinner('Calculating...'):
                    result = route_query(user_query)
                    st.markdown("---")
                    st.markdown(result)
        
        with tab2:
            st.markdown("""
            #### 📊 3D Visualization of Solids
            
            This tool helps you visualize different 3D shapes. Here's how to use it:
            1. Select a shape from the dropdown below
            2. Enter the required dimensions
            3. Click the "Generate Plot" button
            4. The 3D visualization will appear below
            
            You can also:
            - See the shape from different angles in the saved image
            - View net diagrams for some shapes (like cylinder and cube)
            - Compare different shapes by generating multiple plots
            """)
            
            # Create two columns for better layout
            col_left, col_right = st.columns([1, 2])
            
            with col_left:
                st.markdown("### 🎯 Select Shape")
                shape_type = st.selectbox(
                    "Select shape to visualize:",
                    ["Sphere", "Hemisphere", "Cube", "Cuboid", "Cylinder", "Cone", "Combined Solids"]
                )
                
                st.markdown("### 📏 Enter Dimensions")
                
                if shape_type == "Sphere":
                    radius = st.number_input("Radius (cm):", min_value=1.0, value=7.0, step=0.5)
                    if st.button("🎨 Generate Sphere Plot", use_container_width=True):
                        with st.spinner('Generating 3D visualization...'):
                            plot_path = plot_sphere(radius, is_hemisphere=False)
                            st.session_state['current_plot'] = plot_path
                            st.session_state['plot_caption'] = f"3D Sphere Visualization (r = {radius} cm)"
                
                elif shape_type == "Hemisphere":
                    radius = st.number_input("Radius (cm):", min_value=1.0, value=7.0, step=0.5)
                    if st.button("🎨 Generate Hemisphere Plot", use_container_width=True):
                        with st.spinner('Generating 3D visualization...'):
                            plot_path = plot_sphere(radius, is_hemisphere=True)
                            st.session_state['current_plot'] = plot_path
                            st.session_state['plot_caption'] = f"3D Hemisphere Visualization (r = {radius} cm)"
                
                elif shape_type == "Cube":
                    side = st.number_input("Side/Edge (cm):", min_value=1.0, value=5.0, step=0.5)
                    if st.button("🎨 Generate Cube Plot", use_container_width=True):
                        with st.spinner('Generating 3D visualization...'):
                            plot_path = plot_cuboid(side, side, side)
                            st.session_state['current_plot'] = plot_path
                            st.session_state['plot_caption'] = f"3D Cube Visualization (a = {side} cm)"
                            
                            # Generate net diagram
                            net_path = create_2d_net("cube", {"side": side})
                            st.session_state['current_net'] = net_path
                            st.session_state['net_caption'] = "Net Diagram of Cube"
                
                elif shape_type == "Cuboid":
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        length = st.number_input("Length (cm):", min_value=1.0, value=8.0, step=0.5)
                    with col2:
                        breadth = st.number_input("Breadth (cm):", min_value=1.0, value=6.0, step=0.5)
                    with col3:
                        height = st.number_input("Height (cm):", min_value=1.0, value=4.0, step=0.5)
                    
                    if st.button("🎨 Generate Cuboid Plot", use_container_width=True):
                        with st.spinner('Generating 3D visualization...'):
                            plot_path = plot_cuboid(length, breadth, height)
                            st.session_state['current_plot'] = plot_path
                            st.session_state['plot_caption'] = f"3D Cuboid Visualization (l = {length}, b = {breadth}, h = {height} cm)"
                
                elif shape_type == "Cylinder":
                    col1, col2 = st.columns(2)
                    with col1:
                        radius = st.number_input("Radius (cm):", min_value=1.0, value=5.0, step=0.5)
                    with col2:
                        height = st.number_input("Height (cm):", min_value=1.0, value=10.0, step=0.5)
                    
                    if st.button("🎨 Generate Cylinder Plot", use_container_width=True):
                        with st.spinner('Generating 3D visualization...'):
                            plot_path = plot_cylinder(radius, height)
                            st.session_state['current_plot'] = plot_path
                            st.session_state['plot_caption'] = f"3D Cylinder Visualization (r = {radius}, h = {height} cm)"
                            
                            # Generate net diagram
                            net_path = create_2d_net("cylinder", {"radius": radius, "height": height})
                            st.session_state['current_net'] = net_path
                            st.session_state['net_caption'] = "Net Diagram of Cylinder"
                
                elif shape_type == "Cone":
                    col1, col2 = st.columns(2)
                    with col1:
                        radius = st.number_input("Radius (cm):", min_value=1.0, value=5.0, step=0.5)
                    with col2:
                        height = st.number_input("Height (cm):", min_value=1.0, value=12.0, step=0.5)
                    
                    if st.button("🎨 Generate Cone Plot", use_container_width=True):
                        with st.spinner('Generating 3D visualization...'):
                            plot_path = plot_cone(radius, height)
                            st.session_state['current_plot'] = plot_path
                            st.session_state['plot_caption'] = f"3D Cone Visualization (r = {radius}, h = {height} cm)"
                
                elif shape_type == "Combined Solids":
                    combined_type = st.selectbox(
                        "Select combined solid:",
                        ["Cone on Hemisphere"]
                    )
                    
                    if combined_type == "Cone on Hemisphere":
                        radius = st.number_input("Radius (cm):", min_value=1.0, max_value=20.0, value=1.0, step=0.5)
                        height = st.number_input("Cone Height (cm):", min_value=1.0, max_value=20.0, value=1.0, step=0.5)
                        
                        if st.button("Generate Combined Solid Plot"):
                            with st.spinner('Generating visualization...'):
                                plot_path = plot_combined_solid(radius, height)
                                st.image(plot_path, caption="Combined Solid Visualization", use_container_width=True)
                                
                                # Display volume calculation
                                hemisphere_volume = (2/3) * (22/7) * radius**3
                                cone_volume = (1/3) * (22/7) * radius**2 * height
                                total_volume = hemisphere_volume + cone_volume
                                
                                st.markdown(f"""
                                ### 📊 Volume Calculation
                                
                                **Given:**
                                - Radius (r) = {radius} cm
                                - Cone Height (h) = {height} cm
                                
                                **Step-by-Step Solution:**
                                
                                1. Volume of Hemisphere = ⅔πr³
                                   = ⅔ × ²²⁄₇ × {radius}³
                                   = {hemisphere_volume:.2f} cm³
                                
                                2. Volume of Cone = ⅓πr²h
                                   = ⅓ × ²²⁄₇ × {radius}² × {height}
                                   = {cone_volume:.2f} cm³
                                
                                3. Total Volume = Hemisphere Volume + Cone Volume
                                   = {hemisphere_volume:.2f} + {cone_volume:.2f}
                                   = **{total_volume:.2f} cm³**
                                """)
            
            with col_right:
                st.markdown("### 🖼️ Visualization")
                if 'current_plot' in st.session_state:
                    st.image(st.session_state['current_plot'], 
                            caption=st.session_state['plot_caption'],
                            use_container_width=True)
                    
                    if 'current_net' in st.session_state:
                        st.markdown("### 📐 Net Diagram")
                        st.image(st.session_state['current_net'],
                                caption=st.session_state['net_caption'],
                                use_container_width=True)
                else:
                    st.info("👈 Select a shape and enter dimensions to generate a 3D visualization")
        
        with tab3:
            st.markdown("#### 📐 Quick Formula Reference")
            
            formula_type = st.selectbox(
                "Select solid:",
                ["All Formulas", "Cylinder", "Cone", "Sphere & Hemisphere", "Cube & Cuboid"]
            )
            
            if formula_type == "All Formulas":
                display_all_formulas()
            else:
                display_specific_formula(formula_type)
        
        with tab4:
            st.markdown("#### 🎯 Practice Problems")
            
            difficulty = st.select_slider(
                "Select difficulty:",
                options=["Easy", "Medium", "Hard"],
                value="Medium"
            )
            
            display_practice_problems(difficulty)
    
    elif 'Question Bank' in topic:
        display_question_bank()

def display_all_formulas():
    """Display all formulas in a structured format."""
    st.markdown("""
    ### 📊 Complete Formula Sheet - Surface Areas and Volumes
    
    #### 1️⃣ **Cylinder**
    - **Volume** = πr²h
    - **Curved Surface Area (CSA)** = 2πrh
    - **Total Surface Area (TSA)** = 2πr(r + h)
    
    #### 2️⃣ **Cone**
    - **Volume** = ⅓πr²h
    - **Curved Surface Area (CSA)** = πrl
    - **Total Surface Area (TSA)** = πr(r + l)
    - **Slant Height**: l = √(r² + h²)
    
    #### 3️⃣ **Sphere**
    - **Volume** = ⁴⁄₃πr³
    - **Surface Area** = 4πr²
    
    #### 4️⃣ **Hemisphere**
    - **Volume** = ⅔πr³
    - **Curved Surface Area** = 2πr²
    - **Total Surface Area** = 3πr²
    
    #### 5️⃣ **Cube**
    - **Volume** = a³
    - **Total Surface Area** = 6a²
    - **Lateral Surface Area** = 4a²
    - **Diagonal** = a√3
    
    #### 6️⃣ **Cuboid**
    - **Volume** = l × b × h
    - **Total Surface Area** = 2(lb + bh + hl)
    - **Lateral Surface Area** = 2h(l + b)
    - **Diagonal** = √(l² + b² + h²)
    
    #### 📌 **Important Notes:**
    - Use π = 22/7 for calculations unless specified
    - 1 cm³ = 1 ml
    - 1 m³ = 1000 litres
    """)

def display_specific_formula(formula_type):
    """Display specific formula with examples."""
    formulas = {
        "Cylinder": """
        ### 🔵 Cylinder Formulas
        
        **Given:** radius (r) and height (h)
        
        - **Volume** = πr²h
        - **CSA** = 2πrh
        - **TSA** = 2πr(r + h)
        
        **Example:** r = 7 cm, h = 10 cm
        - Volume = 22/7 × 7² × 10 = 1540 cm³
        - CSA = 2 × 22/7 × 7 × 10 = 440 cm²
        - TSA = 2 × 22/7 × 7 × (7 + 10) = 748 cm²
        """,
        
        "Cone": """
        ### 🔺 Cone Formulas
        
        **Given:** radius (r), height (h), slant height (l)
        
        - **Volume** = ⅓πr²h
        - **CSA** = πrl
        - **TSA** = πr(r + l)
        - **Relation:** l² = r² + h²
        
        **Example:** r = 3 cm, h = 4 cm
        - l = √(3² + 4²) = 5 cm
        - Volume = ⅓ × 22/7 × 3² × 4 = 37.71 cm³
        - CSA = 22/7 × 3 × 5 = 47.14 cm²
        """,
        
        "Sphere & Hemisphere": """
        ### ⚪ Sphere & Hemisphere Formulas
        
        **Sphere (radius r):**
        - Volume = ⁴⁄₃πr³
        - Surface Area = 4πr²
        
        **Hemisphere (radius r):**
        - Volume = ⅔πr³
        - CSA = 2πr²
        - TSA = 3πr² (includes base)
        
        **Example:** r = 7 cm
        - Sphere Volume = ⁴⁄₃ × 22/7 × 7³ = 1437.33 cm³
        - Hemisphere Volume = ⅔ × 22/7 × 7³ = 718.67 cm³
        """,
        
        "Cube & Cuboid": """
        ### 📦 Cube & Cuboid Formulas
        
        **Cube (side a):**
        - Volume = a³
        - TSA = 6a²
        - Diagonal = a√3
        
        **Cuboid (l, b, h):**
        - Volume = l × b × h
        - TSA = 2(lb + bh + hl)
        - Diagonal = √(l² + b² + h²)
        
        **Example:** Cube with a = 5 cm
        - Volume = 5³ = 125 cm³
        - TSA = 6 × 5² = 150 cm²
        - Diagonal = 5√3 = 8.66 cm
        """
    }
    
    st.markdown(formulas.get(formula_type, ""))

def display_practice_problems(difficulty):
    """Display practice problems based on difficulty."""
    problems = {
        "Easy": [
            "1. Find the volume of a cylinder with radius 7 cm and height 10 cm.",
            "2. Calculate the TSA of a cube with side 6 cm.",
            "3. Find the volume of a sphere with radius 3 cm.",
        ],
        "Medium": [
            "1. A cone has radius 5 cm and slant height 13 cm. Find its volume and TSA.",
            "2. A cylindrical tank has radius 14 cm and height 20 cm. Find its capacity in litres.",
            "3. Find the surface area of a hemisphere with radius 10.5 cm.",
        ],
        "Hard": [
            "1. An ice cream cone consists of a hemisphere surmounted by a cone. If radius is 3.5 cm and height of cone is 12 cm, find the total volume.",
            "2. A capsule is formed by a cylinder with hemispheres on both ends. If radius is 5 cm and cylinder length is 14 cm, find TSA.",
            "3. A cuboid has volume 480 cm³. If its length and breadth are 8 cm and 6 cm respectively, find its TSA.",
        ]
    }
    
    st.markdown(f"### {difficulty} Problems:")
    for problem in problems[difficulty]:
        st.markdown(problem)
    
    if st.button("Show Solutions"):
        st.info("Solutions will be displayed here. Try solving them first!")

def display_question_bank():
    """Display question bank for the chapter."""
    st.markdown("""
    ### 📚 Question Bank - Surface Areas and Volumes
    
    #### Section A: Very Short Answer (1 mark each)
    1. State the formula for volume of a cone.
    2. What is the CSA of a sphere with radius r?
    3. How many faces does a cuboid have?
    
    #### Section B: Short Answer (2 marks each)
    1. Find the volume of a cylinder with radius 14 cm and height 15 cm.
    2. Calculate the slant height of a cone with radius 5 cm and height 12 cm.
    
    #### Section C: Long Answer (3-4 marks each)
    1. A tent is in the shape of a cylinder surmounted by a cone. The radius is 7 m and heights of cylindrical and conical parts are 8 m and 3 m respectively. Find the total surface area of the tent.
    
    #### Section D: Case Study (5 marks)
    1. A company manufactures spherical balls of radius 7 cm. These are packed in cubical boxes of side 14 cm. Find:
       (a) Volume of the ball
       (b) Volume of the box
       (c) Empty space in the box
    """)

# Add information box
def add_info_box():
    with st.expander("ℹ️ About Surface Areas and Volumes"):
        st.markdown("""
        **Key Concepts:**
        - Surface area measures the total area of all faces
        - Volume measures the space occupied by a solid
        - CSA (Curved Surface Area) excludes flat surfaces
        - TSA (Total Surface Area) includes all surfaces
        
        **Tips for Problem Solving:**
        1. Identify the solid shape correctly
        2. List given values and what to find
        3. Choose appropriate formula
        4. Substitute values carefully with units
        5. Use π = 22/7 unless specified otherwise
        6. Convert units if needed (cm³ to litres, etc.)
        
        **Common Mistakes to Avoid:**
        - Confusing radius with diameter
        - Mixing up CSA and TSA
        - Forgetting to square or cube values
        - Using wrong value of π
        """)

# Call this function at the end of handle_chapter12_surface_areas
handle_chapter12_surface_areas.__doc__ = """
Handler for Chapter 12: Surface Areas and Volumes.
Includes calculator, 3D visualizations, formulas, and practice problems.
"""
--------------------------------------------------------------------------------

### File: topic_handlers/__pycache__/chapter6_triangles_handler.cpython-310.pyc ###

### File: topic_handlers/__pycache__/chapter6_triangles_handler.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xe4 in position 9: invalid continuation byte]

--------------------------------------------------------------------------------

### File: topic_handlers/__pycache__/chapter11_areas_circles_handler.cpython-310.pyc ###

### File: topic_handlers/__pycache__/chapter11_areas_circles_handler.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xc5 in position 9: invalid continuation byte]

--------------------------------------------------------------------------------

### File: topic_handlers/__pycache__/chapter2_polynomials_handler.cpython-310.pyc ###

### File: topic_handlers/__pycache__/chapter2_polynomials_handler.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 8: invalid continuation byte]

--------------------------------------------------------------------------------

### File: topic_handlers/__pycache__/chapter12_surface_areas_handler.cpython-310.pyc ###

### File: topic_handlers/__pycache__/chapter12_surface_areas_handler.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xc5 in position 9: invalid continuation byte]

--------------------------------------------------------------------------------

### File: static/plots/right_triangle_auto.png ###

### File: static/plots/right_triangle_auto.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: Math/ch05_arithmetic_progressions.pdf ###

### File: Math/ch05_arithmetic_progressions.pdf ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 10: invalid continuation byte]

--------------------------------------------------------------------------------

### File: Math/ch06_triangles.pdf ###

### File: Math/ch06_triangles.pdf ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 10: invalid continuation byte]

--------------------------------------------------------------------------------

### File: Math/ch10_circles.pdf ###

### File: Math/ch10_circles.pdf ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 10: invalid continuation byte]

--------------------------------------------------------------------------------

### File: Math/ch01_real_numbers.pdf ###

### File: Math/ch01_real_numbers.pdf ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 10: invalid continuation byte]

--------------------------------------------------------------------------------

### File: Math/ch12_surface_areas_and_volumes.pdf ###

### File: Math/ch12_surface_areas_and_volumes.pdf ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 10: invalid continuation byte]

--------------------------------------------------------------------------------

### File: Math/ch09_some_applications_of_trigonometry.pdf ###

### File: Math/ch09_some_applications_of_trigonometry.pdf ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 10: invalid continuation byte]

--------------------------------------------------------------------------------

### File: Math/ch14_probability.pdf ###

### File: Math/ch14_probability.pdf ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 10: invalid continuation byte]

--------------------------------------------------------------------------------

### File: Math/ch13_statistics.pdf ###

### File: Math/ch13_statistics.pdf ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 10: invalid continuation byte]

--------------------------------------------------------------------------------

### File: Math/ch08_introduction_to_trigonometry.pdf ###

### File: Math/ch08_introduction_to_trigonometry.pdf ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 10: invalid continuation byte]

--------------------------------------------------------------------------------

### File: Math/ch07_ coordinate_geometry.pdf ###

### File: Math/ch07_ coordinate_geometry.pdf ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 10: invalid continuation byte]

--------------------------------------------------------------------------------

### File: Math/ch02_polynomials.pdf ###

### File: Math/ch02_polynomials.pdf ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 10: invalid continuation byte]

--------------------------------------------------------------------------------

### File: Math/ch04_quadratic_equations.pdf ###

### File: Math/ch04_quadratic_equations.pdf ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 10: invalid continuation byte]

--------------------------------------------------------------------------------

### File: Math/ch03_pair_of_linear_equations.pdf ###

### File: Math/ch03_pair_of_linear_equations.pdf ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 10: invalid continuation byte]

--------------------------------------------------------------------------------

### File: Math/Math Book Format.txt ###
ch01_real_numbers.pdf
ch02_polynomials.pdf
ch03_pair_of_linear_equations.pdf
ch04_quadratic equations.pdf
ch05_arithmetic_progressions.pdf
ch06_triangles.pdf
ch07_coordinate_geometry.pdf
ch08_introduction_to_trigonometry.pdf
ch09_some_applications_of_trigonometry.pdf PDF ch10_circles.pdf
ch11_areas_related_to_circles.pdf
ch12_surface areas_and_volumes.pdf
ch13_statistics.pdf
ch14_probability.pdf

----------------------------------------------------------------
real_numbers.pdf
polynomials.pdf
pair_of_linear_equations.pdf
quadratic equations.pdf
arithmetic_progressions.pdf
triangles.pdf
coordinate_geometry.pdf
introduction_to_trigonometry.pdf
some_applications_of_trigonometry.pdf PDF ch10_circles.pdf
areas_related_to_circles.pdf
surface areas_and_volumes.pdf
statistics.pdf
probability.pdf
------------------------------------------------------
real_numbers
polynomials
pair_of_linear_equations
quadratic equations
arithmetic_progressions
triangles
coordinate_geometry
introduction_to_trigonometry
some_applications_of_trigonometry.pdf PDF ch10_circles
areas_related_to_circles
surface areas_and_volumes
statistics
probability
--------------------------------------------------------------------------------

### File: Math/ch11_areas_related_to_circles.pdf ###

### File: Math/ch11_areas_related_to_circles.pdf ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 10: invalid continuation byte]

--------------------------------------------------------------------------------

### File: config/knowledge_base_config.json ###
{
  "question_types": [
    "mcq",
    "short_answer",
    "long_answer",
    "numerical"
  ],
  "difficulty_levels": [
    "easy",
    "medium",
    "hard"
  ],
  "search_settings": {
    "max_results": 10,
    "similarity_threshold": 0.7
  },
  "test_generation": {
    "quick_quiz": 10,
    "chapter_test": 25,
    "full_test": 50
  }
}
--------------------------------------------------------------------------------

### File: config/chapters_config.json ###
{
  "chapters": {
    "chapter1": {
      "title": "Real Numbers",
      "status": "ready",
      "sub_chapters": [
        "irrationality_proofs",
        "euclid_division"
      ],
      "description": "Irrational numbers, Euclid's division lemma, HCF & LCM"
    },
    "chapter2": {
      "title": "Polynomials",
      "status": "ready",
      "sub_chapters": [
        "polynomial_factoring",
        "zeroes_relationship",
        "quadratic_construction"
      ],
      "description": "Polynomial operations, zeroes, and construction"
    },
    "chapter3": {
      "title": "Pair of Linear Equations in Two Variables",
      "status": "ready",
      "sub_chapters": [
        "graphical_method",
        "substitution_method",
        "elimination_method",
        "cross_multiplication"
      ],
      "description": "Solving linear equations using 4 CBSE methods"
    },
    "chapter4": {
      "title": "Quadratic Equations",
      "status": "coming_soon",
      "sub_chapters": [],
      "description": "Coming Soon - Quadratic formula, nature of roots"
    },
    "chapter5": {
      "title": "Arithmetic Progressions",
      "status": "coming_soon",
      "sub_chapters": [],
      "description": "Coming Soon - AP sequences, sum formulas"
    },
    "chapter6": {
      "title": "Triangles",
      "status": "ready",
      "sub_chapters": [
        "triangle_properties",
        "triangle_similarity"
      ],
      "description": "Triangle properties, similarity criteria"
    },
    "chapter7": {
      "title": "Coordinate Geometry",
      "status": "coming_soon",
      "sub_chapters": [],
      "description": "Coming Soon - Distance formula, section formula"
    },
    "chapter8": {
      "title": "Introduction to Trigonometry",
      "status": "coming_soon",
      "sub_chapters": [],
      "description": "Coming Soon - Trigonometric ratios and identities"
    },
    "chapter9": {
      "title": "Circles",
      "status": "coming_soon",
      "sub_chapters": [],
      "description": "Coming Soon - Tangents, chords, circle theorems"
    },
    "chapter10": {
      "title": "Constructions",
      "status": "coming_soon",
      "sub_chapters": [],
      "description": "Coming Soon - Geometric constructions"
    },
    "chapter11": {
      "title": "Areas Related to Circles",
      "status": "coming_soon",
      "sub_chapters": [],
      "description": "Coming Soon - Circle areas, sectors, segments"
    },
    "chapter12": {
      "title": "Surface Areas and Volumes",
      "status": "coming_soon",
      "sub_chapters": [],
      "description": "Coming Soon - 3D geometry calculations"
    },
    "chapter13": {
      "title": "Statistics",
      "status": "coming_soon",
      "sub_chapters": [],
      "description": "Coming Soon - Mean, median, mode, data analysis"
    },
    "chapter14": {
      "title": "Probability",
      "status": "coming_soon",
      "sub_chapters": [],
      "description": "Coming Soon - Basic probability concepts"
    }
  }
}
--------------------------------------------------------------------------------

### File: __pycache__/chapter_sidebar.cpython-310.pyc ###

### File: __pycache__/chapter_sidebar.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xc5 in position 9: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/__init__.py ###
"""
chapters package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter3_linear_equations/__init__.py ###
"""
chapters.chapter3_linear_equations package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter3_linear_equations/sub_chapters/__init__.py ###
"""
chapters.chapter3_linear_equations.sub_chapters package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter3_linear_equations/sub_chapters/graphical_method/__init__.py ###
"""
chapters.chapter3_linear_equations.sub_chapters.graphical_method package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter3_linear_equations/sub_chapters/elimination_method/__init__.py ###
"""
chapters.chapter3_linear_equations.sub_chapters.elimination_method package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter3_linear_equations/sub_chapters/cross_multiplication/__init__.py ###
"""
chapters.chapter3_linear_equations.sub_chapters.cross_multiplication package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter3_linear_equations/sub_chapters/substitution_method/__init__.py ###
"""
chapters.chapter3_linear_equations.sub_chapters.substitution_method package
"""

--------------------------------------------------------------------------------

### File: chapters/__pycache__/__init__.cpython-310.pyc ###

### File: chapters/__pycache__/__init__.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 8: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/__pycache__/__init__.cpython-312.pyc ###

### File: chapters/__pycache__/__init__.cpython-312.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/plot_solids.py ###
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
import numpy as np
import os

# Use π = 22/7 for all calculations
PI = 22/7

def format_calculation(expression, value):
    """Format calculation with π = 22/7."""
    return f"{expression} = {value:.2f}"

def calculate_areas(shape_type, params):
    """Calculate areas and volumes for different shapes."""
    if shape_type == "sphere":
        radius = params["radius"]
        volume = (4/3) * PI * radius**3
        surface_area = 4 * PI * radius**2
        return {
            "Volume": f"⁴⁄₃πr³ = ⁴⁄₃ × ²²⁄₇ × {radius}³ = {volume:.2f} cm³",
            "Surface Area": f"4πr² = 4 × ²²⁄₇ × {radius}² = {surface_area:.2f} cm²"
        }
    
    elif shape_type == "hemisphere":
        radius = params["radius"]
        volume = (2/3) * PI * radius**3
        csa = 2 * PI * radius**2
        tsa = 3 * PI * radius**2
        return {
            "Volume": f"⅔πr³ = ⅔ × ²²⁄₇ × {radius}³ = {volume:.2f} cm³",
            "Curved Surface Area": f"2πr² = 2 × ²²⁄₇ × {radius}² = {csa:.2f} cm²",
            "Total Surface Area": f"3πr² = 3 × ²²⁄₇ × {radius}² = {tsa:.2f} cm²"
        }
    
    elif shape_type == "cube":
        side = params["side"]
        volume = side**3
        tsa = 6 * side**2
        lsa = 4 * side**2
        return {
            "Volume": f"a³ = {side}³ = {volume:.2f} cm³",
            "Total Surface Area": f"6a² = 6 × {side}² = {tsa:.2f} cm²",
            "Lateral Surface Area": f"4a² = 4 × {side}² = {lsa:.2f} cm²"
        }
    
    elif shape_type == "cuboid":
        l, b, h = params["length"], params["breadth"], params["height"]
        volume = l * b * h
        tsa = 2 * (l*b + b*h + h*l)
        lsa = 2 * h * (l + b)
        return {
            "Volume": f"l × b × h = {l} × {b} × {h} = {volume:.2f} cm³",
            "Total Surface Area": f"2(lb + bh + hl) = 2({l}×{b} + {b}×{h} + {h}×{l}) = {tsa:.2f} cm²",
            "Lateral Surface Area": f"2h(l + b) = 2×{h}({l} + {b}) = {lsa:.2f} cm²"
        }
    
    elif shape_type == "cylinder":
        r, h = params["radius"], params["height"]
        volume = PI * r**2 * h
        csa = 2 * PI * r * h
        tsa = 2 * PI * r * (r + h)
        return {
            "Volume": f"πr²h = ²²⁄₇ × {r}² × {h} = {volume:.2f} cm³",
            "Curved Surface Area": f"2πrh = 2 × ²²⁄₇ × {r} × {h} = {csa:.2f} cm²",
            "Total Surface Area": f"2πr(r + h) = 2 × ²²⁄₇ × {r} × ({r} + {h}) = {tsa:.2f} cm²"
        }
    
    elif shape_type == "cone":
        r, h = params["radius"], params["height"]
        l = (r**2 + h**2)**0.5  # slant height
        volume = (1/3) * PI * r**2 * h
        csa = PI * r * l
        tsa = PI * r * (r + l)
        return {
            "Volume": f"⅓πr²h = ⅓ × ²²⁄₇ × {r}² × {h} = {volume:.2f} cm³",
            "Curved Surface Area": f"πrl = ²²⁄₇ × {r} × {l:.2f} = {csa:.2f} cm²",
            "Total Surface Area": f"πr(r + l) = ²²⁄₇ × {r} × ({r} + {l:.2f}) = {tsa:.2f} cm²",
            "Slant Height": f"l = √(r² + h²) = √({r}² + {h}²) = {l:.2f} cm"
        }
    
    return {}

def plot_cylinder(radius, height, save_name="cylinder_plot.png"):
    """
    Creates a 3D plot of a cylinder.
    """
    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111, projection='3d')
    
    # Create cylinder
    z = np.linspace(0, height, 50)
    theta = np.linspace(0, 2 * np.pi, 50)
    theta_grid, z_grid = np.meshgrid(theta, z)
    x_grid = radius * np.cos(theta_grid)
    y_grid = radius * np.sin(theta_grid)
    
    # Plot surface
    ax.plot_surface(x_grid, y_grid, z_grid, alpha=0.7, color='lightblue', edgecolor='none')
    
    # Plot top and bottom circles
    circle_theta = np.linspace(0, 2 * np.pi, 50)
    circle_x = radius * np.cos(circle_theta)
    circle_y = radius * np.sin(circle_theta)
    
    # Bottom circle
    ax.plot(circle_x, circle_y, 0, 'b-', linewidth=2)
    ax.plot_surface(circle_x.reshape(1, -1), circle_y.reshape(1, -1), 
                    np.zeros_like(circle_x).reshape(1, -1), alpha=0.7, color='lightblue')
    
    # Top circle
    ax.plot(circle_x, circle_y, height, 'b-', linewidth=2)
    ax.plot_surface(circle_x.reshape(1, -1), circle_y.reshape(1, -1), 
                    np.full_like(circle_x, height).reshape(1, -1), alpha=0.7, color='lightblue')
    
    # Labels and formatting
    ax.set_xlabel('X', fontsize=12)
    ax.set_ylabel('Y', fontsize=12)
    ax.set_zlabel('Z', fontsize=12)
    ax.set_title(f'Cylinder\nRadius = {radius}, Height = {height} cm', fontsize=16, fontweight='bold')
    
    # Add dimension annotations
    ax.text(0, 0, height/2, f'h = {height}', fontsize=12, color='red')
    ax.text(radius, 0, 0, f'r = {radius}', fontsize=12, color='red')
    
    # Calculate and display areas
    areas = calculate_areas("cylinder", {"radius": radius, "height": height})
    area_text = "\n".join([f"{k}:\n{v}" for k, v in areas.items()])
    ax.text2D(0.02, 0.98, area_text, transform=ax.transAxes, fontsize=10,
              bbox=dict(facecolor='white', alpha=0.8))
    
    ax.set_box_aspect([1,1,height/radius])
    
    save_dir = os.path.join(os.path.dirname(__file__), "plots")
    os.makedirs(save_dir, exist_ok=True)
    save_path = os.path.join(save_dir, save_name)
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    plt.close()
    return save_path

def plot_cone(radius, height, save_name="cone_plot.png"):
    """
    Creates a 3D plot of a cone.
    """
    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111, projection='3d')
    
    # Create cone
    z = np.linspace(0, height, 50)
    theta = np.linspace(0, 2 * np.pi, 50)
    
    R = radius * (1 - z/height)  # Radius decreases linearly with height
    Z, Theta = np.meshgrid(z, theta)
    X = R * np.cos(Theta)
    Y = R * np.sin(Theta)
    
    # Plot surface
    ax.plot_surface(X.T, Y.T, Z.T, alpha=0.7, color='lightcoral', edgecolor='none')
    
    # Plot base circle
    circle_theta = np.linspace(0, 2 * np.pi, 50)
    circle_x = radius * np.cos(circle_theta)
    circle_y = radius * np.sin(circle_theta)
    ax.plot(circle_x, circle_y, 0, 'r-', linewidth=2)
    
    # Fill base
    ax.plot_surface(circle_x.reshape(1, -1), circle_y.reshape(1, -1), 
                    np.zeros_like(circle_x).reshape(1, -1), alpha=0.7, color='lightcoral')
    
    # Plot apex
    ax.scatter([0], [0], [height], color='red', s=50)
    
    # Calculate slant height
    slant_height = np.sqrt(radius**2 + height**2)
    
    # Labels
    ax.set_xlabel('X', fontsize=12)
    ax.set_ylabel('Y', fontsize=12)
    ax.set_zlabel('Z', fontsize=12)
    ax.set_title(f'Cone\nRadius = {radius}, Height = {height} cm\nSlant Height = {slant_height:.2f} cm', 
                 fontsize=16, fontweight='bold')
    
    # Add dimension annotations
    ax.text(0, 0, height/2, f'h = {height}', fontsize=12, color='red')
    ax.text(radius/2, 0, 0, f'r = {radius}', fontsize=12, color='red')
    
    # Draw slant height line
    ax.plot([radius, 0], [0, 0], [0, height], 'r--', linewidth=2)
    ax.text(radius/2, 0, height/2, f'l = {slant_height:.1f}', fontsize=12, color='red')
    
    # Calculate and display areas
    areas = calculate_areas("cone", {"radius": radius, "height": height})
    area_text = "\n".join([f"{k}:\n{v}" for k, v in areas.items()])
    ax.text2D(0.02, 0.98, area_text, transform=ax.transAxes, fontsize=10,
              bbox=dict(facecolor='white', alpha=0.8))
    
    ax.set_box_aspect([1,1,height/radius])
    
    save_dir = os.path.join(os.path.dirname(__file__), "plots")
    os.makedirs(save_dir, exist_ok=True)
    save_path = os.path.join(save_dir, save_name)
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    plt.close()
    return save_path

def plot_sphere(radius, is_hemisphere=False, save_name="sphere_plot.png"):
    """
    Creates a 3D plot of a sphere or hemisphere.
    """
    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111, projection='3d')
    
    # Create sphere
    u = np.linspace(0, 2 * np.pi, 50)
    if is_hemisphere:
        v = np.linspace(0, np.pi/2, 25)  # Only upper hemisphere
    else:
        v = np.linspace(0, np.pi, 50)  # Full sphere
    
    x = radius * np.outer(np.cos(u), np.sin(v))
    y = radius * np.outer(np.sin(u), np.sin(v))
    z = radius * np.outer(np.ones(np.size(u)), np.cos(v))
    
    # Plot surface
    ax.plot_surface(x, y, z, alpha=0.7, color='lightgreen', edgecolor='none')
    
    if is_hemisphere:
        # Add base circle for hemisphere
        circle_theta = np.linspace(0, 2 * np.pi, 50)
        circle_x = radius * np.cos(circle_theta)
        circle_y = radius * np.sin(circle_theta)
        ax.plot(circle_x, circle_y, 0, 'g-', linewidth=2)
        
        # Fill base
        ax.plot_surface(circle_x.reshape(1, -1), circle_y.reshape(1, -1), 
                        np.zeros_like(circle_x).reshape(1, -1), alpha=0.7, color='lightgreen')
    
    # Labels
    ax.set_xlabel('X', fontsize=12)
    ax.set_ylabel('Y', fontsize=12)
    ax.set_zlabel('Z', fontsize=12)
    
    shape_name = "Hemisphere" if is_hemisphere else "Sphere"
    ax.set_title(f'{shape_name}\nRadius = {radius} cm', fontsize=16, fontweight='bold')
    
    # Add radius annotation
    ax.plot([0, radius], [0, 0], [0, 0], 'r-', linewidth=2)
    ax.text(radius/2, 0, 0, f'r = {radius}', fontsize=12, color='red')
    
    # Calculate and display areas
    areas = calculate_areas("hemisphere" if is_hemisphere else "sphere", {"radius": radius})
    area_text = "\n".join([f"{k}:\n{v}" for k, v in areas.items()])
    ax.text2D(0.02, 0.98, area_text, transform=ax.transAxes, fontsize=10,
              bbox=dict(facecolor='white', alpha=0.8))
    
    ax.set_box_aspect([1,1,1])
    
    save_dir = os.path.join(os.path.dirname(__file__), "plots")
    os.makedirs(save_dir, exist_ok=True)
    save_path = os.path.join(save_dir, save_name)
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    plt.close()
    return save_path

def plot_cuboid(length, breadth, height, save_name="cuboid_plot.png"):
    """
    Creates a 3D plot of a cuboid or cube.
    """
    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111, projection='3d')
    
    # Define vertices
    vertices = [
        [0, 0, 0], [length, 0, 0], [length, breadth, 0], [0, breadth, 0],  # bottom
        [0, 0, height], [length, 0, height], [length, breadth, height], [0, breadth, height]  # top
    ]
    vertices = np.array(vertices)
    
    # Define faces
    faces = [
        [vertices[0], vertices[1], vertices[5], vertices[4]],  # front
        [vertices[1], vertices[2], vertices[6], vertices[5]],  # right
        [vertices[2], vertices[3], vertices[7], vertices[6]],  # back
        [vertices[3], vertices[0], vertices[4], vertices[7]],  # left
        [vertices[0], vertices[1], vertices[2], vertices[3]],  # bottom
        [vertices[4], vertices[5], vertices[6], vertices[7]]   # top
    ]
    
    # Create collection of faces
    face_collection = Poly3DCollection(faces, alpha=0.7, facecolor='lightblue', edgecolor='darkblue')
    ax.add_collection3d(face_collection)
    
    # Plot edges
    edges = [
        [0, 1], [1, 2], [2, 3], [3, 0],  # bottom edges
        [4, 5], [5, 6], [6, 7], [7, 4],  # top edges
        [0, 4], [1, 5], [2, 6], [3, 7]   # vertical edges
    ]
    
    for edge in edges:
        points = vertices[edge]
        ax.plot3D(*points.T, 'b-', linewidth=2)
    
    # Labels
    ax.set_xlabel('X', fontsize=12)
    ax.set_ylabel('Y', fontsize=12)
    ax.set_zlabel('Z', fontsize=12)
    
    # Check if it's a cube
    if length == breadth == height:
        ax.set_title(f'Cube\nSide = {length} cm', fontsize=16, fontweight='bold')
        # Add dimension annotation
        ax.text(length/2, 0, -0.5, f'a = {length}', fontsize=12, color='red', ha='center')
        # Calculate and display areas
        areas = calculate_areas("cube", {"side": length})
    else:
        ax.set_title(f'Cuboid\nLength = {length}, Breadth = {breadth}, Height = {height} cm', 
                     fontsize=16, fontweight='bold')
        # Add dimension annotations
        ax.text(length/2, 0, -0.5, f'l = {length}', fontsize=12, color='red', ha='center')
        ax.text(length+0.5, breadth/2, 0, f'b = {breadth}', fontsize=12, color='red', ha='center')
        ax.text(0, -0.5, height/2, f'h = {height}', fontsize=12, color='red', ha='center')
        # Calculate and display areas
        areas = calculate_areas("cuboid", {"length": length, "breadth": breadth, "height": height})
    
    # Display areas
    area_text = "\n".join([f"{k}:\n{v}" for k, v in areas.items()])
    ax.text2D(0.02, 0.98, area_text, transform=ax.transAxes, fontsize=10,
              bbox=dict(facecolor='white', alpha=0.8))
    
    # Set limits
    ax.set_xlim([-1, length+1])
    ax.set_ylim([-1, breadth+1])
    ax.set_zlim([-1, height+1])
    
    ax.set_box_aspect([length, breadth, height])
    
    save_dir = os.path.join(os.path.dirname(__file__), "plots")
    os.makedirs(save_dir, exist_ok=True)
    save_path = os.path.join(save_dir, save_name)
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    plt.close()
    return save_path

def plot_combined_solid(radius, height=None, save_name="combined_solid_plot.png"):
    """Creates a 3D plot of a cone standing on a hemisphere."""
    if height is None:
        height = radius  # If height not provided, use radius as height
    
    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111, projection='3d')
    
    # Create hemisphere
    u = np.linspace(0, 2 * np.pi, 50)
    v = np.linspace(0, np.pi/2, 25)  # Only lower hemisphere
    x_hemi = radius * np.outer(np.cos(u), np.sin(v))
    y_hemi = radius * np.outer(np.sin(u), np.sin(v))
    z_hemi = radius * np.outer(np.ones(np.size(u)), np.cos(v))
    
    # Plot hemisphere surface
    ax.plot_surface(x_hemi, y_hemi, -z_hemi, alpha=0.7, color='lightgreen', edgecolor='none')
    
    # Create cone
    z = np.linspace(0, height, 50)
    theta = np.linspace(0, 2 * np.pi, 50)
    
    R = radius * (1 - z/height)  # Radius decreases linearly with height
    Z, Theta = np.meshgrid(z, theta)
    X = R * np.cos(Theta)
    Y = R * np.sin(Theta)
    
    # Plot cone surface
    ax.plot_surface(X.T, Y.T, Z.T, alpha=0.7, color='lightcoral', edgecolor='none')
    
    # Plot base circle
    circle_theta = np.linspace(0, 2 * np.pi, 50)
    circle_x = radius * np.cos(circle_theta)
    circle_y = radius * np.sin(circle_theta)
    ax.plot(circle_x, circle_y, 0, 'b-', linewidth=2)
    
    # Fill base
    ax.plot_surface(circle_x.reshape(1, -1), circle_y.reshape(1, -1), 
                    np.zeros_like(circle_x).reshape(1, -1), alpha=0.7, color='lightcoral')
    
    # Plot apex
    ax.scatter([0], [0], [height], color='red', s=50)
    
    # Calculate slant height
    slant_height = np.sqrt(radius**2 + height**2)
    
    # Labels
    ax.set_xlabel('X', fontsize=12)
    ax.set_ylabel('Y', fontsize=12)
    ax.set_zlabel('Z', fontsize=12)
    ax.set_title(f'Cone on Hemisphere\nRadius = {radius}, Height = {height} cm\nSlant Height = {slant_height:.2f} cm', 
                 fontsize=16, fontweight='bold')
    
    # Add dimension annotations
    ax.text(0, 0, height/2, f'h = {height}', fontsize=12, color='red')
    ax.text(radius/2, 0, 0, f'r = {radius}', fontsize=12, color='red')
    
    # Calculate volumes
    hemisphere_volume = (2/3) * PI * radius**3
    cone_volume = (1/3) * PI * radius**2 * height
    total_volume = hemisphere_volume + cone_volume
    
    # Add volume calculations
    volume_text = (f"Total Volume = Hemisphere Volume + Cone Volume\n"
                  f"= ⅔πr³ + ⅓πr²h\n"
                  f"= ⅔ × ²²⁄₇ × {radius}³ + ⅓ × ²²⁄₇ × {radius}² × {height}\n"
                  f"= {hemisphere_volume:.2f} + {cone_volume:.2f}\n"
                  f"= {total_volume:.2f} cm³")
    ax.text2D(0.02, 0.98, volume_text, transform=ax.transAxes, fontsize=10,
              bbox=dict(facecolor='white', alpha=0.8))
    
    ax.set_box_aspect([1,1,height/radius])
    
    save_dir = os.path.join(os.path.dirname(__file__), "plots")
    os.makedirs(save_dir, exist_ok=True)
    save_path = os.path.join(save_dir, save_name)
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    plt.close()
    return save_path

def create_2d_net(solid_type, params, save_name="net_diagram.png"):
    """
    Creates 2D net diagrams for solids.
    """
    fig, ax = plt.subplots(figsize=(10, 8))
    
    if solid_type == "cube":
        side = params.get("side", 5)
        
        # Draw cube net (cross pattern)
        # Central square
        central = plt.Rectangle((side, side), side, side, fill=False, edgecolor='black', linewidth=2)
        ax.add_patch(central)
        ax.text(side + side/2, side + side/2, 'Base', ha='center', va='center', fontsize=12)
        
        # Top square
        top = plt.Rectangle((side, 2*side), side, side, fill=False, edgecolor='black', linewidth=2)
        ax.add_patch(top)
        ax.text(side + side/2, 2*side + side/2, 'Top', ha='center', va='center', fontsize=12)
        
        # Bottom square
        bottom = plt.Rectangle((side, 0), side, side, fill=False, edgecolor='black', linewidth=2)
        ax.add_patch(bottom)
        ax.text(side + side/2, side/2, 'Bottom', ha='center', va='center', fontsize=12)
        
        # Left square
        left = plt.Rectangle((0, side), side, side, fill=False, edgecolor='black', linewidth=2)
        ax.add_patch(left)
        ax.text(side/2, side + side/2, 'Left', ha='center', va='center', fontsize=12)
        
        # Right square
        right = plt.Rectangle((2*side, side), side, side, fill=False, edgecolor='black', linewidth=2)
        ax.add_patch(right)
        ax.text(2*side + side/2, side + side/2, 'Right', ha='center', va='center', fontsize=12)
        
        # Far right square (back)
        back = plt.Rectangle((3*side, side), side, side, fill=False, edgecolor='black', linewidth=2)
        ax.add_patch(back)
        ax.text(3*side + side/2, side + side/2, 'Back', ha='center', va='center', fontsize=12)
        
        ax.set_xlim(-0.5, 4*side + 0.5)
        ax.set_ylim(-0.5, 3*side + 0.5)
        ax.set_title(f'Net Diagram of Cube (side = {side})', fontsize=16, fontweight='bold')
        
    elif solid_type == "cylinder":
        radius = params.get("radius", 3)
        height = params.get("height", 8)
        
        # Draw rectangle for curved surface
        rect_width = 2 * np.pi * radius
        rect = plt.Rectangle((0, radius), rect_width, height, fill=False, edgecolor='black', linewidth=2)
        ax.add_patch(rect)
        ax.text(rect_width/2, radius + height/2, f'Curved Surface\n(2πr × h)', ha='center', va='center', fontsize=12)
        
        # Draw two circles
        circle1 = plt.Circle((rect_width/4, 0), radius, fill=False, edgecolor='black', linewidth=2)
        circle2 = plt.Circle((3*rect_width/4, 0), radius, fill=False, edgecolor='black', linewidth=2)
        ax.add_patch(circle1)
        ax.add_patch(circle2)
        ax.text(rect_width/4, 0, 'Base', ha='center', va='center', fontsize=10)
        ax.text(3*rect_width/4, 0, 'Top', ha='center', va='center', fontsize=10)
        
        ax.set_xlim(-radius-1, rect_width+radius+1)
        ax.set_ylim(-radius-1, radius+height+1)
        ax.set_title(f'Net Diagram of Cylinder (r = {radius}, h = {height})', fontsize=16, fontweight='bold')
    
    ax.set_aspect('equal')
    ax.axis('off')
    
    save_dir = os.path.join(os.path.dirname(__file__), "plots")
    os.makedirs(save_dir, exist_ok=True)
    save_path = os.path.join(save_dir, save_name)
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    plt.close()
    return save_path
--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/main_router.py ###
import os
import json
from utils.sanitizer import sanitize_expression
from chapters.chapter12_surface_areas_and_volumes.interpret_query_solids import interpret_query_solids
from chapters.chapter12_surface_areas_and_volumes.sub_chapters.cylinder.solver_cylinder import solve_cylinder
from chapters.chapter12_surface_areas_and_volumes.sub_chapters.cone.solver_cone import solve_cone
from chapters.chapter12_surface_areas_and_volumes.sub_chapters.sphere.solver_sphere import solve_sphere
from chapters.chapter12_surface_areas_and_volumes.sub_chapters.cuboid.solver_cuboid import solve_cuboid
from chapters.chapter12_surface_areas_and_volumes.sub_chapters.combined_solids.solver_combined import solve_combined_solid

def load_logic_template(intent: str):
    path = os.path.join(os.path.dirname(__file__), 'logic_templates', f'{intent}.json')
    if os.path.exists(path):
        with open(path, 'r') as f:
            return json.load(f)
    return None

def route_query(query: str) -> str:
    query = query.strip()
    query_lower = query.lower()
    
    # First, try LLM interpretation if available
    try:
        llm_result = interpret_query_solids(query)
        intent = llm_result.get("intent")
        params = llm_result.get("parameters", {})
        
        if intent == "solve_cylinder":
            return solve_cylinder(params)
        elif intent == "solve_cone":
            return solve_cone(params)
        elif intent == "solve_sphere":
            return solve_sphere(params)
        elif intent == "solve_cuboid":
            return solve_cuboid(params)
        elif intent == "solve_combined":
            return solve_combined_solid(params)
        elif intent == "formula_request":
            return get_formula_explanation(params.get("solid_type"))
            
    except Exception as e:
        # If LLM fails, continue with rule-based approach
        pass
    
    # Rule-based approach for common queries
    if any(word in query_lower for word in ["cylinder", "cylindrical"]):
        if any(word in query_lower for word in ["volume", "find", "calculate"]):
            return extract_and_solve_cylinder(query)
        elif any(word in query_lower for word in ["formula", "surface area", "csa", "tsa"]):
            return get_formula_explanation("cylinder")
            
    elif any(word in query_lower for word in ["cone", "conical"]):
        if any(word in query_lower for word in ["volume", "find", "calculate"]):
            return extract_and_solve_cone(query)
        elif any(word in query_lower for word in ["formula", "surface area", "csa", "tsa"]):
            return get_formula_explanation("cone")
            
    elif any(word in query_lower for word in ["sphere", "spherical", "hemisphere"]):
        if any(word in query_lower for word in ["volume", "find", "calculate"]):
            return extract_and_solve_sphere(query)
        elif any(word in query_lower for word in ["formula", "surface area"]):
            return get_formula_explanation("sphere")
            
    elif any(word in query_lower for word in ["cube", "cuboid", "box"]):
        if any(word in query_lower for word in ["volume", "find", "calculate"]):
            return extract_and_solve_cuboid(query)
        elif any(word in query_lower for word in ["formula", "surface area"]):
            return get_formula_explanation("cuboid")
    
    # No match found → show available options
    return show_available_options()

def extract_and_solve_cylinder(query: str):
    """Extract parameters and solve cylinder problem."""
    import re
    # Try to extract radius and height
    radius_match = re.search(r'radius[:\s]+(\d+(?:\.\d+)?)', query, re.IGNORECASE)
    height_match = re.search(r'height[:\s]+(\d+(?:\.\d+)?)', query, re.IGNORECASE)
    
    if radius_match and height_match:
        params = {
            "radius": float(radius_match.group(1)),
            "height": float(height_match.group(1)),
            "find": "all"  # Find volume, CSA, and TSA
        }
        return solve_cylinder(params)
    else:
        return "❌ Could not extract radius and height from the query. Please specify both values."

def extract_and_solve_cone(query: str):
    """Extract parameters and solve cone problem."""
    import re
    radius_match = re.search(r'radius[:\s]+(\d+(?:\.\d+)?)', query, re.IGNORECASE)
    height_match = re.search(r'height[:\s]+(\d+(?:\.\d+)?)', query, re.IGNORECASE)
    slant_match = re.search(r'slant\s*height[:\s]+(\d+(?:\.\d+)?)', query, re.IGNORECASE)
    
    params = {}
    if radius_match:
        params["radius"] = float(radius_match.group(1))
    if height_match:
        params["height"] = float(height_match.group(1))
    if slant_match:
        params["slant_height"] = float(slant_match.group(1))
        
    if len(params) >= 2:  # Need at least 2 parameters
        params["find"] = "all"
        return solve_cone(params)
    else:
        return "❌ Need at least 2 parameters (radius, height, or slant height) to solve cone problems."

def extract_and_solve_sphere(query: str):
    """Extract parameters and solve sphere problem."""
    import re
    radius_match = re.search(r'radius[:\s]+(\d+(?:\.\d+)?)', query, re.IGNORECASE)
    diameter_match = re.search(r'diameter[:\s]+(\d+(?:\.\d+)?)', query, re.IGNORECASE)
    
    params = {}
    if radius_match:
        params["radius"] = float(radius_match.group(1))
    elif diameter_match:
        params["radius"] = float(diameter_match.group(1)) / 2
        
    if "hemisphere" in query.lower():
        params["type"] = "hemisphere"
    else:
        params["type"] = "sphere"
        
    if "radius" in params:
        params["find"] = "all"
        return solve_sphere(params)
    else:
        return "❌ Could not extract radius or diameter from the query."

def extract_and_solve_cuboid(query: str):
    """Extract parameters and solve cuboid/cube problem."""
    import re
    
    if "cube" in query.lower() and "cuboid" not in query.lower():
        # It's a cube - only need side
        side_match = re.search(r'side[:\s]+(\d+(?:\.\d+)?)', query, re.IGNORECASE)
        edge_match = re.search(r'edge[:\s]+(\d+(?:\.\d+)?)', query, re.IGNORECASE)
        
        if side_match or edge_match:
            side = float(side_match.group(1) if side_match else edge_match.group(1))
            params = {
                "length": side,
                "breadth": side,
                "height": side,
                "type": "cube",
                "find": "all"
            }
            return solve_cuboid(params)
    else:
        # It's a cuboid - need length, breadth, height
        length_match = re.search(r'length[:\s]+(\d+(?:\.\d+)?)', query, re.IGNORECASE)
        breadth_match = re.search(r'breadth[:\s]+(\d+(?:\.\d+)?)', query, re.IGNORECASE)
        width_match = re.search(r'width[:\s]+(\d+(?:\.\d+)?)', query, re.IGNORECASE)
        height_match = re.search(r'height[:\s]+(\d+(?:\.\d+)?)', query, re.IGNORECASE)
        
        params = {}
        if length_match:
            params["length"] = float(length_match.group(1))
        if breadth_match:
            params["breadth"] = float(breadth_match.group(1))
        elif width_match:
            params["breadth"] = float(width_match.group(1))
        if height_match:
            params["height"] = float(height_match.group(1))
            
        if len(params) == 3:
            params["type"] = "cuboid"
            params["find"] = "all"
            return solve_cuboid(params)
            
    return "❌ Could not extract dimensions. For cube: specify side/edge. For cuboid: specify length, breadth, and height."

def get_formula_explanation(solid_type: str) -> str:
    """Return formula explanation for a solid type."""
    formulas = {
        "cylinder": """
📐 **Cylinder Formulas:**

• **Volume** = πr²h
• **Curved Surface Area (CSA)** = 2πrh
• **Total Surface Area (TSA)** = 2πr(r + h)

Where:
- r = radius of base
- h = height of cylinder
- π ≈ 3.14159 or 22/7
""",
        "cone": """
📐 **Cone Formulas:**

• **Volume** = ⅓πr²h
• **Curved Surface Area (CSA)** = πrl
• **Total Surface Area (TSA)** = πr(r + l)
• **Slant Height** l = √(r² + h²)

Where:
- r = radius of base
- h = height of cone
- l = slant height
- π ≈ 3.14159 or 22/7
""",
        "sphere": """
📐 **Sphere & Hemisphere Formulas:**

**Sphere:**
• **Volume** = ⁴⁄₃πr³
• **Surface Area** = 4πr²

**Hemisphere:**
• **Volume** = ⅔πr³
• **Curved Surface Area** = 2πr²
• **Total Surface Area** = 3πr²

Where:
- r = radius
- π ≈ 3.14159 or 22/7
""",
        "cuboid": """
📐 **Cuboid & Cube Formulas:**

**Cuboid:**
• **Volume** = l × b × h
• **Total Surface Area** = 2(lb + bh + hl)
• **Lateral Surface Area** = 2h(l + b)

**Cube:**
• **Volume** = a³
• **Total Surface Area** = 6a²
• **Lateral Surface Area** = 4a²

Where:
- l = length, b = breadth, h = height (cuboid)
- a = side/edge (cube)
"""
    }
    
    return formulas.get(solid_type, "❌ Unknown solid type. Available: cylinder, cone, sphere, cuboid")

def show_available_options():
    """Show available options when no specific query matches."""
    return """
📚 **Surface Areas and Volumes - Available Options:**

**1. Solve Problems:**
• "Find volume of cylinder with radius 7 cm and height 10 cm"
• "Calculate surface area of cone with radius 5 cm and height 12 cm"
• "Find volume of sphere with radius 14 cm"
• "Calculate TSA of cube with side 8 cm"

**2. Get Formulas:**
• "Show cylinder formulas"
• "What is the formula for volume of cone?"
• "Surface area of sphere formula"
• "Cuboid volume and surface area formulas"

**3. Combined Solids:**
• "Find volume of ice cream cone (cone + hemisphere)"
• "Calculate surface area of capsule (cylinder + 2 hemispheres)"

**Tips:**
- Specify the solid type and dimensions
- Use units consistently (cm, m, etc.)
- For combined solids, describe the shape clearly
"""
--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/narrator_solids.py ###
def narrate_cylinder(radius, height, volume, csa, tsa):
    """
    Generate educational narration for cylinder.
    """
    return f"""
🔵 **Understanding the Cylinder:**

Imagine a circular disc of radius {radius} cm. Now, if we move this disc vertically upward by {height} cm, 
it traces out a cylinder!

**Key Features:**
• The cylinder has two circular bases (top and bottom) each with radius {radius} cm
• The height is the perpendicular distance between these bases: {height} cm
• When we "unwrap" the curved surface, it forms a rectangle of dimensions 2πr × h

**Why these formulas work:**
• **Volume** = Area of base × Height = πr² × h = {volume:.2f} cm³
• **CSA** = Perimeter of base × Height = 2πr × h = {csa:.2f} cm²
• **TSA** = CSA + 2 × Base Area = {csa:.2f} + 2π({radius})² = {tsa:.2f} cm²

💡 **Real-world connection:** This cylinder can hold {volume:.2f} ml of water!
"""

def narrate_cone(radius, height, slant_height, volume, csa, tsa):
    """
    Generate educational narration for cone.
    """
    return f"""
🔺 **Understanding the Cone:**

Picture a circle with radius {radius} cm. Now imagine lifting its center point straight up by {height} cm 
while keeping the edge fixed. This creates a cone!

**Key Features:**
• The base is a circle with radius {radius} cm
• The apex (tip) is {height} cm directly above the center
• The slant height ({slant_height:.2f} cm) is the distance from apex to edge

**Pythagorean Connection:**
The radius, height, and slant height form a right triangle:
l² = r² + h² → {slant_height:.2f}² = {radius}² + {height}²

**Why these formulas work:**
• **Volume** = ⅓ × Base Area × Height = ⅓πr²h = {volume:.2f} cm³
  (It's exactly ⅓ of a cylinder with same base and height!)
• **CSA** = π × radius × slant height = {csa:.2f} cm²
• **TSA** = CSA + Base Area = {tsa:.2f} cm²

💡 **Fun fact:** Ice cream cones use this shape for structural strength!
"""

def narrate_sphere(radius, volume, surface_area):
    """
    Generate educational narration for sphere.
    """
    return f"""
⚪ **Understanding the Sphere:**

A sphere is the set of all points that are exactly {radius} cm from a center point. 
It's perfectly round in all directions - like a ball!

**Key Features:**
• Every point on the surface is {radius} cm from the center
• It has the maximum volume for its surface area
• Cross-section through center is always a circle

**Why these formulas work:**
• **Volume** = ⁴⁄₃πr³ = {volume:.2f} cm³
  (Related to the volume of the circumscribing cylinder)
• **Surface Area** = 4πr² = {surface_area:.2f} cm²
  (Exactly 4 times the area of its great circle!)

💡 **Amazing fact:** Bubbles form spheres because this shape minimizes surface area for a given volume!
"""

def narrate_hemisphere(radius, volume, csa, tsa):
    """
    Generate educational narration for hemisphere.
    """
    return f"""
⚪ **Understanding the Hemisphere:**

A hemisphere is exactly half of a sphere, cut along a plane through its center.
Think of it as a dome with radius {radius} cm!

**Key Features:**
• The curved surface is half of a sphere's surface
• The flat base is a circle with radius {radius} cm
• Common in architecture (domes) and cooking (bowls)

**Why these formulas work:**
• **Volume** = ½ × Sphere Volume = ⅔πr³ = {volume:.2f} cm³
• **CSA** = ½ × Sphere Surface = 2πr² = {csa:.2f} cm²
• **TSA** = CSA + Base Area = 2πr² + πr² = 3πr² = {tsa:.2f} cm²

💡 **Practical use:** Hemispheres are used in satellite dishes to focus signals!
"""

def narrate_cube(side, volume, tsa, diagonal):
    """
    Generate educational narration for cube.
    """
    return f"""
📦 **Understanding the Cube:**

A cube is a 3D shape where all edges are equal ({side} cm) and all faces are squares.
It's the 3D version of a square!

**Key Features:**
• 6 identical square faces, each with area {side}² = {side**2} cm²
• 12 equal edges, each {side} cm long
• 8 vertices (corners)
• All angles are 90°

**Why these formulas work:**
• **Volume** = side × side × side = {side}³ = {volume:.2f} cm³
• **TSA** = 6 × (area of one face) = 6 × {side}² = {tsa:.2f} cm²
• **Diagonal** = {side}√3 = {diagonal:.2f} cm
  (Using 3D Pythagorean theorem)

💡 **Fun fact:** Dice are cubes because each face has equal probability of landing up!
"""

def narrate_cuboid(length, breadth, height, volume, tsa, diagonal):
    """
    Generate educational narration for cuboid.
    """
    return f"""
📦 **Understanding the Cuboid:**

A cuboid is like a stretched cube - a box shape with length {length} cm, breadth {breadth} cm, 
and height {height} cm.

**Key Features:**
• 6 rectangular faces in 3 pairs of identical opposites
• Face areas: {length}×{breadth} = {length*breadth} cm² (top/bottom)
            {breadth}×{height} = {breadth*height} cm² (front/back)
            {height}×{length} = {height*length} cm² (left/right)

**Why these formulas work:**
• **Volume** = length × breadth × height = {volume:.2f} cm³
  (How many 1×1×1 cubes fit inside)
• **TSA** = 2(lb + bh + hl) = {tsa:.2f} cm²
  (Sum of all 6 face areas)
• **Diagonal** = √(l² + b² + h²) = {diagonal:.2f} cm
  (3D distance formula)

💡 **Real example:** Most rooms, boxes, and buildings are cuboid-shaped!
"""

def narrate_combined_solid(solid_type, params, total_volume, total_surface_area):
    """
    Generate narration for combined solids.
    """
    if "cone" in solid_type and "hemisphere" in solid_type:
        radius = params.get("radius")
        cone_height = params.get("cone_height")
        
        return f"""
🍦 **Understanding the Ice Cream Shape (Cone on Hemisphere):**

This combined solid looks exactly like an ice cream cone with a scoop on top!

**Structure:**
• Bottom part: Hemisphere (the ice cream scoop) with radius {radius} cm
• Top part: Cone (the wafer) with same radius {radius} cm and height {cone_height} cm
• They share a common circular boundary

**How volumes combine:**
• Hemisphere volume = ⅔πr³ 
• Cone volume = ⅓πr²h
• Total = Hemisphere + Cone = {total_volume:.2f} cm³

**Surface area calculation:**
• We count the curved surface of hemisphere (2πr²)
• Plus the curved surface of cone (πrl)
• The circular junction is internal, so not counted!
• Total Surface Area = {total_surface_area:.2f} cm²

💡 **Design wisdom:** The cone shape provides stability while maximizing ice cream volume!
"""
    
    elif "capsule" in solid_type:
        radius = params.get("radius")
        cylinder_height = params.get("cylinder_height")
        
        return f"""
💊 **Understanding the Capsule Shape:**

A capsule is formed by placing hemispheres on both ends of a cylinder - like a medicine capsule!

**Structure:**
• Middle part: Cylinder with radius {radius} cm and height {cylinder_height} cm
• End parts: Two hemispheres (= 1 complete sphere) with radius {radius} cm
• Total length = {cylinder_height + 2*radius} cm

**Volume calculation:**
• Cylinder volume = πr²h
• Two hemispheres = One sphere = ⁴⁄₃πr³
• Total = {total_volume:.2f} cm³

**Surface area:**
• Curved surface of cylinder = 2πrh
• Surface of complete sphere = 4πr²
• Total = {total_surface_area:.2f} cm²

💡 **Why this shape?** Capsules are aerodynamic and have no sharp edges - perfect for medicine!
"""
    
    return "Combined solid narration not available."

def explain_real_world_applications():
    """
    Explain real-world applications of different solids.
    """
    return """
🌍 **Real-World Applications of 3D Solids:**

**🔵 Cylinders:**
• Water tanks and oil drums (maximum volume, easy to manufacture)
• Pillars in buildings (distribute weight evenly)
• Cans and containers (efficient packing)

**🔺 Cones:**
• Ice cream cones (easy to hold, no spillage)
• Funnels (direct flow of liquids)
• Traffic cones (stable base, visible shape)
• Rocket nose cones (aerodynamic)

**⚪ Spheres:**
• Balls in sports (roll in any direction)
• Planets and stars (gravity pulls equally in all directions)
• Water droplets (minimum surface tension)
• Ball bearings (reduce friction)

**📦 Cubes & Cuboids:**
• Buildings and rooms (efficient use of space)
• Shipping boxes (easy stacking)
• Dice and game pieces (equal probabilities)
• Storage containers (no wasted space)

**🍦 Combined Shapes:**
• Lighthouses (cylinder + cone for stability and visibility)
• Silos (cylinder + hemisphere for grain storage)
• Pencils (cylinder + cone for writing)
• Architecture domes (hemisphere on cylinder/cuboid)

Understanding these shapes helps in:
- Engineering and construction
- Product design and packaging
- Architecture and planning
- Scientific calculations
"""
--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/interpret_query_solids.py ###
import os
import re
from dotenv import load_dotenv
from groq import Groq

load_dotenv()
client = Groq(api_key=os.getenv("GROQ_API_KEY"))

def interpret_query_solids(query: str) -> dict:
    """
    Uses LLM to interpret natural language queries related to surface areas and volumes.
    Returns intent + parsed parameters.
    """
    prompt = f"""
You are a math query classifier for CBSE Class X Surface Areas and Volumes topics.
Classify the user query into one of the following intents:
- solve_cylinder (for cylinder volume/surface area problems)
- solve_cone (for cone volume/surface area problems)
- solve_sphere (for sphere/hemisphere problems)
- solve_cuboid (for cuboid/cube problems)
- solve_combined (for combined solids like cone on hemisphere)
- formula_request (when asking for formulas)
- conversion (for unit conversions)

Extract all numerical parameters with their units.

Return a JSON like:
{{
  "intent": "solve_cylinder",
  "parameters": {{
    "radius": 7,
    "height": 10,
    "unit": "cm",
    "find": "volume"
  }}
}}

Query: "{query}"
"""

    try:
        response = client.chat.completions.create(
            model="llama3-8b-8192",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.2
        )
        content = response.choices[0].message.content.strip()
        if content.startswith("{"):
            import json
            return json.loads(content)
        else:
            return {"intent": "unknown", "raw_response": content}
    except Exception as e:
        return {"intent": "error", "error": str(e)}

def extract_measurements(query: str) -> dict:
    """
    Extract numerical measurements from query using regex.
    """
    measurements = {}
    
    # Common patterns
    patterns = {
        'radius': r'radius[:\s]+(\d+(?:\.\d+)?)\s*(\w+)?',
        'height': r'height[:\s]+(\d+(?:\.\d+)?)\s*(\w+)?',
        'length': r'length[:\s]+(\d+(?:\.\d+)?)\s*(\w+)?',
        'breadth': r'breadth[:\s]+(\d+(?:\.\d+)?)\s*(\w+)?',
        'width': r'width[:\s]+(\d+(?:\.\d+)?)\s*(\w+)?',
        'side': r'side[:\s]+(\d+(?:\.\d+)?)\s*(\w+)?',
        'edge': r'edge[:\s]+(\d+(?:\.\d+)?)\s*(\w+)?',
        'diameter': r'diameter[:\s]+(\d+(?:\.\d+)?)\s*(\w+)?',
        'slant_height': r'slant\s*height[:\s]+(\d+(?:\.\d+)?)\s*(\w+)?'
    }
    
    for key, pattern in patterns.items():
        match = re.search(pattern, query, re.IGNORECASE)
        if match:
            measurements[key] = {
                'value': float(match.group(1)),
                'unit': match.group(2) if match.group(2) else 'cm'
            }
    
    return measurements

# Example for testing
if __name__ == "__main__":
    queries = [
        "Find volume of cylinder with radius 7 cm and height 10 cm",
        "Calculate surface area of cone with radius 5 and height 12",
        "What is the formula for volume of sphere?"
    ]
    
    for q in queries:
        print(f"Query: {q}")
        print(f"LLM Result: {interpret_query_solids(q)}")
        print(f"Regex Extract: {extract_measurements(q)}")
        print("-" * 50)
--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/sub_chapters/cylinder/solver_cylinder.py ###
import math
from typing import Dict, Any

def solve_cylinder(params: Dict[str, Any]) -> str:
    """
    Solve cylinder problems - volume, CSA, TSA.
    """
    try:
        radius = params.get("radius", 0)
        height = params.get("height", 0)
        find = params.get("find", "all")
        unit = params.get("unit", "cm")
        
        if radius <= 0 or height <= 0:
            return "❌ Radius and height must be positive values."
        
        # Use π = 22/7 for calculations (CBSE preference)
        pi = 22/7
        
        # Calculate all values
        volume = pi * radius**2 * height
        csa = 2 * pi * radius * height
        tsa = 2 * pi * radius * (radius + height)
        
        # Format result
        result = f"""
✅ **Cylinder Solution:**

Given:
• Radius (r) = {radius} {unit}
• Height (h) = {height} {unit}

📝 **Step-by-Step Solution:**

**1. Volume = πr²h**
   = {pi:.3f} × {radius}² × {height}
   = {pi:.3f} × {radius**2} × {height}
   = **{volume:.2f} {unit}³**

**2. Curved Surface Area (CSA) = 2πrh**
   = 2 × {pi:.3f} × {radius} × {height}
   = **{csa:.2f} {unit}²**

**3. Total Surface Area (TSA) = 2πr(r + h)**
   = 2 × {pi:.3f} × {radius} × ({radius} + {height})
   = 2 × {pi:.3f} × {radius} × {radius + height}
   = **{tsa:.2f} {unit}²**

💡 **Summary:**
• Volume = {volume:.2f} {unit}³
• CSA = {csa:.2f} {unit}²
• TSA = {tsa:.2f} {unit}²
"""
        
        # Add practical interpretation
        if unit == "cm":
            volume_ml = volume / 1  # 1 cm³ = 1 ml
            result += f"\n📊 **Capacity:** {volume_ml:.2f} ml or {volume_ml/1000:.3f} litres"
        
        return result
        
    except Exception as e:
        return f"❌ Error solving cylinder problem: {str(e)}"

def find_missing_cylinder_parameter(known_params: Dict[str, Any]) -> str:
    """
    Find missing parameter when volume or surface area is given.
    """
    try:
        pi = 22/7
        
        if "volume" in known_params and "radius" in known_params:
            # Find height
            volume = known_params["volume"]
            radius = known_params["radius"]
            height = volume / (pi * radius**2)
            
            return f"""
✅ **Finding Height of Cylinder:**

Given:
• Volume = {volume} cm³
• Radius = {radius} cm

Using V = πr²h:
{volume} = {pi:.3f} × {radius}² × h
{volume} = {pi * radius**2:.2f} × h
h = {volume} ÷ {pi * radius**2:.2f}
**h = {height:.2f} cm**
"""
        
        elif "volume" in known_params and "height" in known_params:
            # Find radius
            volume = known_params["volume"]
            height = known_params["height"]
            radius = math.sqrt(volume / (pi * height))
            
            return f"""
✅ **Finding Radius of Cylinder:**

Given:
• Volume = {volume} cm³
• Height = {height} cm

Using V = πr²h:
{volume} = {pi:.3f} × r² × {height}
r² = {volume} ÷ ({pi:.3f} × {height})
r² = {volume / (pi * height):.2f}
**r = {radius:.2f} cm**
"""
        
        return "❌ Need at least volume and one dimension to find the missing parameter."
        
    except Exception as e:
        return f"❌ Error finding missing parameter: {str(e)}"
--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/sub_chapters/cylinder/__pycache__/solver_cylinder.cpython-310.pyc ###

### File: chapters/chapter12_surface_areas_and_volumes/sub_chapters/cylinder/__pycache__/solver_cylinder.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xa9 in position 12: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/sub_chapters/sphere/solver_sphere.py ###
# File: cbse_math_solver/chapters/chapter12_surface_areas_and_volumes/sub_chapters/sphere/solver_sphere.py

import math
from typing import Dict, Any

def solve_sphere(params: Dict[str, Any]) -> str:
    """
    Solve sphere/hemisphere problems - volume and surface area.
    """
    try:
        radius = params.get("radius", 0)
        shape_type = params.get("type", "sphere").lower()
        unit = params.get("unit", "cm")
        
        if radius <= 0:
            return "❌ Radius must be a positive value."
        
        # Use π = 22/7 for calculations
        pi = 22/7
        
        if shape_type == "sphere":
            # Sphere calculations
            volume = (4/3) * pi * radius**3
            surface_area = 4 * pi * radius**2
            
            result = f"""
✅ **Sphere Solution:**

Given:
• Radius (r) = {radius} {unit}

📝 **Step-by-Step Solution:**

**1. Volume = ⁴⁄₃πr³**
   = ⁴⁄₃ × {pi:.3f} × {radius}³
   = ⁴⁄₃ × {pi:.3f} × {radius**3:.2f}
   = {4/3:.3f} × {pi * radius**3:.2f}
   = **{volume:.2f} {unit}³**

**2. Surface Area = 4πr²**
   = 4 × {pi:.3f} × {radius}²
   = 4 × {pi:.3f} × {radius**2:.2f}
   = **{surface_area:.2f} {unit}²**

💡 **Summary:**
• Volume = {volume:.2f} {unit}³
• Surface Area = {surface_area:.2f} {unit}²
"""
            
        else:  # hemisphere
            # Hemisphere calculations
            volume = (2/3) * pi * radius**3
            csa = 2 * pi * radius**2
            tsa = 3 * pi * radius**2
            
            result = f"""
✅ **Hemisphere Solution:**

Given:
• Radius (r) = {radius} {unit}

📝 **Step-by-Step Solution:**

**1. Volume = ⅔πr³**
   = ⅔ × {pi:.3f} × {radius}³
   = ⅔ × {pi:.3f} × {radius**3:.2f}
   = {2/3:.3f} × {pi * radius**3:.2f}
   = **{volume:.2f} {unit}³**

**2. Curved Surface Area (CSA) = 2πr²**
   = 2 × {pi:.3f} × {radius}²
   = 2 × {pi:.3f} × {radius**2:.2f}
   = **{csa:.2f} {unit}²**

**3. Total Surface Area (TSA) = 3πr²**
   (CSA + Base Area)
   = 3 × {pi:.3f} × {radius}²
   = 3 × {pi:.3f} × {radius**2:.2f}
   = **{tsa:.2f} {unit}²**

💡 **Summary:**
• Volume = {volume:.2f} {unit}³
• Curved Surface Area = {csa:.2f} {unit}²
• Total Surface Area = {tsa:.2f} {unit}²

📌 **Note:** TSA includes the flat circular base of the hemisphere.
"""

        return result

    except Exception as e:
        return f"❌ Error solving {shape_type} problem: {str(e)}"

--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/sub_chapters/sphere/__pycache__/solver_sphere.cpython-310.pyc ###

### File: chapters/chapter12_surface_areas_and_volumes/sub_chapters/sphere/__pycache__/solver_sphere.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0x8a in position 9: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/sub_chapters/cuboid/solver_cuboid.py ###
import math
from typing import Dict, Any

def solve_cuboid(params: Dict[str, Any]) -> str:
    """
    Solve cuboid/cube problems - volume and surface areas.
    """
    try:
        shape_type = params.get("type", "cuboid").lower()
        unit = params.get("unit", "cm")
        
        if shape_type == "cube":
            # For cube, all sides are equal
            side = params.get("length", params.get("side", params.get("edge", 0)))
            
            if side <= 0:
                return "❌ Side/edge must be a positive value."
            
            volume = side**3
            tsa = 6 * side**2
            lsa = 4 * side**2
            diagonal = side * math.sqrt(3)
            
            result = f"""
✅ **Cube Solution:**

Given:
• Side/Edge (a) = {side} {unit}

📝 **Step-by-Step Solution:**

**1. Volume = a³**
   = {side}³
   = **{volume:.2f} {unit}³**

**2. Total Surface Area (TSA) = 6a²**
   = 6 × {side}²
   = 6 × {side**2:.2f}
   = **{tsa:.2f} {unit}²**

**3. Lateral Surface Area (LSA) = 4a²**
   = 4 × {side}²
   = 4 × {side**2:.2f}
   = **{lsa:.2f} {unit}²**

**4. Diagonal = a√3**
   = {side} × √3
   = {side} × {math.sqrt(3):.3f}
   = **{diagonal:.2f} {unit}**

💡 **Summary:**
• Volume = {volume:.2f} {unit}³
• TSA = {tsa:.2f} {unit}²
• LSA = {lsa:.2f} {unit}²
• Diagonal = {diagonal:.2f} {unit}
"""
            
        else:  # cuboid
            length = params.get("length", 0)
            breadth = params.get("breadth", 0)
            height = params.get("height", 0)
            
            if length <= 0 or breadth <= 0 or height <= 0:
                return "❌ Length, breadth, and height must be positive values."
            
            volume = length * breadth * height
            tsa = 2 * (length*breadth + breadth*height + height*length)
            lsa = 2 * height * (length + breadth)
            diagonal = math.sqrt(length**2 + breadth**2 + height**2)
            
            result = f"""
✅ **Cuboid Solution:**

Given:
• Length (l) = {length} {unit}
• Breadth (b) = {breadth} {unit}
• Height (h) = {height} {unit}

📝 **Step-by-Step Solution:**

**1. Volume = l × b × h**
   = {length} × {breadth} × {height}
   = **{volume:.2f} {unit}³**

**2. Total Surface Area (TSA) = 2(lb + bh + hl)**
   = 2 × ({length}×{breadth} + {breadth}×{height} + {height}×{length})
   = 2 × ({length*breadth:.2f} + {breadth*height:.2f} + {height*length:.2f})
   = 2 × {length*breadth + breadth*height + height*length:.2f}
   = **{tsa:.2f} {unit}²**

**3. Lateral Surface Area (LSA) = 2h(l + b)**
   = 2 × {height} × ({length} + {breadth})
   = 2 × {height} × {length + breadth}
   = **{lsa:.2f} {unit}²**

**4. Diagonal = √(l² + b² + h²)**
   = √({length}² + {breadth}² + {height}²)
   = √({length**2:.2f} + {breadth**2:.2f} + {height**2:.2f})
   = √{length**2 + breadth**2 + height**2:.2f}
   = **{diagonal:.2f} {unit}**

💡 **Summary:**
• Volume = {volume:.2f} {unit}³
• TSA = {tsa:.2f} {unit}²
• LSA = {lsa:.2f} {unit}²
• Diagonal = {diagonal:.2f} {unit}
"""
        
        return result
        
    except Exception as e:
        return f"❌ Error solving {shape_type} problem: {str(e)}"

def find_missing_dimension(known_params: Dict[str, Any]) -> str:
    """
    Find missing dimension when volume or surface area is given.
    """
    try:
        if "volume" in known_params and "length" in known_params and "breadth" in known_params:
            # Find height
            volume = known_params["volume"]
            length = known_params["length"]
            breadth = known_params["breadth"]
            height = volume / (length * breadth)
            
            return f"""
✅ **Finding Height of Cuboid:**

Given:
• Volume = {volume} cm³
• Length = {length} cm
• Breadth = {breadth} cm

Using V = l × b × h:
{volume} = {length} × {breadth} × h
{volume} = {length * breadth} × h
h = {volume} ÷ {length * breadth}
**h = {height:.2f} cm**
"""
        
        elif "tsa" in known_params and known_params.get("type") == "cube":
            # Find side of cube
            tsa = known_params["tsa"]
            side = math.sqrt(tsa / 6)
            
            return f"""
✅ **Finding Side of Cube from TSA:**

Given:
• Total Surface Area = {tsa} cm²

Using TSA = 6a²:
{tsa} = 6 × a²
a² = {tsa} ÷ 6
a² = {tsa / 6:.2f}
**a = {side:.2f} cm**
"""
        
        return "❌ Need appropriate parameters to find the missing dimension."
        
    except Exception as e:
        return f"❌ Error finding missing dimension: {str(e)}"
--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/sub_chapters/cuboid/__pycache__/solver_cuboid.cpython-310.pyc ###

### File: chapters/chapter12_surface_areas_and_volumes/sub_chapters/cuboid/__pycache__/solver_cuboid.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xce in position 8: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/sub_chapters/cone/solver_cone.py ###
import math
from typing import Dict, Any

def solve_cone(params: Dict[str, Any]) -> str:
    """
    Solve cone problems - volume, CSA, TSA.
    """
    try:
        radius = params.get("radius", 0)
        height = params.get("height", 0)
        slant_height = params.get("slant_height", 0)
        unit = params.get("unit", "cm")
        
        # Calculate missing parameter using Pythagoras theorem
        if radius > 0 and height > 0 and slant_height == 0:
            slant_height = math.sqrt(radius**2 + height**2)
        elif radius > 0 and slant_height > 0 and height == 0:
            height = math.sqrt(slant_height**2 - radius**2)
        elif height > 0 and slant_height > 0 and radius == 0:
            radius = math.sqrt(slant_height**2 - height**2)
        
        if radius <= 0 or height <= 0:
            return "❌ Need at least 2 parameters: radius, height, or slant height."
        
        # Use π = 22/7 for calculations
        pi = 22/7
        
        # Calculate all values
        volume = (1/3) * pi * radius**2 * height
        csa = pi * radius * slant_height
        tsa = pi * radius * (radius + slant_height)
        
        # Format result
        result = f"""
✅ **Cone Solution:**

Given/Calculated:
• Radius (r) = {radius:.2f} {unit}
• Height (h) = {height:.2f} {unit}
• Slant Height (l) = {slant_height:.2f} {unit}

📝 **Step-by-Step Solution:**

**1. Slant Height Verification:**
   l = √(r² + h²)
   l = √({radius}² + {height}²)
   l = √({radius**2:.2f} + {height**2:.2f})
   l = √{radius**2 + height**2:.2f}
   l = {slant_height:.2f} {unit} ✓

**2. Volume = ⅓πr²h**
   = ⅓ × {pi:.3f} × {radius}² × {height}
   = ⅓ × {pi:.3f} × {radius**2:.2f} × {height}
   = ⅓ × {pi * radius**2 * height:.2f}
   = **{volume:.2f} {unit}³**

**3. Curved Surface Area (CSA) = πrl**
   = {pi:.3f} × {radius} × {slant_height:.2f}
   = **{csa:.2f} {unit}²**

**4. Total Surface Area (TSA) = πr(r + l)**
   = {pi:.3f} × {radius} × ({radius} + {slant_height:.2f})
   = {pi:.3f} × {radius} × {radius + slant_height:.2f}
   = **{tsa:.2f} {unit}²**

💡 **Summary:**
• Volume = {volume:.2f} {unit}³
• CSA = {csa:.2f} {unit}²
• TSA = {tsa:.2f} {unit}²
• Slant Height = {slant_height:.2f} {unit}
"""
        
        return result
        
    except Exception as e:
        return f"❌ Error solving cone problem: {str(e)}"

def find_missing_cone_parameter(known_params: Dict[str, Any]) -> str:
    """
    Find missing parameter when volume or surface area is given.
    """
    try:
        pi = 22/7
        
        if "volume" in known_params and "radius" in known_params:
            # Find height
            volume = known_params["volume"]
            radius = known_params["radius"]
            height = (3 * volume) / (pi * radius**2)
            slant_height = math.sqrt(radius**2 + height**2)
            
            return f"""
✅ **Finding Height of Cone:**

Given:
• Volume = {volume} cm³
• Radius = {radius} cm

Using V = ⅓πr²h:
{volume} = ⅓ × {pi:.3f} × {radius}² × h
{volume} = ⅓ × {pi * radius**2:.2f} × h
h = {3 * volume} ÷ {pi * radius**2:.2f}
**h = {height:.2f} cm**

Slant height: l = √(r² + h²) = √({radius}² + {height:.2f}²) = **{slant_height:.2f} cm**
"""
        
        elif "csa" in known_params and "radius" in known_params:
            # Find slant height
            csa = known_params["csa"]
            radius = known_params["radius"]
            slant_height = csa / (pi * radius)
            
            return f"""
✅ **Finding Slant Height of Cone:**

Given:
• CSA = {csa} cm²
• Radius = {radius} cm

Using CSA = πrl:
{csa} = {pi:.3f} × {radius} × l
l = {csa} ÷ ({pi:.3f} × {radius})
**l = {slant_height:.2f} cm**
"""
        
        return "❌ Need appropriate parameters to find the missing value."
        
    except Exception as e:
        return f"❌ Error finding missing parameter: {str(e)}"
--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/sub_chapters/cone/__pycache__/solver_cone.cpython-310.pyc ###

### File: chapters/chapter12_surface_areas_and_volumes/sub_chapters/cone/__pycache__/solver_cone.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0x86 in position 12: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/sub_chapters/combined_solids/solver_combined.py ###
import math
from typing import Dict, Any

def solve_combined_solid(params: Dict[str, Any]) -> str:
    """
    Solve combined solid problems (e.g., cone on hemisphere, capsule).
    """
    try:
        solid_type = params.get("type", "").lower()
        
        if "cone" in solid_type and "hemisphere" in solid_type:
            return solve_cone_on_hemisphere(params)
        elif "capsule" in solid_type or ("cylinder" in solid_type and "hemisphere" in solid_type):
            return solve_capsule(params)
        elif "toy" in solid_type or "cone on cylinder" in solid_type:
            return solve_toy_shape(params)
        else:
            return "❌ Unknown combined solid type. Supported: cone on hemisphere, capsule, toy (cone on cylinder)"
            
    except Exception as e:
        return f"❌ Error solving combined solid: {str(e)}"

def solve_cone_on_hemisphere(params: Dict[str, Any]) -> str:
    """
    Solve problems for cone mounted on hemisphere (ice cream cone shape).
    """
    radius = params.get("radius", 0)
    cone_height = params.get("cone_height", params.get("height", 0))
    unit = params.get("unit", "cm")
    
    if radius <= 0 or cone_height <= 0:
        return "❌ Need radius and cone height for this combined solid."
    
    pi = 22/7
    
    # Calculate individual components
    # Hemisphere
    hemi_volume = (2/3) * pi * radius**3
    hemi_csa = 2 * pi * radius**2
    
    # Cone
    slant_height = math.sqrt(radius**2 + cone_height**2)
    cone_volume = (1/3) * pi * radius**2 * cone_height
    cone_csa = pi * radius * slant_height
    
    # Combined
    total_volume = hemi_volume + cone_volume
    total_surface_area = hemi_csa + cone_csa
    
    result = f"""
✅ **Cone on Hemisphere (Ice Cream Shape) Solution:**

Given:
• Common Radius (r) = {radius} {unit}
• Height of Cone (h) = {cone_height} {unit}
• Slant Height of Cone (l) = √(r² + h²) = {slant_height:.2f} {unit}

📝 **Step-by-Step Solution:**

**Part 1: Hemisphere**
• Volume = ⅔πr³ = ⅔ × {pi:.3f} × {radius}³ = {hemi_volume:.2f} {unit}³
• CSA = 2πr² = 2 × {pi:.3f} × {radius}² = {hemi_csa:.2f} {unit}²

**Part 2: Cone**
• Volume = ⅓πr²h = ⅓ × {pi:.3f} × {radius}² × {cone_height} = {cone_volume:.2f} {unit}³
• CSA = πrl = {pi:.3f} × {radius} × {slant_height:.2f} = {cone_csa:.2f} {unit}²

**Combined Solid:**
• **Total Volume** = {hemi_volume:.2f} + {cone_volume:.2f} = **{total_volume:.2f} {unit}³**
• **Total Surface Area** = {hemi_csa:.2f} + {cone_csa:.2f} = **{total_surface_area:.2f} {unit}²**

💡 **Summary:**
• Total Volume = {total_volume:.2f} {unit}³
• Total Surface Area = {total_surface_area:.2f} {unit}²
"""
    
    return result

def solve_capsule(params: Dict[str, Any]) -> str:
    """
    Solve capsule (cylinder with hemispheres on both ends).
    """
    radius = params.get("radius", 0)
    cylinder_height = params.get("cylinder_height", params.get("height", 0))
    unit = params.get("unit", "cm")
    
    if radius <= 0 or cylinder_height <= 0:
        return "❌ Need radius and cylinder height for capsule."
    
    pi = 22/7
    
    # Cylinder part
    cyl_volume = pi * radius**2 * cylinder_height
    cyl_csa = 2 * pi * radius * cylinder_height
    
    # Two hemispheres = 1 sphere
    sphere_volume = (4/3) * pi * radius**3
    sphere_sa = 4 * pi * radius**2
    
    # Total
    total_volume = cyl_volume + sphere_volume
    total_surface_area = cyl_csa + sphere_sa
    total_height = cylinder_height + 2 * radius
    
    result = f"""
✅ **Capsule Solution:**

Given:
• Radius (r) = {radius} {unit}
• Cylinder Height (h) = {cylinder_height} {unit}
• Total Height = h + 2r = {total_height} {unit}

📝 **Step-by-Step Solution:**

**Part 1: Cylinder**
• Volume = πr²h = {pi:.3f} × {radius}² × {cylinder_height} = {cyl_volume:.2f} {unit}³
• CSA = 2πrh = 2 × {pi:.3f} × {radius} × {cylinder_height} = {cyl_csa:.2f} {unit}²

**Part 2: Two Hemispheres (= 1 Sphere)**
• Volume = ⁴⁄₃πr³ = ⁴⁄₃ × {pi:.3f} × {radius}³ = {sphere_volume:.2f} {unit}³
• Surface Area = 4πr² = 4 × {pi:.3f} × {radius}² = {sphere_sa:.2f} {unit}²

**Combined Capsule:**
• **Total Volume** = {cyl_volume:.2f} + {sphere_volume:.2f} = **{total_volume:.2f} {unit}³**
• **Total Surface Area** = {cyl_csa:.2f} + {sphere_sa:.2f} = **{total_surface_area:.2f} {unit}²**

💡 **Summary:**
• Total Volume = {total_volume:.2f} {unit}³
• Total Surface Area = {total_surface_area:.2f} {unit}²
• Total Height = {total_height} {unit}
"""
    
    return result

def solve_toy_shape(params: Dict[str, Any]) -> str:
    """
    Solve toy shape (cone on cylinder).
    """
    radius = params.get("radius", 0)
    cylinder_height = params.get("cylinder_height", 0)
    cone_height = params.get("cone_height", 0)
    unit = params.get("unit", "cm")
    
    if radius <= 0 or cylinder_height <= 0 or cone_height <= 0:
        return "❌ Need radius, cylinder height, and cone height."
    
    pi = 22/7
    
    # Cylinder
    cyl_volume = pi * radius**2 * cylinder_height
    cyl_csa = 2 * pi * radius * cylinder_height
    cyl_base = pi * radius**2
    
    # Cone
    slant_height = math.sqrt(radius**2 + cone_height**2)
    cone_volume = (1/3) * pi * radius**2 * cone_height
    cone_csa = pi * radius * slant_height
    
    # Combined
    total_volume = cyl_volume + cone_volume
    total_surface_area = cyl_csa + cyl_base + cone_csa  # One base of cylinder
    total_height = cylinder_height + cone_height
    
    result = f"""
✅ **Toy Shape (Cone on Cylinder) Solution:**

Given:
• Radius (r) = {radius} {unit}
• Cylinder Height = {cylinder_height} {unit}
• Cone Height = {cone_height} {unit}
• Total Height = {total_height} {unit}

📝 **Step-by-Step Solution:**

**Part 1: Cylinder**
• Volume = πr²h = {cyl_volume:.2f} {unit}³
• CSA = 2πrh = {cyl_csa:.2f} {unit}²
• Base Area = πr² = {cyl_base:.2f} {unit}²

**Part 2: Cone**
• Slant Height = √(r² + h²) = {slant_height:.2f} {unit}
• Volume = ⅓πr²h = {cone_volume:.2f} {unit}³
• CSA = πrl = {cone_csa:.2f} {unit}²

**Combined Toy:**
• **Total Volume** = {total_volume:.2f} {unit}³
• **Total Surface Area** = {cyl_csa:.2f} + {cyl_base:.2f} + {cone_csa:.2f} = **{total_surface_area:.2f} {unit}²**

💡 **Summary:**
• Total Volume = {total_volume:.2f} {unit}³
• Total Surface Area = {total_surface_area:.2f} {unit}²
• Total Height = {total_height} {unit}
"""
    
    return result
--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/sub_chapters/combined_solids/__pycache__/solver_combined.cpython-310.pyc ###

### File: chapters/chapter12_surface_areas_and_volumes/sub_chapters/combined_solids/__pycache__/solver_combined.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0x8c in position 12: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/plots/net_diagram.png ###

### File: chapters/chapter12_surface_areas_and_volumes/plots/net_diagram.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/plots/cuboid_plot.png ###

### File: chapters/chapter12_surface_areas_and_volumes/plots/cuboid_plot.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/plots/cone_plot.png ###

### File: chapters/chapter12_surface_areas_and_volumes/plots/cone_plot.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/plots/sphere_plot.png ###

### File: chapters/chapter12_surface_areas_and_volumes/plots/sphere_plot.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/plots/cylinder_plot.png ###

### File: chapters/chapter12_surface_areas_and_volumes/plots/cylinder_plot.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/__pycache__/interpret_query_solids.cpython-310.pyc ###

### File: chapters/chapter12_surface_areas_and_volumes/__pycache__/interpret_query_solids.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xc7 in position 8: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/__pycache__/main_router.cpython-310.pyc ###

### File: chapters/chapter12_surface_areas_and_volumes/__pycache__/main_router.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xfc in position 12: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter12_surface_areas_and_volumes/__pycache__/plot_solids.cpython-310.pyc ###

### File: chapters/chapter12_surface_areas_and_volumes/__pycache__/plot_solids.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xc5 in position 9: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter1_real_numbers/__init__.py ###
"""
chapters.chapter1_real_numbers package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter1_real_numbers/sub_chapters/__init__.py ###
"""
chapters.chapter1_real_numbers.sub_chapters package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter1_real_numbers/sub_chapters/euclid_division/__init__.py ###
"""
chapters.chapter1_real_numbers.sub_chapters.euclid_division package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter1_real_numbers/sub_chapters/irrationality_proofs/__init__.py ###
"""
chapters.chapter1_real_numbers.sub_chapters.irrationality_proofs package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/test_triangle_calc.py ###
import math
from typing import Dict, Any
import matplotlib.pyplot as plt
import numpy as np
import os

def test_right_triangle_calc():
    """Test right triangle calculations with different input cases."""
    
    # Test Case 1: Base and Height
    params1 = {
        "base": 3,
        "height": 4
    }
    
    # Test Case 2: Hypotenuse and Angle
    params2 = {
        "hypotenuse": 5,
        "angle": 36.87
    }
    
    # Test Case 3: Hypotenuse and Base
    params3 = {
        "hypotenuse": 5,
        "base": 3
    }
    
    print("\n=== Test Case 1: Base and Height ===")
    result1 = solve_right_triangle(params1)
    print(result1)
    
    print("\n=== Test Case 2: Hypotenuse and Angle ===")
    result2 = solve_right_triangle(params2)
    print(result2)
    
    print("\n=== Test Case 3: Hypotenuse and Base ===")
    result3 = solve_right_triangle(params3)
    print(result3)

def solve_right_triangle(params: Dict[str, Any]) -> str:
    """
    Solve right triangle problems: hypotenuse, angles, area, perimeter + plot.
    """
    try:
        base = params.get("base", 0)
        height = params.get("height", 0)
        hypotenuse = params.get("hypotenuse", 0)
        angle = params.get("angle", 0)
        
        plot_path = None

        # Case 1: Given base and height
        if base > 0 and height > 0:
            # Calculate hypotenuse using Pythagorean theorem
            hypotenuse = math.sqrt(base**2 + height**2)
            # Calculate angles using inverse tangent
            angle_B = math.degrees(math.atan(height / base))
            angle_A = 90 - angle_B
            # Calculate area and perimeter
            area = 0.5 * base * height
            perimeter = base + height + hypotenuse
            # Order sides: [base, height, hypotenuse]
            sides = [base, height, hypotenuse]
            # Order angles: [angle_A, angle_B, 90]
            angles = [round(angle_A, 1), round(angle_B, 1), 90]
            plot_path = plot_triangle(sides, angles, "test_right_triangle1.png")
            
            result = f"""
✅ **Right Triangle Solution:**

Given:
• Base = {base} cm  
• Height = {height} cm  

📝 **Step-by-Step Calculations:**

1. **Hypotenuse (c):**
   • Using Pythagorean theorem: c = √(a² + b²)
   • c = √({base}² + {height}²)
   • c = √({base**2} + {height**2})
   • c = √{base**2 + height**2}
   • c = **{hypotenuse:.2f} cm**

2. **Angles:**
   • Angle B = tan⁻¹(height/base)
   • Angle B = tan⁻¹({height}/{base})
   • Angle B = tan⁻¹({height/base:.2f})
   • Angle B = **{angle_B:.1f}°**
   
   • Angle A = 90° - Angle B
   • Angle A = 90° - {angle_B:.1f}°
   • Angle A = **{angle_A:.1f}°**

3. **Area:**
   • Area = ½ × base × height
   • Area = ½ × {base} × {height}
   • Area = **{area:.2f} cm²**

4. **Perimeter:**
   • Perimeter = base + height + hypotenuse
   • Perimeter = {base} + {height} + {hypotenuse:.2f}
   • Perimeter = **{perimeter:.2f} cm**

📊 **Visualization:**

![Right Triangle]({plot_path})
"""
        
        # Case 2: Given hypotenuse and one angle
        elif hypotenuse > 0 and angle > 0 and angle < 90:
            # Convert angle to radians for calculations
            angle_rad = math.radians(angle)
            # Calculate base and height using trigonometric ratios
            base = hypotenuse * math.cos(angle_rad)
            height = hypotenuse * math.sin(angle_rad)
            other_angle = 90 - angle
            area = 0.5 * base * height
            # Order sides: [base, height, hypotenuse]
            sides = [base, height, hypotenuse]
            # Order angles: [angle, other_angle, 90]
            angles = [round(angle, 1), round(other_angle, 1), 90]
            plot_path = plot_triangle(sides, angles, "test_right_triangle2.png")

            result = f"""
✅ **Right Triangle Solution:**

Given:
• Hypotenuse = {hypotenuse} cm  
• Angle = {angle}°

📝 **Step-by-Step Calculations:**

1. **Base (a):**
   • Using cosine: a = hypotenuse × cos(angle)
   • a = {hypotenuse} × cos({angle}°)
   • a = {hypotenuse} × {math.cos(angle_rad):.4f}
   • a = **{base:.2f} cm**

2. **Height (b):**
   • Using sine: b = hypotenuse × sin(angle)
   • b = {hypotenuse} × sin({angle}°)
   • b = {hypotenuse} × {math.sin(angle_rad):.4f}
   • b = **{height:.2f} cm**

3. **Other Angle:**
   • Other Angle = 90° - {angle}°
   • Other Angle = **{other_angle:.1f}°**

4. **Area:**
   • Area = ½ × base × height
   • Area = ½ × {base:.2f} × {height:.2f}
   • Area = **{area:.2f} cm²**

📊 **Visualization:**

![Right Triangle]({plot_path})
"""

        # Case 3: Given hypotenuse and one side
        elif hypotenuse > 0 and (base > 0 or height > 0):
            if base > 0:
                # Calculate height using Pythagorean theorem
                height = math.sqrt(hypotenuse**2 - base**2)
                known_side = "base"
                known_value = base
                other_side = height
                other_name = "height"
            else:
                # Calculate base using Pythagorean theorem
                base = math.sqrt(hypotenuse**2 - height**2)
                known_side = "height"
                known_value = height
                other_side = base
                other_name = "base"

            # Calculate angles using inverse tangent
            angle_B = math.degrees(math.atan(height / base))
            angle_A = 90 - angle_B
            area = 0.5 * base * height
            # Order sides: [base, height, hypotenuse]
            sides = [base, height, hypotenuse]
            # Order angles: [angle_A, angle_B, 90]
            angles = [round(angle_A, 1), round(angle_B, 1), 90]
            plot_path = plot_triangle(sides, angles, "test_right_triangle3.png")

            result = f"""
✅ **Right Triangle Solution:**

Given:
• Hypotenuse = {hypotenuse} cm  
• {known_side.capitalize()} = {known_value} cm

📝 **Step-by-Step Calculations:**

1. **{other_name.capitalize()}:**
   • Using Pythagorean theorem: {other_name} = √(hypotenuse² - {known_side}²)
   • {other_name} = √({hypotenuse}² - {known_value}²)
   • {other_name} = √({hypotenuse**2} - {known_value**2})
   • {other_name} = √{hypotenuse**2 - known_value**2}
   • {other_name} = **{other_side:.2f} cm**

2. **Angles:**
   • Angle B = tan⁻¹({other_name}/{known_side})
   • Angle B = tan⁻¹({other_side:.2f}/{known_value})
   • Angle B = tan⁻¹({other_side/known_value:.2f})
   • Angle B = **{angle_B:.1f}°**
   
   • Angle A = 90° - Angle B
   • Angle A = 90° - {angle_B:.1f}°
   • Angle A = **{angle_A:.1f}°**

3. **Area:**
   • Area = ½ × base × height
   • Area = ½ × {base:.2f} × {height:.2f}
   • Area = **{area:.2f} cm²**

📊 **Visualization:**

![Right Triangle]({plot_path})
"""
        
        else:
            result = "❌ Insufficient data. Need at least:\n• Base and height, OR\n• Hypotenuse and one angle, OR\n• Hypotenuse and one other side."
        
        return result

    except Exception as e:
        return f"❌ Error solving right triangle: {str(e)}"

def plot_triangle(sides, angles, save_name="triangle_plot.png"):
    """Plot a triangle with given sides and angles."""
    # Create figure and axis
    fig, ax = plt.subplots(figsize=(10, 10))
    
    # Calculate coordinates using law of cosines
    a, b, c = sides
    A, B, C = angles
    
    # For right triangles, place the right angle at the origin
    if C == 90:  # Right angle is C
        x1, y1 = 0, 0  # Right angle vertex
        x2, y2 = a, 0  # Base vertex
        x3, y3 = 0, b  # Height vertex
    elif B == 90:  # Right angle is B
        x1, y1 = 0, 0  # Right angle vertex
        x2, y2 = c, 0  # Base vertex
        x3, y3 = c, a  # Height vertex
    else:  # Right angle is A
        x1, y1 = 0, 0  # Right angle vertex
        x2, y2 = b, 0  # Base vertex
        x3, y3 = 0, c  # Height vertex
    
    # Plot triangle
    ax.plot([x1, x2], [y1, y2], 'b-', linewidth=2)  # Base
    ax.plot([x1, x3], [y1, y3], 'b-', linewidth=2)  # Height
    ax.plot([x2, x3], [y2, y3], 'b-', linewidth=2)  # Hypotenuse
    
    # Add angle arcs
    def plot_angle_arc(x, y, angle, radius, start_angle=0):
        arc_theta = np.linspace(start_angle, start_angle + np.radians(angle), 100)
        arc_x = x + radius * np.cos(arc_theta)
        arc_y = y + radius * np.sin(arc_theta)
        ax.plot(arc_x, arc_y, 'r-')
        # Adjust text position to be inside the triangle
        text_x = x + radius*0.5*np.cos(np.radians(start_angle + angle/2))
        text_y = y + radius*0.5*np.sin(np.radians(start_angle + angle/2))
        ax.text(text_x, text_y, f'{angle}°', ha='center', va='center')
    
    # Plot angle arcs with smaller radius
    arc_radius = min(a, b, c) * 0.15
    plot_angle_arc(x1, y1, A, arc_radius)
    plot_angle_arc(x2, y2, B, arc_radius, start_angle=180)
    plot_angle_arc(x3, y3, C, arc_radius, start_angle=-B)
    
    # Add side labels with correct positions
    ax.text((x1 + x2)/2, -0.5, f'Base = {a:.1f} cm', ha='center')
    ax.text(-0.5, (y1 + y3)/2, f'Hypotenuse = {b:.1f} cm', va='center')
    ax.text((x2 + x3)/2, (y2 + y3)/2, f'Height = {c:.1f} cm', ha='center')
    
    # Calculate and display area
    area = 0.5 * a * c  # For right triangle
    ax.text(-max(sides), max(sides), f'Area = {area:.2f} cm²',
            bbox=dict(facecolor='white', alpha=0.8))
    
    # Set equal aspect ratio and limits
    ax.set_aspect('equal')
    margin = max(sides) * 0.2
    ax.set_xlim(-margin, max(sides) + margin)
    ax.set_ylim(-margin, max(sides) + margin)
    
    # Remove axes
    ax.axis('off')
    
    # Create plots directory if it doesn't exist
    os.makedirs('chapters/chapter6_triangles/plots', exist_ok=True)
    
    # Save the plot
    plt.savefig(f'chapters/chapter6_triangles/plots/{save_name}',
                bbox_inches='tight', dpi=300)
    plt.close()
    
    return f'chapters/chapter6_triangles/plots/{save_name}'

if __name__ == "__main__":
    test_right_triangle_calc() 
--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/__init__.py ###
"""
chapters.chapter6_triangles package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/main_router.py ###
# File: chapters/chapter6_triangles/main_router.py

import re
import math
from typing import Dict, Any, List, Tuple, Optional

# Import your solvers with CORRECT paths and error handling
try:
    from chapters.chapter6_triangles.sub_chapters.right_triangle.solver_right_triangle import solve_right_triangle
except ImportError:
    def solve_right_triangle(params):
        return "❌ Right triangle solver not available. Check solver_right_triangle.py file."

try:
    from chapters.chapter6_triangles.sub_chapters.similar_triangles.solver_similar import solve_similar_triangles
    # Try to also import the similarity check function
    try:
        from chapters.chapter6_triangles.sub_chapters.similar_triangles.solver_similar import check_similarity_sss
    except ImportError:
        def check_similarity_sss(triangle1, triangle2):
            return check_similarity_sss_inline(triangle1, triangle2)
except ImportError:
    def solve_similar_triangles(params):
        return "❌ Similar triangles solver not available. Check solver_similar.py file."
    def check_similarity_sss(triangle1, triangle2):
        return check_similarity_sss_inline(triangle1, triangle2)

try:
    from chapters.chapter6_triangles.sub_chapters.basic_proportionality.solver_bpt import solve_bpt
except ImportError:
    def solve_bpt(params):
        return "❌ BPT solver not available. Check solver_bpt.py file."

try:
    from chapters.chapter6_triangles.interpret_query_triangles import interpret_query_triangles, extract_triangle_measurements
except ImportError:
    def interpret_query_triangles(query):
        return {"intent": "error", "error": "LLM interpreter not available"}
    def extract_triangle_measurements(query):
        return {}

def route_query(query: str) -> str:
    """
    Main router function that parses natural language queries 
    and routes them to appropriate triangle solvers.
    """
    try:
        if not query or not query.strip():
            return "❌ Please enter a query about triangles."
        
        query = query.lower().strip()
        
        # First try using your existing LLM interpreter
        try:
            llm_result = interpret_query_triangles(query)
            if llm_result.get("intent") != "error" and llm_result.get("intent") != "unknown":
                return route_by_intent(llm_result)
        except:
            # Fall back to regex parsing if LLM fails
            pass
        
        # Fallback: Parse the query and determine the type using regex
        query_type, params = parse_triangle_query(query)
        
        # Route to appropriate solver
        if query_type == "right_triangle":
            return solve_right_triangle(params)
        elif query_type == "similar_triangles":
            return solve_similar_triangles(params)
        elif query_type == "similarity_check":
            # Try to use the similarity check function if available
            try:
                return check_similarity_sss(params.get('triangle1', []), params.get('triangle2', []))
            except:
                # Fallback to inline similarity check
                return check_similarity_sss_inline(params.get('triangle1', []), params.get('triangle2', []))
        elif query_type == "bpt":
            return solve_bpt(params)
        elif query_type == "area":
            return calculate_triangle_area(params)
        elif query_type == "angles":
            return calculate_triangle_angles_from_sides(params)
        else:
            return generate_help_message(query)
            
    except Exception as e:
        return f"❌ Error processing query: {str(e)}\n\n" + generate_help_message(query)

def route_by_intent(llm_result: dict) -> str:
    """Route based on LLM interpretation."""
    intent = llm_result.get("intent")
    params = llm_result.get("parameters", {})
    
    if intent == "solve_right_triangle":
        return solve_right_triangle(params)
    elif intent == "check_similarity":
        # Convert parameters to expected format
        if "triangle1" in params and "triangle2" in params:
            try:
                return check_similarity_sss(params["triangle1"], params["triangle2"])
            except:
                return check_similarity_sss_inline(params["triangle1"], params["triangle2"])
        else:
            return "❌ Need two triangles to check similarity"
    elif intent == "calculate_area":
        return calculate_triangle_area(params)
    elif intent == "apply_bpt":
        return solve_bpt(params)
    else:
        return generate_help_message(str(llm_result))

def parse_triangle_query(query: str) -> Tuple[str, Dict[str, Any]]:
    """
    Parse natural language query and extract parameters using regex.
    """
    query = query.lower().strip()
    
    # Use your existing extraction function
    measurements = extract_triangle_measurements(query)
    
    # Extract numbers from the query
    numbers = extract_numbers(query)
    
    # Right triangle patterns
    right_triangle_keywords = [
        "right triangle", "hypotenuse", "pythagorean", 
        "base and height", "90 degree", "right angle"
    ]
    
    # Similar triangles patterns
    similar_keywords = [
        "similar", "similarity", "check if", "are triangles similar",
        "similar triangles", "proportional"
    ]
    
    # BPT patterns
    bpt_keywords = [
        "bpt", "basic proportionality", "thales", "parallel", 
        "proportional segments", "divides proportionally"
    ]
    
    # Area patterns
    area_keywords = [
        "area", "heron", "heron's formula", "find area"
    ]
    
    # Angle patterns
    angle_keywords = [
        "angles", "find angles", "calculate angles", "angle"
    ]
    
    # Determine query type and extract parameters
    if any(keyword in query for keyword in right_triangle_keywords):
        return "right_triangle", parse_right_triangle_params(query, numbers, measurements)
    
    elif any(keyword in query for keyword in similar_keywords):
        if "check" in query or "are" in query:
            return "similarity_check", parse_similarity_check_params(query, numbers, measurements)
        else:
            return "similar_triangles", parse_similarity_check_params(query, numbers, measurements)
    
    elif any(keyword in query for keyword in bpt_keywords):
        return "bpt", parse_bpt_params(query, numbers)
    
    elif any(keyword in query for keyword in area_keywords):
        return "area", parse_area_params(query, numbers, measurements)
    
    elif any(keyword in query for keyword in angle_keywords):
        return "angles", parse_angle_params(query, numbers, measurements)
    
    # Auto-detect based on numbers provided
    elif len(numbers) >= 2:
        return auto_detect_query_type(query, numbers)
    
    else:
        return "unknown", {}

def extract_numbers(text: str) -> List[float]:
    """Extract all numbers from text."""
    # Pattern to match integers and decimals
    pattern = r'\b\d+\.?\d*\b'
    matches = re.findall(pattern, text)
    return [float(match) for match in matches]

def parse_right_triangle_params(query: str, numbers: List[float], measurements: dict) -> Dict[str, Any]:
    """Parse parameters for right triangle problems."""
    params = {}
    
    # Use measurements from your existing function first
    if "base" in measurements:
        params["base"] = measurements["base"]
    if "height" in measurements:
        params["height"] = measurements["height"]
    
    # Fallback to positional parsing
    if "base" in query and "height" in query and len(numbers) >= 2:
        if "base" not in params:
            params["base"] = numbers[0]
        if "height" not in params:
            params["height"] = numbers[1]
    elif "hypotenuse" in query and len(numbers) >= 2:
        if "base" in query:
            params["hypotenuse"] = numbers[0]
            params["base"] = numbers[1]
        elif "height" in query:
            params["hypotenuse"] = numbers[0]
            params["height"] = numbers[1]
        else:
            params["hypotenuse"] = numbers[0]
            params["angle"] = numbers[1]
    elif len(numbers) == 2:
        # Default: assume base and height
        params["base"] = numbers[0]
        params["height"] = numbers[1]
    
    return params

def parse_similarity_check_params(query: str, numbers: List[float], measurements: dict) -> Dict[str, Any]:
    """Parse parameters for similarity check."""
    
    # Use your existing measurements extraction
    if "triangles" in measurements and len(measurements["triangles"]) >= 2:
        return {
            "triangle1": measurements["triangles"][0],
            "triangle2": measurements["triangles"][1]
        }
    
    if len(numbers) >= 6:
        return {
            "triangle1": numbers[:3],
            "triangle2": numbers[3:6]
        }
    else:
        # Look for patterns like (3,4,5) and (6,8,10)
        pattern = r'\(([^)]+)\)'
        matches = re.findall(pattern, query)
        if len(matches) >= 2:
            try:
                triangle1 = [float(x.strip()) for x in matches[0].split(',')]
                triangle2 = [float(x.strip()) for x in matches[1].split(',')]
                return {"triangle1": triangle1, "triangle2": triangle2}
            except:
                pass
        
        return {"triangle1": [], "triangle2": []}

def parse_bpt_params(query: str, numbers: List[float]) -> Dict[str, Any]:
    """Parse parameters for BPT problems."""
    return {
        "type": "verify_parallel",
        "segments": numbers[:4] if len(numbers) >= 4 else numbers
    }

def parse_area_params(query: str, numbers: List[float], measurements: dict) -> Dict[str, Any]:
    """Parse parameters for area calculations."""
    
    # Use existing measurements first
    if "sides" in measurements:
        return {"sides": measurements["sides"]}
    elif "base" in measurements and "height" in measurements:
        return {"base": measurements["base"], "height": measurements["height"]}
    
    # Fallback to positional
    if len(numbers) >= 3:
        return {"sides": numbers[:3]}
    elif len(numbers) == 2:
        return {"base": numbers[0], "height": numbers[1]}
    else:
        return {"sides": numbers}

def parse_angle_params(query: str, numbers: List[float], measurements: dict) -> Dict[str, Any]:
    """Parse parameters for angle calculations."""
    
    # Use existing measurements first
    if "sides" in measurements:
        return {"sides": measurements["sides"]}
    
    if len(numbers) >= 3:
        return {"sides": numbers[:3]}
    else:
        return {"sides": numbers}

def auto_detect_query_type(query: str, numbers: List[float]) -> Tuple[str, Dict[str, Any]]:
    """Auto-detect query type based on context and numbers."""
    if len(numbers) == 2:
        return "right_triangle", {"base": numbers[0], "height": numbers[1]}
    elif len(numbers) == 3:
        return "area", {"sides": numbers}
    elif len(numbers) == 6:
        return "similarity_check", {
            "triangle1": numbers[:3], 
            "triangle2": numbers[3:]
        }
    else:
        return "unknown", {}

def calculate_triangle_area(params: Dict[str, Any]) -> str:
    """Calculate triangle area using different methods."""
    try:
        if "sides" in params and len(params["sides"]) >= 3:
            # Use Heron's formula
            a, b, c = params["sides"][:3]
            
            # Check if triangle is valid
            if not (a + b > c and b + c > a and a + c > b):
                return "❌ Invalid triangle! The sum of any two sides must be greater than the third side."
            
            # Calculate semi-perimeter
            s = (a + b + c) / 2
            
            # Heron's formula
            area = math.sqrt(s * (s - a) * (s - b) * (s - c))
            
            return f"""
✅ **Triangle Area Calculation (Heron's Formula):**

Given sides:
• a = {a} cm
• b = {b} cm  
• c = {c} cm

📝 **Step-by-Step Calculation:**

1. **Semi-perimeter (s):**
   • s = (a + b + c) / 2
   • s = ({a} + {b} + {c}) / 2
   • s = {a + b + c} / 2
   • s = {s} cm

2. **Heron's Formula:**
   • Area = √[s(s-a)(s-b)(s-c)]
   • Area = √[{s} × ({s}-{a}) × ({s}-{b}) × ({s}-{c})]
   • Area = √[{s} × {s-a} × {s-b} × {s-c}]
   • Area = √{s * (s-a) * (s-b) * (s-c)}
   • Area = **{area:.2f} cm²**

💡 **Additional Information:**
• Perimeter = {a + b + c} cm
• This triangle is {'right-angled' if abs(a**2 + b**2 - c**2) < 0.001 or abs(b**2 + c**2 - a**2) < 0.001 or abs(a**2 + c**2 - b**2) < 0.001 else 'not right-angled'}
"""
        
        elif "base" in params and "height" in params:
            # Use base × height / 2
            base = params["base"]
            height = params["height"]
            area = 0.5 * base * height
            
            return f"""
✅ **Triangle Area Calculation (Base × Height):**

Given:
• Base = {base} cm
• Height = {height} cm

📝 **Calculation:**
• Area = ½ × base × height
• Area = ½ × {base} × {height}
• Area = **{area:.2f} cm²**
"""
        
        else:
            return "❌ Insufficient data for area calculation. Need either 3 sides or base and height."
            
    except Exception as e:
        return f"❌ Error calculating area: {str(e)}"

def calculate_triangle_angles_from_sides(params: Dict[str, Any]) -> str:
    """Calculate all angles of a triangle from its sides."""
    try:
        if "sides" not in params or len(params["sides"]) < 3:
            return "❌ Need all three sides to calculate angles."
        
        a, b, c = params["sides"][:3]
        
        # Check if triangle is valid
        if not (a + b > c and b + c > a and a + c > b):
            return "❌ Invalid triangle! The sum of any two sides must be greater than the third side."
        
        # Use law of cosines to find angles
        # cos(A) = (b² + c² - a²) / (2bc)
        cos_A = (b**2 + c**2 - a**2) / (2 * b * c)
        cos_B = (a**2 + c**2 - b**2) / (2 * a * c)
        cos_C = (a**2 + b**2 - c**2) / (2 * a * b)
        
        # Convert to degrees
        angle_A = math.degrees(math.acos(max(-1, min(1, cos_A))))
        angle_B = math.degrees(math.acos(max(-1, min(1, cos_B))))
        angle_C = math.degrees(math.acos(max(-1, min(1, cos_C))))
        
        return f"""
✅ **Triangle Angles Calculation (Law of Cosines):**

Given sides:
• a = {a} cm (opposite to angle A)
• b = {b} cm (opposite to angle B)
• c = {c} cm (opposite to angle C)

📝 **Step-by-Step Calculation:**

1. **Angle A:**
   • cos(A) = (b² + c² - a²) / (2bc)
   • cos(A) = ({b}² + {c}² - {a}²) / (2 × {b} × {c})
   • cos(A) = ({b**2} + {c**2} - {a**2}) / {2*b*c}
   • cos(A) = {b**2 + c**2 - a**2} / {2*b*c}
   • cos(A) = {cos_A:.4f}
   • A = **{angle_A:.1f}°**

2. **Angle B:**
   • cos(B) = (a² + c² - b²) / (2ac)
   • B = **{angle_B:.1f}°**

3. **Angle C:**
   • cos(C) = (a² + b² - c²) / (2ab)
   • C = **{angle_C:.1f}°**

✅ **Verification:**
• Sum of angles = {angle_A:.1f}° + {angle_B:.1f}° + {angle_C:.1f}° = {angle_A + angle_B + angle_C:.1f}°
• Should equal 180° ✓

💡 **Triangle Type:**
• This is a {'right-angled' if abs(max(angle_A, angle_B, angle_C) - 90) < 0.1 else 'acute' if max(angle_A, angle_B, angle_C) < 90 else 'obtuse'} triangle
"""
        
    except Exception as e:
        return f"❌ Error calculating angles: {str(e)}"

def check_similarity_sss_inline(triangle1: List[float], triangle2: List[float]) -> str:
    """
    Check if two triangles are similar using SSS criterion.
    """
    if len(triangle1) != 3 or len(triangle2) != 3:
        return "❌ Each triangle must have exactly 3 sides"
    
    if not triangle1 or not triangle2:
        return "❌ Please provide valid triangle sides"
    
    # Sort sides to match corresponding sides
    a1, b1, c1 = sorted(triangle1)
    a2, b2, c2 = sorted(triangle2)
    
    # Calculate ratios
    ratio_a = a2 / a1
    ratio_b = b2 / b1
    ratio_c = c2 / c1
    
    # Check if all ratios are equal (within tolerance)
    tolerance = 0.001
    is_similar = (abs(ratio_a - ratio_b) < tolerance and 
                  abs(ratio_b - ratio_c) < tolerance and 
                  abs(ratio_a - ratio_c) < tolerance)
    
    result = f"""
✅ **Similar Triangles Check (SSS Criterion):**

**Triangle 1:** Sides = {triangle1[0]}, {triangle1[1]}, {triangle1[2]} cm
**Triangle 2:** Sides = {triangle2[0]}, {triangle2[1]}, {triangle2[2]} cm

📝 **Step-by-Step Analysis:**

**1. Sorting sides (smallest to largest):**
   • Triangle 1: {a1}, {b1}, {c1}
   • Triangle 2: {a2}, {b2}, {c2}

**2. Calculating ratios of corresponding sides:**
   • Ratio 1: {a2}/{a1} = {ratio_a:.3f}
   • Ratio 2: {b2}/{b1} = {ratio_b:.3f}
   • Ratio 3: {c2}/{c1} = {ratio_c:.3f}

**3. Checking if all ratios are equal:**
   • Difference between ratios: {abs(ratio_a - ratio_b):.6f}, {abs(ratio_b - ratio_c):.6f}, {abs(ratio_a - ratio_c):.6f}
   • All differences < 0.001? {'YES ✓' if is_similar else 'NO ✗'}

💡 **Conclusion:**
{'✅ The triangles ARE SIMILAR by SSS criterion!' if is_similar else '❌ The triangles are NOT SIMILAR'}
{f'• Scale factor (ratio) = {ratio_a:.3f}' if is_similar else '• Ratios are not equal'}
{f'• Corresponding angles are equal' if is_similar else '• Corresponding angles may differ'}
"""
    
    return result

def generate_help_message(original_query: str) -> str:
    """Generate helpful message with examples."""
    return f"""
❓ **I couldn't understand your query: "{original_query}"**

Here are some examples of what you can ask:

🔹 **Right Triangles:**
• "Find hypotenuse of right triangle with base 3 cm and height 4 cm"
• "Right triangle with hypotenuse 10 cm and angle 30 degrees"

🔹 **Similar Triangles:**
• "Check if triangles with sides (3,4,5) and (6,8,10) are similar"
• "Are triangles with sides 5,6,7 and 10,12,14 similar?"

🔹 **Triangle Area:**
• "Find area of triangle with sides 5 cm, 6 cm, and 7 cm"
• "Calculate area with base 8 cm and height 6 cm"

🔹 **Triangle Angles:**
• "Find angles of triangle with sides 3, 4, 5"
• "Calculate all angles for sides 7, 8, 9"

🔹 **BPT (Basic Proportionality Theorem):**
• "BPT with segments 4, 6, 8, 12"
• "Check if line is parallel using segments 3, 6, 4, 8"

💡 **Tips:**
• Use specific numbers (e.g., "3 cm", "5.5", "10")
• Include units when possible
• Be specific about what you want to find
"""
--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/plot_triangles.py ###
# File: chapters/chapter6_triangles/plot_triangles.py

import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np
import math
from typing import List, Tuple
import os

def plot_triangle(sides: List[float], angles: List[float], filename: str = "triangle_plot.png") -> str:
    """
    Plot a triangle given its sides and angles.
    Returns the path to the saved plot.
    """
    try:
        # Create figure and axis
        fig, ax = plt.subplots(1, 1, figsize=(10, 8))
        ax.set_aspect('equal')
        
        # Calculate triangle coordinates
        points = calculate_triangle_coordinates(sides, angles)
        
        # Extract coordinates
        x_coords = [p[0] for p in points] + [points[0][0]]  # Close the triangle
        y_coords = [p[1] for p in points] + [points[0][1]]
        
        # Plot triangle
        ax.plot(x_coords, y_coords, 'b-', linewidth=3, label='Triangle')
        ax.fill(x_coords, y_coords, alpha=0.3, color='lightblue')
        
        # Add vertices
        ax.scatter([p[0] for p in points], [p[1] for p in points], 
                  c='red', s=100, zorder=5)
        
        # Label vertices
        labels = ['A', 'B', 'C']
        for i, (point, label) in enumerate(zip(points, labels)):
            ax.annotate(label, (point[0], point[1]), 
                       xytext=(5, 5), textcoords='offset points',
                       fontsize=14, fontweight='bold')
        
        # Label sides
        for i in range(3):
            p1, p2 = points[i], points[(i + 1) % 3]
            mid_x, mid_y = (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2
            side_length = sides[i]
            ax.annotate(f'{side_length:.1f} cm', (mid_x, mid_y),
                       xytext=(0, -15), textcoords='offset points',
                       ha='center', fontsize=12, 
                       bbox=dict(boxstyle='round,pad=0.2', facecolor='yellow', alpha=0.7))
        
        # Label angles
        for i in range(3):
            angle_pos = points[i]
            angle_value = angles[i]
            ax.annotate(f'{angle_value:.1f}°', angle_pos,
                       xytext=(10, 10), textcoords='offset points',
                       fontsize=11, color='red', fontweight='bold',
                       bbox=dict(boxstyle='round,pad=0.2', facecolor='white', alpha=0.8))
        
        # Set title and labels
        triangle_type = determine_triangle_type(sides, angles)
        ax.set_title(f'{triangle_type} Triangle\nSides: {sides[0]:.1f}, {sides[1]:.1f}, {sides[2]:.1f} cm', 
                    fontsize=16, fontweight='bold', pad=20)
        
        # Calculate area and perimeter
        area = calculate_area_heron(sides)
        perimeter = sum(sides)
        
        # Add info box
        info_text = f'Area: {area:.2f} cm²\nPerimeter: {perimeter:.1f} cm'
        ax.text(0.02, 0.98, info_text, transform=ax.transAxes, 
               verticalalignment='top', fontsize=12,
               bbox=dict(boxstyle='round,pad=0.5', facecolor='lightgreen', alpha=0.8))
        
        # Set axis limits with padding
        all_x = [p[0] for p in points]
        all_y = [p[1] for p in points]
        margin = max(max(sides) * 0.2, 1)
        
        ax.set_xlim(min(all_x) - margin, max(all_x) + margin)
        ax.set_ylim(min(all_y) - margin, max(all_y) + margin)
        
        # Remove axis ticks and labels for cleaner look
        ax.set_xticks([])
        ax.set_yticks([])
        
        # Add grid
        ax.grid(True, alpha=0.3)
        
        # Save plot
        plot_path = f"static/plots/{filename}"
        os.makedirs("static/plots", exist_ok=True)
        plt.savefig(plot_path, dpi=300, bbox_inches='tight', facecolor='white')
        plt.close()
        
        return plot_path
        
    except Exception as e:
        print(f"Error plotting triangle: {e}")
        return "Error creating plot"

def plot_similar_triangles(triangle1_data: Tuple[List[float], List[float]], 
                          triangle2_data: Tuple[List[float], List[float]], 
                          filename: str = "similar_triangles.png") -> str:
    """
    Plot two triangles side by side to show similarity.
    """
    try:
        sides1, angles1 = triangle1_data
        sides2, angles2 = triangle2_data
        
        # Create figure with subplots
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 8))
        
        # Plot first triangle
        points1 = calculate_triangle_coordinates(sides1, angles1)
        plot_single_triangle(ax1, points1, sides1, angles1, "Triangle 1", 'lightblue')
        
        # Plot second triangle
        points2 = calculate_triangle_coordinates(sides2, angles2)
        plot_single_triangle(ax2, points2, sides2, angles2, "Triangle 2", 'lightcoral')
        
        # Calculate similarity ratio
        ratio = sides2[0] / sides1[0]
        
        # Add similarity information
        fig.suptitle(f'Similar Triangles Comparison\nScale Factor: {ratio:.2f}', 
                    fontsize=18, fontweight='bold')
        
        # Add similarity details
        info_text = f'Triangle 1 Area: {calculate_area_heron(sides1):.2f} cm²\n'
        info_text += f'Triangle 2 Area: {calculate_area_heron(sides2):.2f} cm²\n'
        info_text += f'Area Ratio: {(calculate_area_heron(sides2)/calculate_area_heron(sides1)):.2f}\n'
        info_text += f'Expected Area Ratio: {ratio**2:.2f}'
        
        fig.text(0.5, 0.02, info_text, ha='center', fontsize=12,
                bbox=dict(boxstyle='round,pad=0.5', facecolor='lightyellow', alpha=0.9))
        
        # Save plot
        plot_path = f"static/plots/{filename}"
        os.makedirs("static/plots", exist_ok=True)
        plt.savefig(plot_path, dpi=300, bbox_inches='tight', facecolor='white')
        plt.close()
        
        return plot_path
        
    except Exception as e:
        print(f"Error plotting similar triangles: {e}")
        return "Error creating plot"

def plot_single_triangle(ax, points: List[Tuple[float, float]], sides: List[float], 
                        angles: List[float], title: str, color: str):
    """Helper function to plot a single triangle on given axis."""
    
    # Extract coordinates
    x_coords = [p[0] for p in points] + [points[0][0]]
    y_coords = [p[1] for p in points] + [points[0][1]]
    
    # Plot triangle
    ax.plot(x_coords, y_coords, 'b-', linewidth=3)
    ax.fill(x_coords, y_coords, alpha=0.4, color=color)
    
    # Add vertices
    ax.scatter([p[0] for p in points], [p[1] for p in points], 
              c='red', s=100, zorder=5)
    
    # Label vertices
    labels = ['A', 'B', 'C']
    for i, (point, label) in enumerate(zip(points, labels)):
        ax.annotate(label, (point[0], point[1]), 
                   xytext=(5, 5), textcoords='offset points',
                   fontsize=14, fontweight='bold')
    
    # Label sides
    for i in range(3):
        p1, p2 = points[i], points[(i + 1) % 3]
        mid_x, mid_y = (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2
        side_length = sides[i]
        ax.annotate(f'{side_length:.1f}', (mid_x, mid_y),
                   xytext=(0, -15), textcoords='offset points',
                   ha='center', fontsize=11, 
                   bbox=dict(boxstyle='round,pad=0.2', facecolor='yellow', alpha=0.7))
    
    # Set title
    ax.set_title(title, fontsize=14, fontweight='bold')
    
    # Set equal aspect and clean up
    ax.set_aspect('equal')
    ax.grid(True, alpha=0.3)
    ax.set_xticks([])
    ax.set_yticks([])
    
    # Set limits with padding
    all_x = [p[0] for p in points]
    all_y = [p[1] for p in points]
    margin = max(max(sides) * 0.2, 1)
    
    ax.set_xlim(min(all_x) - margin, max(all_x) + margin)
    ax.set_ylim(min(all_y) - margin, max(all_y) + margin)

def calculate_triangle_coordinates(sides: List[float], angles: List[float]) -> List[Tuple[float, float]]:
    """
    Calculate triangle coordinates for plotting.
    Places first vertex at origin, second on x-axis.
    """
    a, b, c = sides
    
    # Place first point at origin
    A = (0.0, 0.0)
    
    # Place second point on x-axis
    B = (c, 0.0)  # Side c is between A and B
    
    # Calculate third point using law of cosines
    # We need angle A (at vertex A)
    angle_A_rad = math.radians(angles[0])
    
    # Point C coordinates
    C_x = b * math.cos(angle_A_rad)
    C_y = b * math.sin(angle_A_rad)
    C = (C_x, C_y)
    
    return [A, B, C]

def determine_triangle_type(sides: List[float], angles: List[float]) -> str:
    """Determine the type of triangle."""
    max_angle = max(angles)
    
    if abs(max_angle - 90) < 0.1:
        return "Right"
    elif max_angle > 90:
        return "Obtuse"
    else:
        return "Acute"

def calculate_area_heron(sides: List[float]) -> float:
    """Calculate triangle area using Heron's formula."""
    a, b, c = sides
    s = (a + b + c) / 2  # semi-perimeter
    area = math.sqrt(s * (s - a) * (s - b) * (s - c))
    return area

def plot_right_triangle_special(base: float, height: float, filename: str = "right_triangle.png") -> str:
    """
    Special plotting function for right triangles with base and height.
    """
    try:
        fig, ax = plt.subplots(1, 1, figsize=(10, 8))
        ax.set_aspect('equal')
        
        # Right triangle coordinates
        A = (0, 0)      # Origin
        B = (base, 0)   # Base point
        C = (0, height) # Height point
        
        points = [A, B, C]
        x_coords = [0, base, 0, 0]
        y_coords = [0, 0, height, 0]
        
        # Plot triangle
        ax.plot(x_coords, y_coords, 'b-', linewidth=3)
        ax.fill(x_coords, y_coords, alpha=0.3, color='lightblue')
        
        # Add vertices
        ax.scatter([0, base, 0], [0, 0, height], c='red', s=100, zorder=5)
        
        # Label vertices
        ax.annotate('A', (0, 0), xytext=(-10, -10), textcoords='offset points',
                   fontsize=14, fontweight='bold')
        ax.annotate('B', (base, 0), xytext=(5, -10), textcoords='offset points',
                   fontsize=14, fontweight='bold')
        ax.annotate('C', (0, height), xytext=(-10, 5), textcoords='offset points',
                   fontsize=14, fontweight='bold')
        
        # Label sides
        ax.annotate(f'Base = {base} cm', (base/2, -0.1*height), ha='center', 
                   fontsize=12, bbox=dict(boxstyle='round,pad=0.2', facecolor='yellow', alpha=0.7))
        ax.annotate(f'Height = {height} cm', (-0.1*base, height/2), ha='center', rotation=90,
                   fontsize=12, bbox=dict(boxstyle='round,pad=0.2', facecolor='yellow', alpha=0.7))
        
        # Calculate and label hypotenuse
        hypotenuse = math.sqrt(base**2 + height**2)
        ax.annotate(f'Hypotenuse = {hypotenuse:.2f} cm', (base/2, height/2), 
                   xytext=(10, 10), textcoords='offset points',
                   fontsize=12, bbox=dict(boxstyle='round,pad=0.2', facecolor='orange', alpha=0.7))
        
        # Add right angle indicator
        right_angle_size = min(base, height) * 0.1
        square = patches.Rectangle((0, 0), right_angle_size, right_angle_size, 
                                 linewidth=2, edgecolor='red', facecolor='none')
        ax.add_patch(square)
        
        # Calculate angles
        angle_B = math.degrees(math.atan(height / base))
        angle_C = 90 - angle_B
        
        # Label angles
        ax.annotate('90°', (right_angle_size/2, right_angle_size/2), ha='center', va='center',
                   fontsize=11, color='red', fontweight='bold')
        ax.annotate(f'{angle_B:.1f}°', (base*0.8, height*0.1), 
                   fontsize=11, color='red', fontweight='bold')
        ax.annotate(f'{angle_C:.1f}°', (base*0.1, height*0.8), 
                   fontsize=11, color='red', fontweight='bold')
        
        # Title and info
        ax.set_title(f'Right Triangle\nBase: {base} cm, Height: {height} cm, Hypotenuse: {hypotenuse:.2f} cm', 
                    fontsize=16, fontweight='bold', pad=20)
        
        # Area and perimeter
        area = 0.5 * base * height
        perimeter = base + height + hypotenuse
        info_text = f'Area: {area:.2f} cm²\nPerimeter: {perimeter:.2f} cm'
        ax.text(0.98, 0.98, info_text, transform=ax.transAxes, 
               verticalalignment='top', horizontalalignment='right', fontsize=12,
               bbox=dict(boxstyle='round,pad=0.5', facecolor='lightgreen', alpha=0.8))
        
        # Set limits
        margin = max(base, height) * 0.2
        ax.set_xlim(-margin, base + margin)
        ax.set_ylim(-margin, height + margin)
        
        # Clean up axes
        ax.set_xticks([])
        ax.set_yticks([])
        ax.grid(True, alpha=0.3)
        
        # Save plot
        plot_path = f"static/plots/{filename}"
        os.makedirs("static/plots", exist_ok=True)
        plt.savefig(plot_path, dpi=300, bbox_inches='tight', facecolor='white')
        plt.close()
        
        return plot_path
        
    except Exception as e:
        print(f"Error plotting right triangle: {e}")
        return "Error creating plot"
--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/interpret_query_triangles.py ###
import os
import re
from dotenv import load_dotenv
from groq import Groq

load_dotenv()
client = Groq(api_key=os.getenv("GROQ_API_KEY"))

def interpret_query_triangles(query: str) -> dict:
    """
    Uses LLM to interpret natural language queries related to triangles.
    Returns intent + parsed parameters.
    """
    prompt = f"""
You are a math query classifier for CBSE Class X Triangles topics.
Classify the user query into one of the following intents:
- solve_right_triangle (for right triangle problems)
- check_similarity (for checking if triangles are similar)
- calculate_area (for finding area of triangles)
- apply_pythagoras (for Pythagoras theorem problems)
- apply_bpt (for Basic Proportionality Theorem)
- formula_request (when asking for formulas/theorems)

Extract all numerical parameters and their context.

Return a JSON like:
{{
  "intent": "solve_right_triangle",
  "parameters": {{
    "base": 3,
    "height": 4,
    "find": "hypotenuse"
  }}
}}

Query: "{query}"
"""

    try:
        response = client.chat.completions.create(
            model="llama3-8b-8192",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.2
        )
        content = response.choices[0].message.content.strip()
        if content.startswith("{"):
            import json
            return json.loads(content)
        else:
            return {"intent": "unknown", "raw_response": content}
    except Exception as e:
        return {"intent": "error", "error": str(e)}

def extract_triangle_measurements(query: str) -> dict:
    """
    Extract triangle measurements from query using regex.
    """
    measurements = {}
    
    # Common patterns for sides
    # Pattern 1: "sides 3, 4, 5" or "sides are 3, 4, 5"
    sides_pattern = r'sides?\s*(?:are\s*)?(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)'
    sides_match = re.search(sides_pattern, query, re.IGNORECASE)
    if sides_match:
        measurements['sides'] = [float(sides_match.group(i)) for i in range(1, 4)]
    
    # Pattern 2: Triangle notation like (3,4,5)
    triangle_pattern = r'\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)'
    triangles = re.findall(triangle_pattern, query)
    if triangles:
        measurements['triangles'] = [[float(x) for x in t] for t in triangles]
    
    # Pattern for base and height
    base_pattern = r'base[:\s=]+(\d+(?:\.\d+)?)'
    height_pattern = r'height[:\s=]+(\d+(?:\.\d+)?)'
    
    base_match = re.search(base_pattern, query, re.IGNORECASE)
    height_match = re.search(height_pattern, query, re.IGNORECASE)
    
    if base_match:
        measurements['base'] = float(base_match.group(1))
    if height_match:
        measurements['height'] = float(height_match.group(1))
    
    # Pattern for angles
    angle_pattern = r'(\d+(?:\.\d+)?)\s*(?:degree|deg|°)'
    angles = re.findall(angle_pattern, query, re.IGNORECASE)
    if angles:
        measurements['angles'] = [float(a) for a in angles]
    
    # Check for specific terms
    if 'hypotenuse' in query.lower():
        measurements['find'] = 'hypotenuse'
    elif 'area' in query.lower():
        measurements['find'] = 'area'
    elif 'similar' in query.lower():
        measurements['find'] = 'similarity'
    
    return measurements

def parse_triangle_notation(notation: str) -> list:
    """
    Parse triangle notation like ABC or PQR.
    """
    # Remove special characters and spaces
    notation = re.sub(r'[^\w]', '', notation)
    
    # Check if it's a valid triangle notation (3 letters)
    if len(notation) == 3 and notation.isalpha():
        return list(notation.upper())
    elif 'triangle' in notation.lower():
        # Extract letters after 'triangle'
        match = re.search(r'triangle\s*([A-Z]{3})', notation, re.IGNORECASE)
        if match:
            return list(match.group(1).upper())
    
    return None

# Example for testing
if __name__ == "__main__":
    test_queries = [
        "Find hypotenuse of right triangle with base 3 cm and height 4 cm",
        "Check if triangles with sides (3,4,5) and (6,8,10) are similar",
        "Find area of triangle with sides 5, 6, and 7",
        "What is Pythagoras theorem?"
    ]
    
    for q in test_queries:
        print(f"\nQuery: {q}")
        print(f"LLM Result: {interpret_query_triangles(q)}")
        print(f"Regex Extract: {extract_triangle_measurements(q)}")
        print("-" * 50)
--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/utils/triangle_base.py ###
import json
import os
import numpy as np
from typing import List, Tuple, Dict, Optional, Union
from dataclasses import dataclass

@dataclass
class TriangleData:
    sides: List[float]
    angles: Optional[List[float]] = None
    points: Optional[List[Tuple[float, float]]] = None
    
    def is_valid(self) -> bool:
        """Check if the triangle is valid using triangle inequality theorem."""
        if len(self.sides) != 3:
            return False
        a, b, c = sorted(self.sides)
        return a + b > c
    
    def get_type(self) -> str:
        """Determine the type of triangle based on its sides."""
        if not self.is_valid():
            return 'invalid'
        
        a, b, c = sorted(self.sides)
        
        if abs(a - b) < 1e-10 and abs(b - c) < 1e-10:
            return 'equilateral'
        elif abs(a - b) < 1e-10 or abs(b - c) < 1e-10:
            return 'isosceles'
        else:
            return 'scalene'
    
    def is_right_triangle(self) -> bool:
        """Check if the triangle is a right triangle using Pythagorean theorem."""
        if not self.is_valid():
            return False
        
        a, b, c = sorted(self.sides)
        return abs(a**2 + b**2 - c**2) < 1e-10

class TriangleBase:
    def __init__(self):
        self.config = self._load_config()
    
    def _load_config(self) -> Dict:
        """Load configuration from JSON file."""
        config_path = os.path.join(os.path.dirname(__file__), '..', 'config', 'triangle_config.json')
        with open(config_path, 'r') as f:
            return json.load(f)
    
    def validate_sides(self, sides: List[float]) -> bool:
        """Validate triangle sides."""
        if len(sides) != 3:
            return False
        
        min_length = self.config['validation']['min_side_length']
        max_length = self.config['validation']['max_side_length']
        
        return all(min_length <= side <= max_length for side in sides)
    
    def calculate_angles(self, sides: List[float]) -> List[float]:
        """Calculate angles using cosine law."""
        if not self.validate_sides(sides):
            return []
        
        a, b, c = sides
        angles = []
        
        # Calculate angles using cosine law
        cos_A = (b**2 + c**2 - a**2) / (2 * b * c)
        cos_B = (a**2 + c**2 - b**2) / (2 * a * c)
        cos_C = (a**2 + b**2 - c**2) / (2 * a * b)
        
        # Convert to degrees and round
        angles = [
            round(np.degrees(np.arccos(np.clip(cos_A, -1.0, 1.0))), 1),
            round(np.degrees(np.arccos(np.clip(cos_B, -1.0, 1.0))), 1),
            round(np.degrees(np.arccos(np.clip(cos_C, -1.0, 1.0))), 1)
        ]
        
        return angles
    
    def calculate_area(self, sides: List[float], method: str = 'heron') -> float:
        """Calculate triangle area using specified method."""
        if not self.validate_sides(sides):
            return 0.0
        
        if method == 'heron':
            # Heron's formula
            s = sum(sides) / 2
            return np.sqrt(s * (s - sides[0]) * (s - sides[1]) * (s - sides[2]))
        elif method == 'base_height':
            # Base-height formula (requires height)
            if len(sides) != 2:
                return 0.0
            return 0.5 * sides[0] * sides[1]
        else:
            return 0.0
    
    def are_similar(self, triangle1: TriangleData, triangle2: TriangleData) -> Tuple[bool, Optional[float]]:
        """Check if two triangles are similar and return scale factor if they are."""
        if not (triangle1.is_valid() and triangle2.is_valid()):
            return False, None
        
        # Sort sides for consistent comparison
        sides1 = sorted(triangle1.sides)
        sides2 = sorted(triangle2.sides)
        
        # Calculate ratios of corresponding sides
        ratios = [sides2[i] / sides1[i] for i in range(3)]
        
        # Check if all ratios are equal (within tolerance)
        if all(abs(ratio - ratios[0]) < 1e-10 for ratio in ratios):
            return True, ratios[0]
        
        return False, None
    
    def get_formula_explanation(self, formula_type: str) -> str:
        """Get explanation for a specific formula."""
        formulas = self.config['formulas']
        if formula_type in formulas:
            return self._format_formula_explanation(formulas[formula_type])
        return "Formula not found."
    
    def _format_formula_explanation(self, formula_data: Dict) -> str:
        """Format formula explanation in a readable way."""
        explanation = f"📐 **{formula_data['name']}:**\n\n"
        
        if 'formula' in formula_data:
            explanation += f"**Formula:** {formula_data['formula']}\n\n"
        
        if 'description' in formula_data:
            explanation += f"**Description:** {formula_data['description']}\n\n"
        
        if 'variables' in formula_data:
            explanation += "**Variables:**\n"
            for var, desc in formula_data['variables'].items():
                explanation += f"• {var}: {desc}\n"
            explanation += "\n"
        
        if 'example' in formula_data:
            explanation += f"**Example:** {formula_data['example']}\n"
        
        return explanation 
--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/utils/triangle_plotter.py ###
import numpy as np
import matplotlib.pyplot as plt
from typing import List, Tuple, Dict, Any
from .triangle_base import TriangleBase

class TrianglePlotter:
    def __init__(self):
        self.base = TriangleBase()
        self.config = self.base.config["plotting"]
    
    def plot_triangle(self, sides: List[float], title: str = "Triangle", 
                     color: str = "blue", alpha: float = 0.3) -> plt.Figure:
        """Plot a single triangle given its sides."""
        # Calculate coordinates using law of cosines
        a, b, c = sides
        cos_A = (b**2 + c**2 - a**2) / (2 * b * c)
        sin_A = np.sqrt(1 - cos_A**2)
        
        # Set up coordinates
        x = [0, c, b * cos_A, 0]
        y = [0, 0, b * sin_A, 0]
        
        # Create figure
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.plot(x, y, color=color, linewidth=2)
        ax.fill(x, y, color=color, alpha=alpha)
        
        # Add labels
        ax.text(-0.2, -0.2, 'A', fontsize=12)
        ax.text(c + 0.1, -0.2, 'B', fontsize=12)
        ax.text(b * cos_A - 0.2, b * sin_A + 0.1, 'C', fontsize=12)
        
        # Add side lengths
        ax.text(c/2, -0.3, f'a={a:.1f}', fontsize=10)
        ax.text(b * cos_A/2, b * sin_A/2, f'b={b:.1f}', fontsize=10)
        ax.text((c + b * cos_A)/2, b * sin_A/2, f'c={c:.1f}', fontsize=10)
        
        # Set equal aspect ratio and remove axes
        ax.set_aspect('equal')
        ax.axis('off')
        ax.set_title(title)
        
        return fig
    
    def plot_similar_triangles(self, triangle1: List[float], triangle2: List[float], 
                             scale_factor: float = 1.0) -> plt.Figure:
        """Plot two similar triangles with their corresponding sides."""
        # Create figure with two subplots
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))
        
        # Plot first triangle directly on ax1
        self._plot_triangle_on_axis(ax1, triangle1, "Triangle 1", "blue", 0.3)
        
        # Plot second triangle directly on ax2  
        self._plot_triangle_on_axis(ax2, triangle2, "Triangle 2", "red", 0.3)
        
        # Add scale factor information
        fig.suptitle(f"Similar Triangles (Scale Factor: {scale_factor:.3f})", fontsize=16, fontweight='bold')
        
        # Add similarity information
        area1 = self._calculate_area_heron(triangle1)
        area2 = self._calculate_area_heron(triangle2)
        area_ratio = area2 / area1
        
        info_text = f'Triangle 1 Area: {area1:.2f} units²\n'
        info_text += f'Triangle 2 Area: {area2:.2f} units²\n'
        info_text += f'Area Ratio: {area_ratio:.3f}\n'
        info_text += f'Expected Area Ratio: {scale_factor**2:.3f}'
        
        fig.text(0.5, 0.02, info_text, ha='center', fontsize=11,
                bbox=dict(boxstyle='round,pad=0.5', facecolor='lightyellow', alpha=0.9))
        
        plt.tight_layout()
        return fig
    
    def _plot_triangle_on_axis(self, ax, sides: List[float], title: str, color: str, alpha: float):
        """Helper method to plot a triangle directly on a given axis."""
        # Calculate coordinates using law of cosines
        a, b, c = sides
        
        # Ensure valid triangle
        if not (a + b > c and b + c > a and a + c > b):
            ax.text(0.5, 0.5, f'Invalid Triangle\n{sides}', 
                   ha='center', va='center', transform=ax.transAxes,
                   fontsize=12, color='red')
            ax.set_title(title)
            ax.axis('off')
            return
        
        cos_A = (b**2 + c**2 - a**2) / (2 * b * c)
        cos_A = max(-1, min(1, cos_A))  # Clamp to valid range
        sin_A = np.sqrt(1 - cos_A**2)
        
        # Set up coordinates
        x = [0, c, b * cos_A, 0]
        y = [0, 0, b * sin_A, 0]
        
        # Plot triangle
        ax.plot(x, y, color=color, linewidth=2)
        ax.fill(x, y, color=color, alpha=alpha)
        
        # Add vertex labels
        ax.text(-0.15, -0.15, 'A', fontsize=12, fontweight='bold')
        ax.text(c + 0.05, -0.15, 'B', fontsize=12, fontweight='bold')
        ax.text(b * cos_A - 0.15, b * sin_A + 0.05, 'C', fontsize=12, fontweight='bold')
        
        # Add side lengths with better positioning
        ax.text(c/2, -0.25, f'{a:.1f}', fontsize=10, ha='center', 
               bbox=dict(boxstyle='round,pad=0.2', facecolor='white', alpha=0.8))
        ax.text(b * cos_A/2 - 0.2, b * sin_A/2, f'{b:.1f}', fontsize=10, ha='center',
               bbox=dict(boxstyle='round,pad=0.2', facecolor='white', alpha=0.8))
        ax.text((c + b * cos_A)/2 + 0.1, b * sin_A/2, f'{c:.1f}', fontsize=10, ha='center',
               bbox=dict(boxstyle='round,pad=0.2', facecolor='white', alpha=0.8))
        
        # Set equal aspect ratio and clean up axes
        ax.set_aspect('equal')
        ax.axis('off')
        ax.set_title(title, fontsize=14, fontweight='bold')
        
        # Set reasonable axis limits with padding
        max_coord = max(max(x), max(y))
        padding = max_coord * 0.2
        ax.set_xlim(-padding, max_coord + padding)
        ax.set_ylim(-padding, max_coord + padding)
    
    def plot_right_triangle(self, base: float, height: float) -> plt.Figure:
        """Plot a right triangle given base and height."""
        # Calculate hypotenuse
        hypotenuse = np.sqrt(base**2 + height**2)
        
        # Set up coordinates
        x = [0, base, 0, 0]
        y = [0, 0, height, 0]
        
        # Create figure
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.plot(x, y, color='blue', linewidth=2)
        ax.fill(x, y, color='blue', alpha=0.3)
        
        # Add labels
        ax.text(-0.2, -0.2, 'A', fontsize=12, fontweight='bold')
        ax.text(base + 0.1, -0.2, 'B', fontsize=12, fontweight='bold')
        ax.text(-0.2, height + 0.1, 'C', fontsize=12, fontweight='bold')
        
        # Add side lengths
        ax.text(base/2, -0.3, f'Base = {base:.1f} cm', fontsize=11, ha='center',
               bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.7))
        ax.text(-0.4, height/2, f'Height = {height:.1f} cm', fontsize=11, ha='center', rotation=90,
               bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.7))
        ax.text(base/2, height/2, f'Hypotenuse = {hypotenuse:.1f} cm', fontsize=11, ha='center',
               bbox=dict(boxstyle='round,pad=0.3', facecolor='orange', alpha=0.7))
        
        # Add right angle marker
        right_angle_size = min(base, height) * 0.1
        ax.plot([0, right_angle_size], [0, 0], 'k-', linewidth=1)
        ax.plot([0, 0], [0, right_angle_size], 'k-', linewidth=1)
        ax.plot([right_angle_size, right_angle_size], [0, right_angle_size], 'k-', linewidth=1)
        ax.plot([0, right_angle_size], [right_angle_size, right_angle_size], 'k-', linewidth=1)
        
        # Add 90° label
        ax.text(right_angle_size/2, right_angle_size/2, '90°', fontsize=10, ha='center', va='center',
               color='red', fontweight='bold')
        
        # Calculate and display angles
        angle_B = np.degrees(np.arctan(height / base))
        angle_C = 90 - angle_B
        
        ax.text(base * 0.8, height * 0.1, f'{angle_B:.1f}°', fontsize=10, color='red', fontweight='bold')
        ax.text(base * 0.1, height * 0.8, f'{angle_C:.1f}°', fontsize=10, color='red', fontweight='bold')
        
        # Set equal aspect ratio and remove axes
        ax.set_aspect('equal')
        ax.axis('off')
        ax.set_title("Right Triangle", fontsize=16, fontweight='bold', pad=20)
        
        # Set axis limits with padding
        margin = max(base, height) * 0.2
        ax.set_xlim(-margin, base + margin)
        ax.set_ylim(-margin, height + margin)
        
        # Add grid for better visualization
        ax.grid(True, alpha=0.3)
        
        return fig
    
    def plot_bpt_theorem(self, segments: List[float]) -> plt.Figure:
        """Plot Basic Proportionality Theorem scenario."""
        if len(segments) < 4:
            raise ValueError("Need at least 4 segments for BPT plot")
            
        AD, DB, AE, EC = segments[:4]
        
        # Create figure
        fig, ax = plt.subplots(figsize=(10, 7))
        
        # Calculate proportional coordinates
        total_base = AD + DB
        total_height = AE + EC
        
        # Scale for better visualization
        scale = 8
        base_scale = scale
        height_scale = scale * (total_height / total_base)
        
        # Main triangle vertices
        A = [0, 0]
        B = [base_scale, 0]
        C = [base_scale * 0.4, height_scale]
        
        # Points D and E based on ratios
        D_ratio = AD / total_base
        E_ratio = AE / total_height
        
        D = [base_scale * D_ratio, 0]
        E = [C[0] * E_ratio, C[1] * E_ratio]
        
        # Plot main triangle ABC
        triangle_x = [A[0], B[0], C[0], A[0]]
        triangle_y = [A[1], B[1], C[1], A[1]]
        ax.plot(triangle_x, triangle_y, 'b-', linewidth=3, label='Triangle ABC')
        
        # Plot parallel line DE
        ax.plot([D[0], E[0]], [D[1], E[1]], 'r-', linewidth=3, label='Line DE')
        
        # Plot segments AD, DB, AE, EC with different colors for clarity
        ax.plot([A[0], D[0]], [A[1], D[1]], 'g-', linewidth=4, alpha=0.7, label=f'AD = {AD:.1f}')
        ax.plot([D[0], B[0]], [D[1], B[1]], 'm-', linewidth=4, alpha=0.7, label=f'DB = {DB:.1f}')
        ax.plot([A[0], E[0]], [A[1], E[1]], 'orange', linewidth=4, alpha=0.7, label=f'AE = {AE:.1f}')
        ax.plot([E[0], C[0]], [E[1], C[1]], 'purple', linewidth=4, alpha=0.7, label=f'EC = {EC:.1f}')
        
        # Add point labels
        offset = 0.2
        ax.text(A[0] - offset, A[1] - offset, 'A', fontsize=14, fontweight='bold')
        ax.text(B[0] + offset, B[1] - offset, 'B', fontsize=14, fontweight='bold')
        ax.text(C[0] - offset, C[1] + offset, 'C', fontsize=14, fontweight='bold')
        ax.text(D[0], D[1] - offset, 'D', fontsize=14, fontweight='bold', color='red')
        ax.text(E[0] - offset, E[1], 'E', fontsize=14, fontweight='bold', color='red')
        
        # Add ratios
        ratio1 = AD / DB
        ratio2 = AE / EC
        is_parallel = abs(ratio1 - ratio2) < 0.001
        
        # Add BPT verification text
        verification_text = f'AD/DB = {AD:.1f}/{DB:.1f} = {ratio1:.3f}\n'
        verification_text += f'AE/EC = {AE:.1f}/{EC:.1f} = {ratio2:.3f}\n'
        verification_text += f'Ratios equal? {"YES" if is_parallel else "NO"}\n'
        verification_text += f'Therefore: DE {"||" if is_parallel else "∦"} BC'
        
        ax.text(0.02, 0.98, verification_text, transform=ax.transAxes, fontsize=12,
               verticalalignment='top', 
               bbox=dict(boxstyle='round,pad=0.5', facecolor='lightyellow', alpha=0.9))
        
        # Set equal aspect ratio and clean up
        ax.set_aspect('equal')
        ax.legend(loc='upper right')
        ax.grid(True, alpha=0.3)
        ax.set_title("Basic Proportionality Theorem (Thales' Theorem)", fontsize=16, fontweight='bold')
        
        # Remove axis ticks for cleaner look
        ax.set_xticks([])
        ax.set_yticks([])
        
        return fig
    
    def _calculate_area_heron(self, sides: List[float]) -> float:
        """Calculate triangle area using Heron's formula."""
        a, b, c = sides
        s = (a + b + c) / 2  # semi-perimeter
        try:
            area = np.sqrt(s * (s - a) * (s - b) * (s - c))
            return area
        except:
            return 0.0
--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/utils/__pycache__/triangle_base.cpython-310.pyc ###

### File: chapters/chapter6_triangles/utils/__pycache__/triangle_base.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xc5 in position 9: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/utils/__pycache__/triangle_plotter.cpython-310.pyc ###

### File: chapters/chapter6_triangles/utils/__pycache__/triangle_plotter.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xe6 in position 9: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/__init__.py ###
"""
chapters.chapter6_triangles.sub_chapters package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/triangle_similarity/__init__.py ###
"""
chapters.chapter6_triangles.sub_chapters.triangle_similarity package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/basic_proportionality/solver_bpt.py ###
import math
from typing import Dict, Any

def solve_bpt(params: Dict[str, Any]) -> str:
    """
    Apply Basic Proportionality Theorem (Thales Theorem).
    """
    try:
        problem_type = params.get("type", "find_segment")
        segments = params.get("segments", [])
        
        if len(segments) < 4:
            return "❌ Need all 4 segments (AD, DB, AE, EC) to verify if DE || BC"
        
        AD, DB, AE, EC = segments[:4]
        
        # Calculate ratios
        ratio1 = AD / DB
        ratio2 = AE / EC
        difference = abs(ratio1 - ratio2)
        is_parallel = difference < 0.001
        
        result = f"""
✅ **Converse of BPT - Verify Parallel Lines:**

Given segments in triangle ABC:
• AD = {AD} cm
• DB = {DB} cm
• AE = {AE} cm
• EC = {EC} cm

📝 **Checking if DE || BC:**

**Converse of BPT:** If AD/DB = AE/EC, then DE || BC

**1. Calculate ratios:**
   • AD/DB = {AD}/{DB} = {ratio1:.4f}
   • AE/EC = {AE}/{EC} = {ratio2:.4f}

**2. Compare ratios:**
   • Difference = |{ratio1:.4f} - {ratio2:.4f}| = {difference:.6f}
   • Are ratios equal? {'YES ✓' if is_parallel else 'NO ✗'}

💡 **Conclusion:**
{'✅ DE IS PARALLEL to BC' if is_parallel else '❌ DE is NOT PARALLEL to BC'}
{f'The ratios are equal, so by converse of BPT, DE || BC' if is_parallel else f'The ratios are not equal, so DE is not parallel to BC'}

**Additional Info:**
• AB = AD + DB = {AD + DB} cm
• AC = AE + EC = {AE + EC} cm
• Ratio AD/AB = {AD/(AD+DB):.3f}
• Ratio AE/AC = {AE/(AE+EC):.3f}
"""
        
        return result

    except Exception as e:
        return f"❌ Error applying BPT: {str(e)}"

def find_ratio_bpt(params: Dict[str, Any]) -> str:
    """
    Find ratios using BPT.
    """
    known_ratio = params.get("known_ratio", 0)
    find_type = params.get("find_type", "segments")
    
    if known_ratio <= 0:
        return "❌ Need a valid ratio to work with"
    
    result = f"""
✅ **BPT - Working with Ratios:**

Given: DE || BC and one ratio = {known_ratio}

📝 **Using BPT Properties:**

**If AD/DB = {known_ratio}, then:**
1. AE/EC = {known_ratio} (by BPT)
2. AD/AB = AD/(AD+DB) = {known_ratio}/{known_ratio + 1} = {known_ratio/(known_ratio + 1):.3f}
3. AE/AC = AE/(AE+EC) = {known_ratio}/{known_ratio + 1} = {known_ratio/(known_ratio + 1):.3f}
4. DE/BC = AD/AB = {known_ratio/(known_ratio + 1):.3f}

**Example with concrete numbers:**
If AD = {known_ratio * 5} cm, then:
• DB = {5} cm
• AE = {known_ratio * 6} cm (if AC = {(known_ratio + 1) * 6} cm)
• EC = {6} cm

💡 **Key Relationships:**
• The ratios AD/DB and AE/EC are always equal when DE || BC
• The ratio DE/BC equals AD/AB (or AE/AC)
• These ratios help find unknown segments
"""
    
    return result

def explain_bpt_with_example() -> str:
    """
    Explain BPT with a worked example.
    """
    result = """
✅ **Basic Proportionality Theorem (Thales Theorem) Explained:**

📐 **Statement:**
If a line is drawn parallel to one side of a triangle intersecting the other two sides, then it divides the two sides proportionally.

**In Triangle ABC with DE || BC:**
• D lies on AB
• E lies on AC
• Then: AD/DB = AE/EC

📝 **Worked Example:**

Given: Triangle ABC with DE || BC
• AD = 6 cm
• DB = 4 cm
• AE = 9 cm
• Find EC

**Solution:**
1. Apply BPT: AD/DB = AE/EC
2. Substitute: 6/4 = 9/EC
3. Cross-multiply: 6 × EC = 4 × 9
4. 6 × EC = 36
5. EC = 36/6 = 6 cm

**Verification:**
• AD/DB = 6/4 = 1.5
• AE/EC = 9/6 = 1.5 ✓

💡 **Applications:**
1. Finding unknown segments
2. Proving lines are parallel
3. Dividing line segments in given ratio
4. Similar triangle problems

**Converse of BPT:**
If AD/DB = AE/EC, then DE || BC

**Important Ratios:**
• AD/AB = AE/AC = DE/BC
• DB/AB = EC/AC
• AD/DB = AE/EC
"""
    
    return result

def find_segment_bpt(params: Dict[str, Any]) -> str:
    """
    Find missing segment using BPT.
    """
    segments = params.get("segments", [])
    
    if len(segments) < 3:
        return "❌ Need at least 3 known segments to find the fourth"
    
    # BPT: If DE || BC, then AD/DB = AE/EC
    # Segments order: AD, DB, AE, EC
    if len(segments) == 4 and 0 in segments:
        # Find which segment is missing
        if segments[0] == 0:  # AD missing
            AD = (segments[1] * segments[2]) / segments[3]
            missing = "AD"
            value = AD
            formula = f"AD = (DB × AE) / EC = ({segments[1]} × {segments[2]}) / {segments[3]}"
        elif segments[1] == 0:  # DB missing
            DB = (segments[0] * segments[3]) / segments[2]
            missing = "DB"
            value = DB
            formula = f"DB = (AD × EC) / AE = ({segments[0]} × {segments[3]}) / {segments[2]}"
        elif segments[2] == 0:  # AE missing
            AE = (segments[0] * segments[3]) / segments[1]
            missing = "AE"
            value = AE
            formula = f"AE = (AD × EC) / DB = ({segments[0]} × {segments[3]}) / {segments[1]}"
        else:  # EC missing
            EC = (segments[1] * segments[2]) / segments[0]
            missing = "EC"
            value = EC
            formula = f"EC = (DB × AE) / AD = ({segments[1]} × {segments[2]}) / {segments[0]}"
    else:
        # Use first 3 to find 4th
        AD, DB, AE = segments[:3]
        EC = (DB * AE) / AD
        missing = "EC"
        value = EC
        formula = f"EC = (DB × AE) / AD = ({DB} × {AE}) / {AD}"
    
    result = f"""
✅ **Basic Proportionality Theorem (BPT) Solution:**

Given: In triangle ABC with DE || BC
• AD = {segments[0] if segments[0] != 0 else '?'} cm
• DB = {segments[1] if len(segments) > 1 and segments[1] != 0 else '?'} cm
• AE = {segments[2] if len(segments) > 2 and segments[2] != 0 else '?'} cm
• EC = {segments[3] if len(segments) > 3 and segments[3] != 0 else '?'} cm

📝 **Finding {missing}:**

**BPT States:** If DE || BC, then AD/DB = AE/EC

**Cross-multiplication:**
AD × EC = DB × AE

**Solving for {missing}:**
{formula}
{missing} = {value:.2f} cm

💡 **Verification:**
• Ratio 1: AD/DB = {segments[0] if segments[0] != 0 else value}/{segments[1] if segments[1] != 0 else value} = {(segments[0] if segments[0] != 0 else value)/(segments[1] if segments[1] != 0 else value):.3f}
• Ratio 2: AE/EC = {segments[2] if segments[2] != 0 else value}/{segments[3] if segments[3] != 0 else value} = {(segments[2] if segments[2] != 0 else value)/(segments[3] if segments[3] != 0 else value):.3f}
• Ratios are equal ✓
"""
    
    return result

def verify_parallel_bpt(params: Dict[str, Any]) -> str:
    """
    Verify if a line is parallel using converse of BPT.
    """
    segments = params.get("segments", [])
    
    if problem_type == "find_segment":
        return find_segment_bpt(params)
    elif problem_type == "verify_parallel":
        return verify_parallel_bpt(params)
    elif problem_type == "find_ratio":
        return find_ratio_bpt(params)
    else:
        return explain_bpt_with_example()
--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/basic_proportionality/__pycache__/solver_bpt.cpython-310.pyc ###

### File: chapters/chapter6_triangles/sub_chapters/basic_proportionality/__pycache__/solver_bpt.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xc5 in position 9: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/right_triangle/solver_right_triangle.py ###
import math
import os
from typing import Dict, Any
from chapters.chapter6_triangles.utils.triangle_plotter import TrianglePlotter

def solve_right_triangle(params: Dict[str, Any]) -> str:
    """
    Solve right triangle problems: hypotenuse, angles, area, perimeter + plot.
    """
    try:
        base = params.get("base", 0)
        height = params.get("height", 0)
        hypotenuse = params.get("hypotenuse", 0)
        angle = params.get("angle", 0)
        
        # Initialize plotter
        plotter = TrianglePlotter()
        plot_info = None

        # Case 1: Given base and height
        if base > 0 and height > 0:
            # Calculate hypotenuse using Pythagorean theorem
            hypotenuse = math.sqrt(base**2 + height**2)
            # Calculate angles using inverse tangent
            angle_B = math.degrees(math.atan(height / base))
            angle_A = 90 - angle_B
            # Calculate area and perimeter
            area = 0.5 * base * height
            perimeter = base + height + hypotenuse
            
            # Generate plot
            try:
                fig = plotter.plot_right_triangle(base, height)
                plot_path = "static/plots/right_triangle_auto.png"
                os.makedirs("static/plots", exist_ok=True)
                fig.savefig(plot_path, dpi=300, bbox_inches='tight')
                plot_info = f"![Right Triangle]({plot_path})"
            except Exception as e:
                plot_info = f"⚠️ Plot generation failed: {str(e)}"
            
            result = f"""
✅ **Right Triangle Solution:**

Given:
• Base = {base} cm  
• Height = {height} cm  

📝 **Step-by-Step Calculations:**

1. **Hypotenuse (c):**
   • Using Pythagorean theorem: c = √(a² + b²)
   • c = √({base}² + {height}²)
   • c = √({base**2} + {height**2})
   • c = √{base**2 + height**2}
   • c = **{hypotenuse:.2f} cm**

2. **Angles:**
   • Angle B = tan⁻¹(height/base)
   • Angle B = tan⁻¹({height}/{base})
   • Angle B = tan⁻¹({height/base:.2f})
   • Angle B = **{angle_B:.1f}°**
   
   • Angle A = 90° - Angle B
   • Angle A = 90° - {angle_B:.1f}°
   • Angle A = **{angle_A:.1f}°**

3. **Area:**
   • Area = ½ × base × height
   • Area = ½ × {base} × {height}
   • Area = **{area:.2f} cm²**

4. **Perimeter:**
   • Perimeter = base + height + hypotenuse
   • Perimeter = {base} + {height} + {hypotenuse:.2f}
   • Perimeter = **{perimeter:.2f} cm**

📊 **Visualization:**
{plot_info}
"""
        
        # Case 2: Given hypotenuse and one angle
        elif hypotenuse > 0 and angle > 0 and angle < 90:
            # Convert angle to radians for calculations
            angle_rad = math.radians(angle)
            # Calculate base and height using trigonometric ratios
            base = hypotenuse * math.cos(angle_rad)
            height = hypotenuse * math.sin(angle_rad)
            other_angle = 90 - angle
            area = 0.5 * base * height
            
            # Generate plot
            try:
                fig = plotter.plot_right_triangle(base, height)
                plot_path = "static/plots/right_triangle_auto.png"
                os.makedirs("static/plots", exist_ok=True)
                fig.savefig(plot_path, dpi=300, bbox_inches='tight')
                plot_info = f"![Right Triangle]({plot_path})"
            except Exception as e:
                plot_info = f"⚠️ Plot generation failed: {str(e)}"

            result = f"""
✅ **Right Triangle Solution:**

Given:
• Hypotenuse = {hypotenuse} cm  
• Angle = {angle}°

📝 **Step-by-Step Calculations:**

1. **Base (a):**
   • Using cosine: a = hypotenuse × cos(angle)
   • a = {hypotenuse} × cos({angle}°)
   • a = {hypotenuse} × {math.cos(angle_rad):.4f}
   • a = **{base:.2f} cm**

2. **Height (b):**
   • Using sine: b = hypotenuse × sin(angle)
   • b = {hypotenuse} × sin({angle}°)
   • b = {hypotenuse} × {math.sin(angle_rad):.4f}
   • b = **{height:.2f} cm**

3. **Other Angle:**
   • Other Angle = 90° - {angle}°
   • Other Angle = **{other_angle:.1f}°**

4. **Area:**
   • Area = ½ × base × height
   • Area = ½ × {base:.2f} × {height:.2f}
   • Area = **{area:.2f} cm²**

📊 **Visualization:**
{plot_info}
"""

        # Case 3: Given hypotenuse and one side
        elif hypotenuse > 0 and (base > 0 or height > 0):
            if base > 0:
                # Calculate height using Pythagorean theorem
                if hypotenuse**2 - base**2 < 0:
                    return "❌ Invalid input: base cannot be larger than hypotenuse in a right triangle."
                height = math.sqrt(hypotenuse**2 - base**2)
                known_side = "base"
                known_value = base
                other_side = height
                other_name = "height"
            else:
                # Calculate base using Pythagorean theorem
                if hypotenuse**2 - height**2 < 0:
                    return "❌ Invalid input: height cannot be larger than hypotenuse in a right triangle."
                base = math.sqrt(hypotenuse**2 - height**2)
                known_side = "height"
                known_value = height
                other_side = base
                other_name = "base"

            # Calculate angles using inverse tangent
            angle_B = math.degrees(math.atan(height / base))
            angle_A = 90 - angle_B
            area = 0.5 * base * height
            
            # Generate plot
            try:
                fig = plotter.plot_right_triangle(base, height)
                plot_path = "static/plots/right_triangle_auto.png"
                os.makedirs("static/plots", exist_ok=True)
                fig.savefig(plot_path, dpi=300, bbox_inches='tight')
                plot_info = f"![Right Triangle]({plot_path})"
            except Exception as e:
                plot_info = f"⚠️ Plot generation failed: {str(e)}"

            result = f"""
✅ **Right Triangle Solution:**

Given:
• Hypotenuse = {hypotenuse} cm  
• {known_side.capitalize()} = {known_value} cm

📝 **Step-by-Step Calculations:**

1. **{other_name.capitalize()}:**
   • Using Pythagorean theorem: {other_name} = √(hypotenuse² - {known_side}²)
   • {other_name} = √({hypotenuse}² - {known_value}²)
   • {other_name} = √({hypotenuse**2} - {known_value**2})
   • {other_name} = √{hypotenuse**2 - known_value**2}
   • {other_name} = **{other_side:.2f} cm**

2. **Angles:**
   • Angle B = tan⁻¹({other_name}/{known_side})
   • Angle B = tan⁻¹({other_side:.2f}/{known_value})
   • Angle B = tan⁻¹({other_side/known_value:.2f})
   • Angle B = **{angle_B:.1f}°**
   
   • Angle A = 90° - Angle B
   • Angle A = 90° - {angle_B:.1f}°
   • Angle A = **{angle_A:.1f}°**

3. **Area:**
   • Area = ½ × base × height
   • Area = ½ × {base:.2f} × {height:.2f}
   • Area = **{area:.2f} cm²**

📊 **Visualization:**
{plot_info}
"""
        
        else:
            result = "❌ Insufficient data. Need at least:\n• Base and height, OR\n• Hypotenuse and one angle, OR\n• Hypotenuse and one other side."
        
        return result

    except Exception as e:
        return f"❌ Error solving right triangle: {str(e)}"
--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/right_triangle/__pycache__/solver_right_triangle.cpython-310.pyc ###

### File: chapters/chapter6_triangles/sub_chapters/right_triangle/__pycache__/solver_right_triangle.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xe4 in position 9: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/similar_triangles/solver.py ###
# File: chapters/chapter6_triangles/sub_chapters/similar_triangles/solver.py

import math

def check_similar_triangles(sides1: list, sides2: list) -> dict:
    """Check if two triangles are similar using SSS criterion."""
    if len(sides1) != 3 or len(sides2) != 3:
        raise ValueError("Both triangles must have exactly 3 sides")
    
    # Calculate ratios of corresponding sides
    ratios = [sides2[i]/sides1[i] for i in range(3)]
    
    # Check if all ratios are equal (within a small tolerance)
    is_similar = all(abs(r - ratios[0]) < 1e-10 for r in ratios)
    
    return {
        'is_similar': is_similar,
        'ratio': ratios[0] if is_similar else None,
        'message': f"Triangles are {'similar' if is_similar else 'not similar'} by SSS criterion"
    }

def check_similar_triangles_angles(angles1: list, angles2: list) -> dict:
    """Check if two triangles are similar using AA criterion."""
    if len(angles1) != 3 or len(angles2) != 3:
        raise ValueError("Both triangles must have exactly 3 angles")
    
    # Check if two angles are equal (within a small tolerance)
    angles1.sort()
    angles2.sort()
    is_similar = (abs(angles1[0] - angles2[0]) < 1e-10 and 
                 abs(angles1[1] - angles2[1]) < 1e-10)
    
    return {
        'is_similar': is_similar,
        'message': f"Triangles are {'similar' if is_similar else 'not similar'} by AA criterion"
    }

def find_missing_side(sides1: list, sides2: list, missing_index: int) -> dict:
    """Find the missing side in a similar triangle."""
    if len(sides1) != 3 or len(sides2) != 3:
        raise ValueError("Both triangles must have exactly 3 sides")
    
    # Find the ratio using the known sides
    known_ratios = [sides2[i]/sides1[i] for i in range(3) if i != missing_index]
    if not known_ratios or not all(abs(r - known_ratios[0]) < 1e-10 for r in known_ratios):
        raise ValueError("Triangles are not similar")
    
    ratio = known_ratios[0]
    missing_side = sides1[missing_index] * ratio
    
    return {
        'missing_side': missing_side,
        'ratio': ratio,
        'message': f"Missing side = {missing_side:.2f} cm"
    }

def find_missing_angle(angles1: list, angles2: list, missing_index: int) -> dict:
    """Find the missing angle in a similar triangle."""
    if len(angles1) != 3 or len(angles2) != 3:
        raise ValueError("Both triangles must have exactly 3 angles")
    
    # In similar triangles, corresponding angles are equal
    missing_angle = angles1[missing_index]
    
    return {
        'missing_angle': missing_angle,
        'message': f"Missing angle = {missing_angle}°"
    } 
--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/similar_triangles/solver_similar.py ###
import math
import streamlit as st
import numpy as np
from typing import Dict, Any, List, Tuple
from ...utils.triangle_base import TriangleBase, TriangleData
from ...utils.triangle_plotter import TrianglePlotter

def solve_similar_triangles(params: Dict) -> str:
    """Entry point for similar triangles solver."""
    solver = SimilarTriangleSolver()
    return solver.solve(params)

class SimilarTriangleSolver(TriangleBase):
    def __init__(self):
        super().__init__()
        self.plotter = TrianglePlotter()
    
    def solve(self, params: Dict) -> str:
        """Solve similar triangles problem."""
        try:
            # Extract parameters
            triangle1_sides = params.get('triangle1', [])
            triangle2_sides = params.get('triangle2', [])
            
            # Validate input
            if not (triangle1_sides and triangle2_sides):
                return "❌ Please provide sides for both triangles."
            
            # Create triangle data objects
            triangle1 = TriangleData(sides=triangle1_sides)
            triangle2 = TriangleData(sides=triangle2_sides)
            
            # Check if triangles are valid
            if not triangle1.is_valid():
                return "❌ First triangle is not valid! The sum of any two sides must be greater than the third side."
            if not triangle2.is_valid():
                return "❌ Second triangle is not valid! The sum of any two sides must be greater than the third side."
            
            # Check similarity
            is_similar, scale_factor = self.are_similar(triangle1, triangle2)
            
            # Prepare response
            response = []
            
            if is_similar:
                response.append("✅ The triangles are similar!")
                response.append(f"Scale factor: {scale_factor:.2f}")
                
                # Additional information
                response.append("\n📐 **Additional Information:**")
                response.append(f"First triangle is {triangle1.get_type()}")
                response.append(f"Second triangle is {triangle2.get_type()}")
                
                if triangle1.is_right_triangle():
                    response.append("First triangle is a right triangle")
                if triangle2.is_right_triangle():
                    response.append("Second triangle is a right triangle")
                
                # Calculate and display angles
                angles1 = self.calculate_angles(triangle1.sides)
                angles2 = self.calculate_angles(triangle2.sides)
                
                response.append("\n📐 **Angles:**")
                response.append(f"First triangle: {', '.join(f'{angle}°' for angle in angles1)}")
                response.append(f"Second triangle: {', '.join(f'{angle}°' for angle in angles2)}")
                
                # Calculate and display areas
                area1 = self.calculate_area(triangle1.sides)
                area2 = self.calculate_area(triangle2.sides)
                
                response.append("\n📐 **Areas:**")
                response.append(f"First triangle: {area1:.2f} square units")
                response.append(f"Second triangle: {area2:.2f} square units")
                response.append(f"Area ratio: {(area2/area1):.2f} (should be square of scale factor)")
                
                # Visualize triangles
                response.append("\n📐 **Visualization:**")
                
                # Calculate points for visualization
                points1 = self._calculate_triangle_points(triangle1.sides)
                points2 = self._calculate_triangle_points(triangle2.sides)
                
                # Plot triangles
                col1, col2 = st.columns(2)
                with col1:
                    st.write("First Triangle")
                    fig1 = self.plotter.plot_triangle(points1, angles1)
                    st.pyplot(fig1)
                
                with col2:
                    st.write("Second Triangle")
                    fig2 = self.plotter.plot_triangle(points2, angles2)
                    st.pyplot(fig2)
                
                # Explanation
                response.append("\n📐 **Explanation:**")
                response.append("Two triangles are similar if their corresponding sides are proportional.")
                response.append(f"In this case, the ratio of corresponding sides is {scale_factor:.2f}:1")
                response.append("Therefore, the triangles are similar.")
                
            else:
                response.append("❌ The triangles are not similar!")
                
                # Show why they're not similar
                response.append("\n📐 **Analysis:**")
                sides1_sorted = sorted(triangle1.sides)
                sides2_sorted = sorted(triangle2.sides)
                ratios = [sides2_sorted[i] / sides1_sorted[i] for i in range(3)]
                
                response.append("Side ratios:")
                for i, ratio in enumerate(ratios):
                    response.append(f"Ratio {i+1}: {ratio:.2f}")
                
                response.append("\nFor triangles to be similar, all side ratios must be equal.")
                response.append("In this case, the ratios are different, which means the triangles are not similar.")
            
            return "\n".join(response)
            
        except Exception as e:
            return f"❌ Error: {str(e)}"
    
    def _calculate_triangle_points(self, sides: List[float]) -> List[Tuple[float, float]]:
        """Calculate points for triangle visualization."""
        # Place first point at origin
        points = [(0, 0)]
        
        # Place second point on x-axis
        points.append((sides[0], 0))
        
        # Calculate third point using cosine law
        a, b, c = sides
        cos_C = (a**2 + b**2 - c**2) / (2 * a * b)
        sin_C = np.sqrt(1 - cos_C**2)
        
        x = a * cos_C
        y = a * sin_C
        points.append((x, y))
        
        return points

def check_similarity_sss(sides1: List[float], sides2: List[float]) -> str:
    """
    Check if two triangles are similar using SSS criterion.
    """
    if len(sides1) != 3 or len(sides2) != 3:
        return "❌ Each triangle must have exactly 3 sides"
    
    # Sort sides to match corresponding sides
    a1, b1, c1 = sorted(sides1)
    a2, b2, c2 = sorted(sides2)
    
    # Calculate ratios
    ratio_a = a2 / a1
    ratio_b = b2 / b1
    ratio_c = c2 / c1
    
    # Check if all ratios are equal (within tolerance)
    tolerance = 0.001
    is_similar = (abs(ratio_a - ratio_b) < tolerance and 
                  abs(ratio_b - ratio_c) < tolerance and 
                  abs(ratio_a - ratio_c) < tolerance)
    
    # Calculate angles for both triangles
    angles1 = calculate_triangle_angles(sides1)
    angles2 = calculate_triangle_angles(sides2)
    
    result = f"""
✅ **Similar Triangles Check (SSS Criterion):**

**Triangle 1:** Sides = {sides1[0]}, {sides1[1]}, {sides1[2]} cm
**Triangle 2:** Sides = {sides2[0]}, {sides2[1]}, {sides2[2]} cm

📝 **Step-by-Step Analysis:**

**1. Sorting sides (smallest to largest):**
   • Triangle 1: {a1}, {b1}, {c1}
   • Triangle 2: {a2}, {b2}, {c2}

**2. Calculating ratios of corresponding sides:**
   • Ratio 1: {a2}/{a1} = {ratio_a:.3f}
   • Ratio 2: {b2}/{b1} = {ratio_b:.3f}
   • Ratio 3: {c2}/{c1} = {ratio_c:.3f}

**3. Checking if all ratios are equal:**
   • Difference between ratios: {abs(ratio_a - ratio_b):.6f}, {abs(ratio_b - ratio_c):.6f}, {abs(ratio_a - ratio_c):.6f}
   • All differences < 0.001? {'YES ✓' if is_similar else 'NO ✗'}

**4. Angles of triangles:**
   • Triangle 1: {angles1[0]:.1f}°, {angles1[1]:.1f}°, {angles1[2]:.1f}°
   • Triangle 2: {angles2[0]:.1f}°, {angles2[1]:.1f}°, {angles2[2]:.1f}°

💡 **Conclusion:**
{'✅ The triangles ARE SIMILAR by SSS criterion!' if is_similar else '❌ The triangles are NOT SIMILAR'}
{f'• Scale factor (ratio) = {ratio_a:.3f}' if is_similar else '• Ratios are not equal'}
{f'• Corresponding angles are equal' if is_similar else '• Corresponding angles may differ'}

**Properties of similar triangles:**
• Corresponding angles are equal
• Corresponding sides are proportional
• Ratio of areas = (ratio of sides)²
{f'• Area ratio = {ratio_a**2:.3f}' if is_similar else ''}
"""
    
    return result

def check_similarity_aa(params: Dict[str, Any]) -> str:
    """
    Check if two triangles are similar using AA criterion.
    """
    angles1 = params.get("angles1", [])
    angles2 = params.get("angles2", [])
    
    if len(angles1) < 2 or len(angles2) < 2:
        return "❌ Need at least 2 angles from each triangle"
    
    # Sort angles for comparison
    angles1_sorted = sorted(angles1[:2])
    angles2_sorted = sorted(angles2[:2])
    
    # Check if two angles are equal
    tolerance = 0.1
    is_similar = (abs(angles1_sorted[0] - angles2_sorted[0]) < tolerance and 
                  abs(angles1_sorted[1] - angles2_sorted[1]) < tolerance)
    
    # Calculate third angles
    third_angle1 = 180 - sum(angles1[:2])
    third_angle2 = 180 - sum(angles2[:2])
    
    result = f"""
✅ **Similar Triangles Check (AA Criterion):**

**Triangle 1 angles:** {angles1[0]}°, {angles1[1]}°, {third_angle1:.1f}°
**Triangle 2 angles:** {angles2[0]}°, {angles2[1]}°, {third_angle2:.1f}°

📝 **Analysis:**

**1. Comparing corresponding angles:**
   • Angle 1: {angles1_sorted[0]}° vs {angles2_sorted[0]}° (difference: {abs(angles1_sorted[0] - angles2_sorted[0]):.1f}°)
   • Angle 2: {angles1_sorted[1]}° vs {angles2_sorted[1]}° (difference: {abs(angles1_sorted[1] - angles2_sorted[1]):.1f}°)

**2. AA Criterion Check:**
   Two angles of one triangle equal to two angles of another? {'YES ✓' if is_similar else 'NO ✗'}

💡 **Conclusion:**
{'✅ The triangles ARE SIMILAR by AA criterion!' if is_similar else '❌ The triangles are NOT SIMILAR'}
"""
    
    return result

def find_missing_side_similar(params: Dict[str, Any]) -> str:
    """
    Find missing side in similar triangles.
    """
    known_triangle = params.get("known_triangle", [])
    partial_triangle = params.get("partial_triangle", [])
    ratio = params.get("ratio", 0)
    
    if not ratio and len(known_triangle) == 3 and len(partial_triangle) >= 2:
        # Calculate ratio from known sides
        for i in range(len(partial_triangle)):
            if partial_triangle[i] > 0 and known_triangle[i] > 0:
                ratio = partial_triangle[i] / known_triangle[i]
                break
    
    if not ratio:
        return "❌ Cannot determine scale factor. Need at least one corresponding pair of sides."
    
    # Find missing sides
    missing_sides = []
    for i in range(3):
        if i < len(partial_triangle) and partial_triangle[i] == 0:
            missing_sides.append((i, known_triangle[i] * ratio))
    
    result = f"""
✅ **Finding Missing Sides in Similar Triangles:**

**Known Triangle:** {known_triangle}
**Partial Triangle:** {partial_triangle}
**Scale Factor:** {ratio:.3f}

📝 **Solution:**
"""
    
    for idx, value in missing_sides:
        side_name = ['a', 'b', 'c'][idx]
        result += f"""
**Missing side {side_name}:**
• {side_name} = {known_triangle[idx]} × {ratio:.3f}
• {side_name} = {value:.2f} cm
"""
    
    return result

def calculate_triangle_angles(sides: List[float]) -> List[float]:
    """
    Calculate angles of a triangle using law of cosines.
    """
    a, b, c = sides
    
    # Law of cosines: cos(A) = (b² + c² - a²) / (2bc)
    cos_A = (b**2 + c**2 - a**2) / (2 * b * c)
    cos_B = (a**2 + c**2 - b**2) / (2 * a * c)
    cos_C = (a**2 + b**2 - c**2) / (2 * a * b)
    
    # Ensure values are in valid range for arccos
    cos_A = max(-1, min(1, cos_A))
    cos_B = max(-1, min(1, cos_B))
    cos_C = max(-1, min(1, cos_C))
    
    # Calculate angles in degrees
    angle_A = math.degrees(math.acos(cos_A))
    angle_B = math.degrees(math.acos(cos_B))
    angle_C = math.degrees(math.acos(cos_C))
    
    return [angle_A, angle_B, angle_C]

def area_ratio_similar_triangles(ratio: float) -> str:
    """
    Calculate area ratio of similar triangles.
    """
    area_ratio = ratio ** 2
    
    result = f"""
✅ **Area Ratio of Similar Triangles:**

Given:
• Linear scale factor (ratio of sides) = {ratio}

📝 **Formula:**
• Area ratio = (Linear ratio)²
• Area ratio = {ratio}²
• Area ratio = {area_ratio:.3f}

💡 **This means:**
• If sides are in ratio {ratio}:1
• Then areas are in ratio {area_ratio:.3f}:1

**Example:**
If smaller triangle has area 10 cm²,
then larger triangle has area = 10 × {area_ratio:.3f} = {10 * area_ratio:.2f} cm²
"""
    
    return result
--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/similar_triangles/__pycache__/solver_similar.cpython-310.pyc ###

### File: chapters/chapter6_triangles/sub_chapters/similar_triangles/__pycache__/solver_similar.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xc5 in position 9: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/__pycache__/__init__.cpython-310.pyc ###

### File: chapters/chapter6_triangles/sub_chapters/__pycache__/__init__.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xc4 in position 8: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/pythagoras/solver_pythagoras.py ###
import math
from typing import Dict, Any

def solve_pythagoras(params: Dict[str, Any]) -> str:
    """
    Apply Pythagoras theorem to find missing side or verify right triangle.
    """
    try:
        find = params.get("find", "hypotenuse")
        
        if find == "verify":
            return verify_pythagoras(params)
        elif find == "hypotenuse":
            return find_hypotenuse(params)
        elif find == "side":
            return find_other_side(params)
        else:
            # Auto-detect what to find
            return auto_solve_pythagoras(params)
            
    except Exception as e:
        return f"❌ Error applying Pythagoras theorem: {str(e)}"

def find_hypotenuse(params: Dict[str, Any]) -> str:
    """
    Find hypotenuse given two other sides.
    """
    side1 = params.get("side1", 0)
    side2 = params.get("side2", 0)
    
    if side1 <= 0 or side2 <= 0:
        return "❌ Both sides must be positive values"
    
    hypotenuse = math.sqrt(side1**2 + side2**2)
    
    result = f"""
✅ **Pythagoras Theorem - Finding Hypotenuse:**

Given:
• Side 1 (a) = {side1} cm
• Side 2 (b) = {side2} cm

📝 **Step-by-Step Solution:**

**Pythagoras Theorem:** c² = a² + b²

**1. Square the given sides:**
   • a² = {side1}² = {side1**2}
   • b² = {side2}² = {side2**2}

**2. Add the squares:**
   • c² = a² + b²
   • c² = {side1**2} + {side2**2}
   • c² = {side1**2 + side2**2}

**3. Take square root:**
   • c = √{side1**2 + side2**2}
   • **c = {hypotenuse:.2f} cm**

💡 **Answer:** Hypotenuse = {hypotenuse:.2f} cm

**Verification:** {side1}² + {side2}² = {side1**2} + {side2**2} = {side1**2 + side2**2} = {hypotenuse:.2f}² ✓

**Practical Note:** This is the length of the longest side in the right triangle.
"""
    
    return result

def find_other_side(params: Dict[str, Any]) -> str:
    """
    Find one side given hypotenuse and another side.
    """
    hypotenuse = params.get("hypotenuse", 0)
    known_side = params.get("known_side", 0)
    
    if hypotenuse <= 0 or known_side <= 0:
        return "❌ Hypotenuse and known side must be positive"
    
    if known_side >= hypotenuse:
        return "❌ In a right triangle, hypotenuse must be longer than any other side"
    
    other_side = math.sqrt(hypotenuse**2 - known_side**2)
    
    result = f"""
✅ **Pythagoras Theorem - Finding Other Side:**

Given:
• Hypotenuse (c) = {hypotenuse} cm
• Known side (a) = {known_side} cm

📝 **Step-by-Step Solution:**

**From Pythagoras Theorem:** c² = a² + b²
**Rearranging:** b² = c² - a²

**1. Square the given values:**
   • c² = {hypotenuse}² = {hypotenuse**2}
   • a² = {known_side}² = {known_side**2}

**2. Subtract to find b²:**
   • b² = c² - a²
   • b² = {hypotenuse**2} - {known_side**2}
   • b² = {hypotenuse**2 - known_side**2}

**3. Take square root:**
   • b = √{hypotenuse**2 - known_side**2}
   • **b = {other_side:.2f} cm**

💡 **Answer:** Other side = {other_side:.2f} cm

**Verification:** {known_side}² + {other_side:.2f}² = {known_side**2} + {other_side**2:.2f} ≈ {hypotenuse**2} = {hypotenuse}² ✓
"""
    
    return result

def verify_pythagoras(params: Dict[str, Any]) -> str:
    """
    Verify if given sides form a right triangle.
    """
    sides = params.get("sides", [])
    
    if len(sides) != 3:
        return "❌ Need exactly 3 sides to verify"
    
    # Sort to identify potential hypotenuse
    a, b, c = sorted(sides)
    
    # Check Pythagoras theorem
    left_side = a**2 + b**2
    right_side = c**2
    difference = abs(left_side - right_side)
    is_right = difference < 0.001
    
    result = f"""
✅ **Pythagoras Theorem - Verification:**

Given sides: {sides[0]}, {sides[1]}, {sides[2]} cm
Sorted: {a}, {b}, {c} cm (smallest to largest)

📝 **Checking if it's a right triangle:**

**Pythagoras Theorem:** In a right triangle, a² + b² = c²

**1. Calculate squares:**
   • a² = {a}² = {a**2}
   • b² = {b}² = {b**2}
   • c² = {c}² = {c**2}

**2. Check the equation:**
   • a² + b² = {a**2} + {b**2} = {left_side}
   • c² = {right_side}
   • Difference = |{left_side} - {right_side}| = {difference:.6f}

💡 **Conclusion:**
{'✅ YES, this IS a right triangle!' if is_right else '❌ NO, this is NOT a right triangle'}
{f'The hypotenuse is {c} cm (the longest side)' if is_right else f'For a right triangle, we would need: c = √{left_side} = {math.sqrt(left_side):.2f} cm'}

**Triangle Type:** {classify_by_pythagoras(a, b, c)}
"""
    
    return result

def auto_solve_pythagoras(params: Dict[str, Any]) -> str:
    """
    Automatically determine what to solve based on given parameters.
    """
    # Check what's given
    if "sides" in params and len(params["sides"]) == 3:
        return verify_pythagoras(params)
    elif "side1" in params and "side2" in params:
        return find_hypotenuse(params)
    elif "hypotenuse" in params and "known_side" in params:
        return find_other_side(params)
    else:
        # Extract any numbers and try to make sense
        numbers = []
        for key, value in params.items():
            if isinstance(value, (int, float)) and value > 0:
                numbers.append(value)
        
        if len(numbers) == 2:
            params["side1"] = numbers[0]
            params["side2"] = numbers[1]
            return find_hypotenuse(params)
        elif len(numbers) == 3:
            params["sides"] = numbers
            return verify_pythagoras(params)
        else:
            return "❌ Unable to determine what to calculate. Please provide either:\n• Two sides to find hypotenuse\n• Hypotenuse and one side to find the other side\n• Three sides to verify if it's a right triangle"

def classify_by_pythagoras(a: float, b: float, c: float) -> str:
    """
    Classify triangle using Pythagoras theorem.
    """
    left = a**2 + b**2
    right = c**2
    
    if abs(left - right) < 0.001:
        return "Right Triangle (90° angle)"
    elif left > right:
        return "Acute Triangle (all angles < 90°)"
    else:
        return "Obtuse Triangle (one angle > 90°)"
--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/pythagoras/__pycache__/solver_pythagoras.cpython-310.pyc ###

### File: chapters/chapter6_triangles/sub_chapters/pythagoras/__pycache__/solver_pythagoras.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xa6 in position 8: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/area/solver.py ###
# File: chapters/chapter6_triangles/sub_chapters/area/solver.py

import math

def calculate_area_heron(sides: list) -> dict:
    """Calculate area of a triangle using Heron's formula."""
    if len(sides) != 3:
        raise ValueError("Triangle must have exactly 3 sides")
    
    a, b, c = sides
    
    # Check if triangle is valid
    if not (a + b > c and b + c > a and c + a > b):
        raise ValueError("Invalid triangle: sum of any two sides must be greater than the third side")
    
    # Calculate semi-perimeter
    s = (a + b + c) / 2
    
    # Calculate area using Heron's formula
    area = math.sqrt(s * (s - a) * (s - b) * (s - c))
    
    return {
        'area': area,
        'semi_perimeter': s,
        'message': f"Area = {area:.2f} cm²"
    }

def calculate_area_base_height(base: float, height: float) -> dict:
    """Calculate area of a triangle using base and height."""
    if base <= 0 or height <= 0:
        raise ValueError("Base and height must be positive")
    
    area = 0.5 * base * height
    
    return {
        'area': area,
        'message': f"Area = {area:.2f} cm²"
    }

def calculate_area_sides_angle(side1: float, side2: float, angle: float) -> dict:
    """Calculate area of a triangle using two sides and included angle."""
    if side1 <= 0 or side2 <= 0:
        raise ValueError("Sides must be positive")
    
    if angle <= 0 or angle >= 180:
        raise ValueError("Angle must be between 0° and 180°")
    
    # Convert angle to radians
    angle_rad = math.radians(angle)
    
    # Calculate area using formula: Area = ½ × a × b × sin(C)
    area = 0.5 * side1 * side2 * math.sin(angle_rad)
    
    return {
        'area': area,
        'message': f"Area = {area:.2f} cm²"
    }

def find_height_given_area(area: float, base: float) -> dict:
    """Find height of a triangle given area and base."""
    if area <= 0 or base <= 0:
        raise ValueError("Area and base must be positive")
    
    height = (2 * area) / base
    
    return {
        'height': height,
        'message': f"Height = {height:.2f} cm"
    }

def find_base_given_area(area: float, height: float) -> dict:
    """Find base of a triangle given area and height."""
    if area <= 0 or height <= 0:
        raise ValueError("Area and height must be positive")
    
    base = (2 * area) / height
    
    return {
        'base': base,
        'message': f"Base = {base:.2f} cm"
    } 
--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/area/solver_area.py ###
import math
from typing import Dict, Any

def solve_triangle_area(params: Dict[str, Any]) -> str:
    """
    Calculate area of triangle using various methods.
    """
    try:
        method = params.get("method", "auto")
        
        if method == "heron" or "sides" in params:
            return calculate_area_heron(params)
        elif method == "base_height" or ("base" in params and "height" in params):
            return calculate_area_base_height(params)
        elif method == "trigonometric" or "angle" in params:
            return calculate_area_trigonometric(params)
        else:
            return "❌ Need either: 3 sides (Heron's formula), base & height, or 2 sides & included angle"
            
    except Exception as e:
        return f"❌ Error calculating area: {str(e)}"

def calculate_area_heron(params: Dict[str, Any]) -> str:
    """
    Calculate area using Heron's formula.
    """
    sides = params.get("sides", [])
    
    if len(sides) != 3:
        return "❌ Need exactly 3 sides for Heron's formula"
    
    a, b, c = sides
    
    # Check triangle validity
    if not (a + b > c and b + c > a and c + a > b):
        return f"""
❌ **Invalid Triangle:**

Given sides: {a}, {b}, {c} cm

**Triangle Inequality Check:**
• {a} + {b} = {a + b} {'>' if a + b > c else '≤'} {c} {'✓' if a + b > c else '✗'}
• {b} + {c} = {b + c} {'>' if b + c > a else '≤'} {a} {'✓' if b + c > a else '✗'}
• {c} + {a} = {c + a} {'>' if c + a > b else '≤'} {b} {'✓' if c + a > b else '✗'}

**Result:** These sides cannot form a triangle!
"""
    
    # Calculate semi-perimeter
    s = (a + b + c) / 2
    
    # Calculate area using Heron's formula
    area_squared = s * (s - a) * (s - b) * (s - c)
    area = math.sqrt(area_squared)
    
    # Calculate angles for additional info
    angles = calculate_angles_from_sides(sides)
    
    result = f"""
✅ **Triangle Area (Heron's Formula):**

Given sides: a = {a} cm, b = {b} cm, c = {c} cm

📝 **Step-by-Step Solution:**

**1. Calculate semi-perimeter (s):**
   s = (a + b + c) / 2
   s = ({a} + {b} + {c}) / 2
   s = {a + b + c} / 2
   s = {s} cm

**2. Apply Heron's Formula:**
   Area = √[s(s-a)(s-b)(s-c)]
   Area = √[{s}({s}-{a})({s}-{b})({s}-{c})]
   Area = √[{s} × {s-a} × {s-b} × {s-c}]
   Area = √[{area_squared:.3f}]
   **Area = {area:.2f} cm²**

**3. Additional Information:**
   • Perimeter = {a + b + c} cm
   • Angles: {angles[0]:.1f}°, {angles[1]:.1f}°, {angles[2]:.1f}°
   • Type: {classify_triangle(sides, angles)}

💡 **Verification:** Sum of angles = {sum(angles):.1f}° ≈ 180° ✓
"""
    
    return result

def calculate_area_base_height(params: Dict[str, Any]) -> str:
    """
    Calculate area using base and height.
    """
    base = params.get("base", 0)
    height = params.get("height", 0)
    
    if base <= 0 or height <= 0:
        return "❌ Base and height must be positive values"
    
    area = 0.5 * base * height
    
    result = f"""
✅ **Triangle Area (Base × Height):**

Given:
• Base = {base} cm
• Height = {height} cm

📝 **Solution:**

**Formula:** Area = ½ × base × height
   Area = ½ × {base} × {height}
   Area = 0.5 × {base * height}
   **Area = {area:.2f} cm²**

💡 **Note:** Height must be perpendicular to the base.

**Quick Facts:**
• This is the simplest formula for triangle area
• Works for any triangle if you know base and perpendicular height
• For right triangles, the two legs can be base and height
"""
    
    return result

def calculate_area_trigonometric(params: Dict[str, Any]) -> str:
    """
    Calculate area using two sides and included angle.
    """
    side1 = params.get("side1", 0)
    side2 = params.get("side2", 0)
    angle = params.get("angle", 0)
    
    if side1 <= 0 or side2 <= 0:
        return "❌ Sides must be positive values"
    
    if angle <= 0 or angle >= 180:
        return "❌ Angle must be between 0° and 180°"
    
    # Convert angle to radians
    angle_rad = math.radians(angle)
    
    # Calculate area
    area = 0.5 * side1 * side2 * math.sin(angle_rad)
    
    result = f"""
✅ **Triangle Area (Trigonometric Formula):**

Given:
• Side 1 = {side1} cm
• Side 2 = {side2} cm
• Included angle = {angle}°

📝 **Solution:**

**Formula:** Area = ½ × a × b × sin(C)
   where C is the angle between sides a and b

   Area = ½ × {side1} × {side2} × sin({angle}°)
   Area = ½ × {side1} × {side2} × {math.sin(angle_rad):.4f}
   Area = 0.5 × {side1 * side2 * math.sin(angle_rad):.4f}
   **Area = {area:.2f} cm²**

💡 **Important:**
• The angle must be between the two given sides
• This formula is useful when you don't have the height
• sin({angle}°) = {math.sin(angle_rad):.4f}
"""
    
    return result

def calculate_angles_from_sides(sides: list) -> list:
    """
    Calculate angles using law of cosines.
    """
    a, b, c = sides
    
    # Law of cosines
    cos_A = (b**2 + c**2 - a**2) / (2 * b * c)
    cos_B = (a**2 + c**2 - b**2) / (2 * a * c)
    cos_C = (a**2 + b**2 - c**2) / (2 * a * b)
    
    # Ensure values are in valid range
    cos_A = max(-1, min(1, cos_A))
    cos_B = max(-1, min(1, cos_B))
    cos_C = max(-1, min(1, cos_C))
    
    # Calculate angles in degrees
    angle_A = math.degrees(math.acos(cos_A))
    angle_B = math.degrees(math.acos(cos_B))
    angle_C = math.degrees(math.acos(cos_C))
    
    return [angle_A, angle_B, angle_C]

def classify_triangle(sides: list, angles: list) -> str:
    """
    Classify triangle by sides and angles.
    """
    a, b, c = sorted(sides)
    
    # By sides
    if abs(a - b) < 0.001 and abs(b - c) < 0.001:
        side_type = "Equilateral"
    elif abs(a - b) < 0.001 or abs(b - c) < 0.001 or abs(a - c) < 0.001:
        side_type = "Isosceles"
    else:
        side_type = "Scalene"
    
    # By angles
    max_angle = max(angles)
    if abs(max_angle - 90) < 0.1:
        angle_type = "Right"
    elif max_angle > 90:
        angle_type = "Obtuse"
    else:
        angle_type = "Acute"
    
    return f"{angle_type} {side_type}"
--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/area/__pycache__/solver_area.cpython-310.pyc ###

### File: chapters/chapter6_triangles/sub_chapters/area/__pycache__/solver_area.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xd3 in position 9: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/sub_chapters/triangle_properties/__init__.py ###
"""
chapters.chapter6_triangles.sub_chapters.triangle_properties package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/config/triangle_config.json ###
{
    "formulas": {
        "pythagoras": {
            "name": "Pythagoras Theorem",
            "formula": "c² = a² + b²",
            "description": "In a right-angled triangle, the square of the hypotenuse equals the sum of squares of other two sides.",
            "variables": {
                "c": "hypotenuse (longest side)",
                "a": "base",
                "b": "height"
            },
            "example": "If base = 3, height = 4, then hypotenuse = √(3² + 4²) = √(9 + 16) = √25 = 5"
        },
        "similarity": {
            "name": "Triangle Similarity Criteria",
            "criteria": [
                {
                    "name": "AA (Angle-Angle)",
                    "description": "If two angles of one triangle equal two angles of another"
                },
                {
                    "name": "SSS (Side-Side-Side)",
                    "description": "If all corresponding sides are in the same ratio",
                    "formula": "a₁/a₂ = b₁/b₂ = c₁/c₂"
                },
                {
                    "name": "SAS (Side-Angle-Side)",
                    "description": "If one angle is equal and including sides are in same ratio"
                }
            ],
            "properties": [
                "Corresponding angles are equal",
                "Corresponding sides are proportional",
                "Ratio of areas = (ratio of sides)²"
            ]
        },
        "area": {
            "name": "Triangle Area Formulas",
            "formulas": [
                {
                    "name": "Base-Height Formula",
                    "formula": "Area = ½ × base × height"
                },
                {
                    "name": "Heron's Formula",
                    "formula": "Area = √[s(s-a)(s-b)(s-c)]",
                    "description": "Where s = (a+b+c)/2 (semi-perimeter)"
                },
                {
                    "name": "Trigonometric Formula",
                    "formula": "Area = ½ × a × b × sin(C)",
                    "description": "Where C is angle between sides a and b"
                },
                {
                    "name": "Equilateral Triangle",
                    "formula": "Area = (√3/4) × side²"
                }
            ]
        },
        "bpt": {
            "name": "Basic Proportionality Theorem (Thales Theorem)",
            "statement": "If a line is drawn parallel to one side of a triangle intersecting the other two sides, then it divides the two sides proportionally.",
            "formula": "If DE ∥ BC, then AD/DB = AE/EC and AD/AB = AE/AC = DE/BC",
            "converse": "If a line divides two sides of a triangle in the same ratio, then the line is parallel to the third side.",
            "applications": [
                "Finding unknown lengths",
                "Proving lines parallel",
                "Similar triangle problems"
            ]
        }
    },
    "plotting": {
        "colors": {
            "triangle": "#2E86C1",
            "angles": "#E74C3C",
            "sides": "#27AE60",
            "labels": "#000000",
            "background": "#FFFFFF"
        },
        "line_width": 2,
        "font_size": 12,
        "arc_radius_ratio": 0.2
    },
    "validation": {
        "min_side_length": 0.1,
        "max_side_length": 1000,
        "angle_tolerance": 1e-10
    }
} 
--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/plots/test_right_triangle1.png ###

### File: chapters/chapter6_triangles/plots/test_right_triangle1.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/plots/right_triangle_plot.png ###

### File: chapters/chapter6_triangles/plots/right_triangle_plot.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/plots/general_triangle_plot.png ###

### File: chapters/chapter6_triangles/plots/general_triangle_plot.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/plots/test_right_triangle2.png ###

### File: chapters/chapter6_triangles/plots/test_right_triangle2.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/plots/similar_triangles_plot.png ###

### File: chapters/chapter6_triangles/plots/similar_triangles_plot.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/plots/test_right_triangle3.png ###

### File: chapters/chapter6_triangles/plots/test_right_triangle3.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/__pycache__/plot_triangles.cpython-310.pyc ###

### File: chapters/chapter6_triangles/__pycache__/plot_triangles.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xfd in position 8: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/__pycache__/interpret_query_triangles.cpython-310.pyc ###

### File: chapters/chapter6_triangles/__pycache__/interpret_query_triangles.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xd2 in position 9: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/__pycache__/__init__.cpython-310.pyc ###

### File: chapters/chapter6_triangles/__pycache__/__init__.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xc4 in position 8: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/__pycache__/main_router.cpython-310.pyc ###

### File: chapters/chapter6_triangles/__pycache__/main_router.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xe5 in position 9: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/chapters/chapter6_triangles/plots/test_right_triangle1.png ###

### File: chapters/chapter6_triangles/chapters/chapter6_triangles/plots/test_right_triangle1.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/chapters/chapter6_triangles/plots/test_right_triangle2.png ###

### File: chapters/chapter6_triangles/chapters/chapter6_triangles/plots/test_right_triangle2.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter6_triangles/chapters/chapter6_triangles/plots/test_right_triangle3.png ###

### File: chapters/chapter6_triangles/chapters/chapter6_triangles/plots/test_right_triangle3.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/__init__.py ###
"""
chapters.chapter2_polynomials package
"""
# File: chapters/chapter2_polynomials/__init__.py
from . import main_router

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/main_router.py ###
import os
import json
from utils.sanitizer import sanitize_expression
from chapters.chapter2_polynomials.sub_chapters.polynomial_factoring.solver_factoring import factor_polynomial
from chapters.chapter2_polynomials.interpret_query_polynomial import interpret_query_polynomial

def load_logic_template(intent: str):
    path = os.path.join(os.path.dirname(__file__), 'logic_templates', f'{intent}.json')
    if os.path.exists(path):
        with open(path, 'r') as f:
            return json.load(f)
    return None

def route_query(query: str) -> str:
    query = query.strip()
    query_lower = query.lower()
    
    # First, try LLM interpretation if available
    try:
        llm_result = interpret_query_polynomial(query)
        if llm_result.get("intent") == "factor_polynomial" and llm_result.get("expression"):
            expr = sanitize_expression(llm_result["expression"])
            return factor_polynomial(expr)
    except Exception as e:
        # If LLM fails, continue with rule-based approach
        pass
    
    # Rule-based approach
    if any(kw in query_lower for kw in ["factor", "factorise", "expand"]):
        # Extract expression more flexibly
        import re
        # Look for polynomial patterns
        pattern = r'[x\d\s\+\-\*\^]+'
        matches = re.findall(pattern, query)
        if matches:
            # Take the longest match (likely the expression)
            expr = max(matches, key=len)
            expr = sanitize_expression(expr)
            return factor_polynomial(expr)
    
    # Direct polynomial check (already sanitized)
    expr = sanitize_expression(query)
    try:
        # Check if it's a valid polynomial expression
        if "x" in expr and any(op in expr for op in ["+", "-", "*", "**"]):
            return factor_polynomial(expr)
    except Exception:
        pass

    # No match found → fallback to logic_template examples
    fallback = load_logic_template("factor_polynomial")
    if fallback:
        examples = fallback.get("examples", [])
        response_template = fallback.get("response_template", "")
        message = "**⚠️ Could not understand the query. Try these examples:**\n"
        for e in examples:
            message += f"- {e}\n"
        if response_template:
            message += f"\n**📘 Note:** {response_template}"
        return message
    else:
        return "❌ Unrecognized polynomial query."
--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/interpret_query_polynomial.py ###
import os
from dotenv import load_dotenv
from groq import Groq

load_dotenv()
client = Groq(api_key=os.getenv("GROQ_API_KEY"))

def interpret_query_polynomial(query: str) -> dict:
    """
    Uses LLM to interpret natural language queries related to polynomials.
    Returns intent + parsed expression.
    """
    prompt = f"""
You are a math query classifier for CBSE Class X Polynomial topics.
Classify the user query into one of the following intents:
- factor_polynomial
- find_zeroes
- construct_quadratic

Return a JSON like:
{{
  "intent": "factor_polynomial",
  "expression": "x^2 + 5x + 6"
}}

Query: "{query}"
"""


    try:
        response = client.chat.completions.create(
            model="llama3-8b-8192",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.2
        )
        content = response.choices[0].message.content.strip()
        if content.startswith("{"):
            import json
            return json.loads(content)
        else:
            return {"intent": "unknown", "raw_response": content}
    except Exception as e:
        return {"intent": "error", "error": str(e)}

# Example for testing
if __name__ == "__main__":
    q = "Can you factor x^2 - 3x - 10?"
    print(interpret_query_polynomial(q))

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/logic_templates/factor_polynomial.json ###
{
  "intent": "factor_polynomial",
  "patterns": [
    "factor",
    "can you factor",
    "factorise",
    "factorize",
    "split the middle term",
    "find factors"
  ],
  "examples": [
    "factor x^2 - 5x + 6",
    "can you factor x^2 + 3x + 2",
    "factorize x^2 - 7x + 12",
    "factor the polynomial x^2 + 8x + 15",
    "x^2 - 9x + 20",
    "factor x^3 - 6x^2 + 11x - 6",
    "factorize x^3 + 2x^2 - 5x - 6",
    "can you factor x^3 - x",
    "factor the cubic x^3 - 8"
  ],
  "response_template": "To factor a polynomial, we find its roots and express it as a product of linear factors.",
  "steps_template": [
    "For Quadratic (ax² + bx + c):",
    "  1. Check discriminant (b² - 4ac)",
    "  2. Find two numbers that multiply to ac and add to b",
    "  3. Split the middle term and factor by grouping",
    "",
    "For Cubic (ax³ + bx² + cx + d):",
    "  1. Try Rational Root Theorem (±factors of d/±factors of a)",
    "  2. Use synthetic division to find factors",
    "  3. Factor the remaining quadratic"
  ],
  "common_errors": [
    "Not all polynomials can be factored over real numbers",
    "Check discriminant for quadratics - if negative, no real factors exist",
    "Some cubics have only one real root and two complex roots"
  ]
}
--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/__init__.py ###
"""
chapters.chapter2_polynomials.sub_chapters package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/interpret_query_factoring.py ###
# File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/interpret_query_factoring.py

import re
from utils.sanitizer import sanitize_expression

def interpret_query(query: str) -> str:
    """
    Extracts and sanitizes the polynomial expression from the user query.
    Example: 'Factor x^2 - 15x + 60' → 'x**2 - 15*x + 60'
    """
    # Use regex to capture expression after 'factor' or 'factor the polynomial'
    match = re.search(r'factor(?: the)?(?: polynomial)?\s+([-\d\w\s\^\+\*/xX]+)', query, re.IGNORECASE)
    if match:
        raw_expr = match.group(1).strip()
        return sanitize_expression(raw_expr)

    raise ValueError("Could not extract a valid polynomial expression from the query.")

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__init__.py ###
"""
chapters.chapter2_polynomials.sub_chapters.polynomial_factoring package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/solver_factoring.py ###
# File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/solver_factoring.py

from sympy import factor, sympify, symbols, solve, I, expand, nsimplify, Rational
import re

x = symbols('x')

def format_root(root):
    """Format a root value nicely."""
    try:
        # Try to simplify to a nice form
        simplified = nsimplify(root, rational=True)
        if simplified.is_Integer:
            return str(simplified)
        elif simplified.is_Rational:
            return str(simplified)
        else:
            # For irrational roots, show decimal approximation
            return f"{float(root):.3f}"
    except:
        return f"{float(root):.3f}"

def explain_factoring_steps(expr, degree):
    """Generate step-by-step explanation for factoring."""
    poly = expr.as_poly(x)
    coeffs = poly.all_coeffs()
    
    if degree == 2:
        a, b, c = coeffs
        steps = f"\n📝 **Steps for factoring {expr}:**\n"
        steps += f"1. Identify coefficients: a={a}, b={b}, c={c}\n"
        steps += f"2. Calculate discriminant: b²-4ac = {b}²-4({a})({c}) = {b**2 - 4*a*c}\n"
        
        if b**2 - 4*a*c >= 0:
            steps += f"3. Find two numbers that multiply to {a*c} and add to {b}\n"
            # Try to find integer factors
            for i in range(1, abs(a*c) + 1):
                if (a*c) % i == 0:
                    j = (a*c) // i
                    if i + j == b or -i - j == b:
                        steps += f"   Found: {i} and {j}\n"
                        break
        return steps
    
    elif degree == 3:
        a, b, c, d = coeffs
        steps = f"\n📝 **Steps for factoring the cubic {expr}:**\n"
        steps += f"1. Coefficients: a={a}, b={b}, c={c}, d={d}\n"
        steps += f"2. Try to find rational roots using Rational Root Theorem\n"
        steps += f"   Possible rational roots: ±(factors of {abs(d)})/(factors of {abs(a)})\n"
        
        # Find actual roots
        roots = solve(expr, x)
        real_roots = [r for r in roots if not r.has(I)]
        if real_roots:
            steps += f"3. Found roots: {', '.join([format_root(r) for r in real_roots])}\n"
        
        return steps
    
    return ""

def factor_polynomial(expression: str) -> str:
    """
    Factors polynomials (quadratic and cubic) with detailed explanations.
    """
    try:
        expr = sympify(expression)
        
        # Expand first to ensure standard form
        expr = expand(expr)

        # Degree of the polynomial
        if not expr.is_polynomial(x):
            return "Only polynomial expressions are supported."

        degree = expr.as_poly(x).degree()
        
        if degree > 3:
            return f"Currently supporting polynomials up to degree 3. Your polynomial has degree {degree}."

        # Get factoring steps explanation
        steps = explain_factoring_steps(expr, degree)

        # ✅ Quadratic check: discriminant
        if degree == 2:
            a, b, c = expr.as_poly(x).all_coeffs()
            discriminant = b**2 - 4*a*c
            if discriminant < 0:
                return f"The polynomial {expr} cannot be factorized over real numbers.\n{steps}❌ Since discriminant < 0, this has complex roots only."

        # ✅ Cubic check: real roots
        if degree == 3:
            roots = solve(expr, x)
            real_roots = [r for r in roots if not r.has(I)]
            complex_roots = [r for r in roots if r.has(I)]
            
            if len(real_roots) == 0:
                return f"The cubic polynomial {expr} has no real roots and cannot be factorized over real numbers.\n{steps}❌ All roots are complex."
            elif len(real_roots) == 1:
                # One real root, two complex roots
                real_root = real_roots[0]
                steps += f"\n✅ This cubic has 1 real root and 2 complex roots.\n"

        # Perform factoring
        factored = factor(expr)

        # If unchanged, it's irreducible
        if factored == expr:
            return f"The polynomial {expr} cannot be factorized further over rational numbers.\n{steps}"
        
        # Format the output nicely with roots information
        result = f"✅ **Factored form of {expr}:**\n\n**{factored}**"
        
        # Add roots information
        roots = solve(expr, x)
        if roots:
            result += f"\n\n🎯 **Roots/Zeros:**\n"
            for i, root in enumerate(roots, 1):
                if root.is_real:
                    result += f"   x_{i} = {format_root(root)}\n"
                else:
                    result += f"   x_{i} = {root} (complex)\n"
        
        result += steps
        
        return result

    except Exception as e:
        return f"Failed to factor the expression: {expression}\nError: {str(e)}"
--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/narrator_polynomial.py ###
def narrate_polynomial_plot(coefficients, degree=2):
    from sympy import symbols, solve, nsimplify, I
    x = symbols('x')
    
    if degree == 2:
        a, b, c = coefficients
        expr = a * x**2 + b * x + c
        vertex_x = -b / (2*a)
        vertex_y = a * vertex_x**2 + b * vertex_x + c
        
        if a > 0:
            direction = "opens upward (U-shaped)"
            vertex_type = "minimum"
        else:
            direction = "opens downward (inverted U-shaped)"
            vertex_type = "maximum"
            
        narration = f"This quadratic curve {direction} since the coefficient of x² is {a}. "
        narration += f"The vertex ({vertex_type} point) is at ({vertex_x:.2f}, {vertex_y:.2f}). "
        
    elif degree == 3:
        a, b, c, d = coefficients
        expr = a * x**3 + b * x**2 + c * x + d
        
        if a > 0:
            behavior = "rises to +∞ as x→+∞ and falls to -∞ as x→-∞"
        else:
            behavior = "falls to -∞ as x→+∞ and rises to +∞ as x→-∞"
            
        narration = f"This cubic curve {behavior} since the coefficient of x³ is {a}. "
        
        # Check for critical points
        discriminant = 4*b**2 - 12*a*c
        if discriminant > 0:
            narration += "The curve has two critical points (local maximum and minimum). "
        elif discriminant == 0:
            narration += "The curve has one critical point (inflection point). "
        else:
            narration += "The curve has no critical points (monotonic). "
    
    # Find and describe roots
    roots = solve(expr, x)
    real_roots = [r for r in roots if not r.has(I)]
    complex_roots = [r for r in roots if r.has(I)]
    
    # Format roots nicely
    if real_roots:
        root_texts = []
        for r in real_roots:
            try:
                simplified = nsimplify(r, rational=True)
                if simplified.is_Integer or simplified.is_Rational:
                    root_texts.append(f"x = {simplified}")
                else:
                    root_texts.append(f"x = {float(r):.2f}")
            except:
                root_texts.append(f"x = {float(r):.2f}")
        
        root_text = ', '.join(root_texts)
        narration += f"It intersects the x-axis at: {root_text}. "
        
        if len(real_roots) == 1 and degree == 3:
            narration += "This cubic has one real root and two complex roots. "
    else:
        narration += "The curve does not intersect the x-axis (no real roots). "
    
    if complex_roots:
        narration += f"It has {len(complex_roots)} complex root(s). "
    
    narration += "These are the zeros of the polynomial."
    
    return narration
--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/query_router_factoring.py ###
from .interpret_query_factoring import interpret_query
from .solver_factoring import factor_polynomial

def route_factoring(query: str) -> str:
    try:
        expr = interpret_query(query)
        return factor_polynomial(expr)
    except Exception as e:
        return f"Error processing polynomial: {str(e)}"

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/plot_polynomial.py ###
#cbse_math_solver/chpater/chapter2_polynomial_sub_chapters/polynomial_factoring/plot_polynomial.py
import matplotlib.pyplot as plt
import numpy as np
import os
from sympy import symbols, solve, I

def plot_polynomial(coefficients, degree=2, plot_name="polynomial_plot.png"):
    """
    Generates and saves the plot of polynomial to chapters/chapter2_polynomials/plots/
    Supports both quadratic (ax^2 + bx + c) and cubic (ax^3 + bx^2 + cx + d) polynomials
    """
    # First, find the roots to determine optimal viewing window
    x = symbols('x')
    if degree == 2:
        a, b, c = coefficients
        expr = a * x**2 + b * x + c
    else:
        a, b, c, d = coefficients
        expr = a * x**3 + b * x**2 + c * x + d
    
    roots = solve(expr, x)
    real_roots = [float(r.evalf()) for r in roots if not r.has(I)]
    
    # Determine x-range based on roots and critical points
    if real_roots:
        min_root = min(real_roots)
        max_root = max(real_roots)
        root_range = max_root - min_root
        
        # Add padding around roots for better visibility
        padding = max(root_range * 0.5, 2.0)  # At least 2 units padding
        x_min = min_root - padding
        x_max = max_root + padding
    else:
        # Default range if no real roots
        x_min, x_max = -10, 10
    
    # For cubic, also consider critical points
    if degree == 3 and real_roots:
        # Critical points where dy/dx = 0
        # For ax³ + bx² + cx + d, derivative is 3ax² + 2bx + c
        discriminant = (2*b)**2 - 4*(3*a)*c
        if discriminant >= 0:
            crit_x1 = (-2*b + np.sqrt(discriminant)) / (6*a)
            crit_x2 = (-2*b - np.sqrt(discriminant)) / (6*a)
            # Extend range if critical points are outside current range
            x_min = min(x_min, crit_x1 - 1, crit_x2 - 1)
            x_max = max(x_max, crit_x1 + 1, crit_x2 + 1)
    
    # Create more points for smoother curve
    x_vals = np.linspace(x_min, x_max, 1000)
    
    if degree == 2:
        y_vals = a * x_vals**2 + b * x_vals + c
        # Format polynomial equation nicely
        equation = ""
        if a == 1:
            equation += "x²"
        elif a == -1:
            equation += "-x²"
        else:
            equation += f"{a}x²"
        
        if b != 0:
            if b == 1:
                equation += " + x"
            elif b == -1:
                equation += " - x"
            elif b > 0:
                equation += f" + {b}x"
            else:
                equation += f" - {abs(b)}x"
        
        if c != 0:
            if c > 0:
                equation += f" + {c}"
            else:
                equation += f" - {abs(c)}"
                
    elif degree == 3:
        y_vals = a * x_vals**3 + b * x_vals**2 + c * x_vals + d
        # Format polynomial equation nicely
        equation = ""
        if a == 1:
            equation += "x³"
        elif a == -1:
            equation += "-x³"
        else:
            equation += f"{a}x³"
        
        if b != 0:
            if b == 1:
                equation += " + x²"
            elif b == -1:
                equation += " - x²"
            elif b > 0:
                equation += f" + {b}x²"
            else:
                equation += f" - {abs(b)}x²"
        
        if c != 0:
            if c == 1:
                equation += " + x"
            elif c == -1:
                equation += " - x"
            elif c > 0:
                equation += f" + {c}x"
            else:
                equation += f" - {abs(c)}x"
        
        if d != 0:
            if d > 0:
                equation += f" + {d}"
            else:
                equation += f" - {abs(d)}"
    else:
        raise ValueError(f"Unsupported degree: {degree}")

    save_dir = os.path.join(os.path.dirname(__file__), "plots")
    os.makedirs(save_dir, exist_ok=True)
    save_path = os.path.join(save_dir, plot_name)

    # Create figure with high DPI for clarity
    fig, ax = plt.subplots(figsize=(14, 10))
    
    # Plot the polynomial curve
    ax.plot(x_vals, y_vals, 'b-', linewidth=3, label=f'y = {equation}', zorder=5)
    
    # Set up the axes to pass through origin
    ax.spines['left'].set_position('zero')
    ax.spines['bottom'].set_position('zero')
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    
    # Add arrows to axes
    arrow_props = dict(arrowstyle='->', lw=2, color='black')
    ax.annotate('', xy=(x_max, 0), xytext=(x_min, 0), arrowprops=arrow_props)
    ax.annotate('', xy=(0, max(y_vals)), xytext=(0, min(y_vals)), arrowprops=arrow_props)
    
    # Add axis labels
    ax.text(x_max - 0.3, -0.5, 'x', fontsize=20, fontweight='bold', ha='center')
    ax.text(0.3, max(y_vals) - 0.5, 'y', fontsize=20, fontweight='bold', va='center')
    
    # Enhanced grid
    ax.grid(True, which='major', alpha=0.3, linestyle='-', color='gray')
    ax.minorticks_on()
    ax.grid(True, which='minor', alpha=0.1, linestyle=':', color='gray')

    # Mark real roots with enhanced visibility
    if real_roots:
        # Plot roots with larger markers
        ax.plot(real_roots, [0] * len(real_roots), 'o', color='red', markersize=14, 
                label='Zeros (x-intercepts)', markeredgecolor='darkred', markeredgewidth=3,
                markerfacecolor='red', zorder=10)
        
        # Add vertical lines at roots for emphasis
        for root in real_roots:
            ax.axvline(x=root, color='red', alpha=0.3, linestyle='--', linewidth=2, zorder=1)
        
        # Annotate roots with enhanced visibility
        for i, root in enumerate(real_roots):
            # Format root value nicely
            if abs(root - round(root)) < 0.001:
                root_str = f"{int(round(root))}"
            else:
                root_str = f"{root:.3f}"
            
            # Calculate annotation position
            y_range = max(y_vals) - min(y_vals)
            y_offset = y_range * 0.08
            
            # Alternate positions for close roots
            position_multiplier = 1
            for other_root in real_roots[:i]:
                if abs(other_root - root) < 1:
                    position_multiplier *= -1.2
            
            ax.annotate(f'({root_str}, 0)', 
                       xy=(root, 0), 
                       xytext=(root, y_offset * position_multiplier),
                       ha='center',
                       fontsize=14,
                       fontweight='bold',
                       color='darkred',
                       bbox=dict(boxstyle="round,pad=0.5", facecolor="yellow", 
                                edgecolor='darkred', linewidth=2, alpha=0.9),
                       arrowprops=dict(arrowstyle='->', color='darkred', lw=2))

    # Find and mark critical points for cubic
    if degree == 3:
        discriminant = (2*b)**2 - 4*(3*a)*c
        if discriminant >= 0:
            x1 = (-2*b + np.sqrt(discriminant)) / (6*a)
            x2 = (-2*b - np.sqrt(discriminant)) / (6*a)
            y1 = a*x1**3 + b*x1**2 + c*x1 + d
            y2 = a*x2**3 + b*x2**2 + c*x2 + d
            
            # Plot critical points
            ax.plot([x1, x2], [y1, y2], '^', markersize=14, color='green',
                   label='Critical Points', markeredgecolor='darkgreen', 
                   markeredgewidth=2, markerfacecolor='lightgreen', zorder=10)

    # Add shading to show positive/negative regions
    ax.fill_between(x_vals, 0, y_vals, where=(y_vals > 0), 
                    interpolate=True, alpha=0.15, color='blue')
    ax.fill_between(x_vals, 0, y_vals, where=(y_vals < 0), 
                    interpolate=True, alpha=0.15, color='red')

    # Set title
    ax.set_title(f"Graph of Polynomial Function", 
                 fontsize=22, fontweight='bold', pad=30)
    
    # Add equation in a very prominent box at the top
    equation_text = f"y = {equation}"
    props_eq = dict(boxstyle='round,pad=1', facecolor='lightblue', 
                   edgecolor='darkblue', linewidth=4, alpha=0.95)
    ax.text(0.5, 0.92, equation_text, transform=ax.transAxes, 
            fontsize=24, fontweight='bold', ha='center', va='center', 
            bbox=props_eq, color='darkblue')
    
    # Add text box with root information
    if real_roots:
        root_info = "Zeros (x-intercepts):\n"
        for root in sorted(real_roots):
            if abs(root - round(root)) < 0.001:
                root_info += f"x = {int(round(root))}\n"
            else:
                root_info += f"x = {root:.3f}\n"
        
        props = dict(boxstyle='round,pad=0.5', facecolor='lightyellow', 
                    edgecolor='darkgoldenrod', linewidth=2, alpha=0.9)
        ax.text(0.02, 0.98, root_info.strip(), transform=ax.transAxes, 
                fontsize=14, verticalalignment='top', bbox=props)
    
    # Set y-limits with padding
    y_min, y_max = min(y_vals), max(y_vals)
    y_range = y_max - y_min
    y_padding = y_range * 0.15
    ax.set_ylim(y_min - y_padding, y_max + y_padding)
    
    # Set x-limits
    ax.set_xlim(x_min, x_max)
    
    # Enhance legend
    ax.legend(loc='lower right', fontsize=14, framealpha=0.95, edgecolor='black')
    
    # Make tick labels larger and cleaner
    ax.tick_params(axis='both', which='major', labelsize=14)
    
    # Adjust tick label positions to avoid overlapping with axes
    ax.xaxis.set_tick_params(pad=10)
    ax.yaxis.set_tick_params(pad=10)
    
    # Remove tick labels at origin to avoid clutter
    xticks = ax.get_xticks()
    yticks = ax.get_yticks()
    
    # Filter out zero from tick labels
    xticks_filtered = [t for t in xticks if abs(t) > 0.1]
    yticks_filtered = [t for t in yticks if abs(t) > 0.1]
    
    ax.set_xticks(xticks_filtered)
    ax.set_yticks(yticks_filtered)
    
    plt.tight_layout()
    plt.savefig(save_path, dpi=300, bbox_inches='tight', facecolor='white')
    plt.close()
    return save_path
--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/test_polynomial_factoring.py ###
# File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/test_polynomial_factoring.py

import sys
import os

# Automatically add the project root ('cbse_math_solver') to sys.path
CURRENT_FILE = os.path.abspath(__file__)
PROJECT_ROOT = os.path.abspath(os.path.join(CURRENT_FILE, "../../../../.."))
sys.path.insert(0, PROJECT_ROOT)

from chapters.chapter2_polynomials.sub_chapters.polynomial_factoring.query_router_factoring import route_factoring

def run_tests():
    test_queries = [
        "Factor the polynomial 2x^2 + 3x + 1",
        "Factor 3x^2 + 5x + 2",
        "Factor x^2 - 4x + 4",
        "Factor x^2 + 1",
        "Factor x^3 + x^2 + x + 1"
    ]

    for query in test_queries:
        print(f"\nQuery: {query}")
        print("Result:", route_factoring(query))

if __name__ == "__main__":
    run_tests()

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/plots/polynomial_plot.png ###

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/plots/polynomial_plot.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/narrator_polynomial.cpython-310.pyc ###

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/narrator_polynomial.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xa6 in position 8: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/query_router_factoring.cpython-312.pyc ###

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/query_router_factoring.cpython-312.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/interpret_query_factoring.cpython-312.pyc ###

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/interpret_query_factoring.cpython-312.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/plot_polynomial.cpython-310.pyc ###

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/plot_polynomial.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xa0 in position 8: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/__init__.cpython-310.pyc ###

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/__init__.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 8: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/query_router_factoring.cpython-310.pyc ###

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/query_router_factoring.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xd8 in position 8: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/interpret_query_factoring.cpython-310.pyc ###

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/interpret_query_factoring.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0x88 in position 8: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/solver_factoring.cpython-310.pyc ###

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/solver_factoring.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xb1 in position 8: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/solver_factoring.cpython-312.pyc ###

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/solver_factoring.cpython-312.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/__init__.cpython-312.pyc ###

### File: chapters/chapter2_polynomials/sub_chapters/polynomial_factoring/__pycache__/__init__.cpython-312.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/quadratic_construction/__init__.py ###
"""
chapters.chapter2_polynomials.sub_chapters.quadratic_construction package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/__pycache__/__init__.cpython-310.pyc ###

### File: chapters/chapter2_polynomials/sub_chapters/__pycache__/__init__.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 8: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/__pycache__/__init__.cpython-312.pyc ###

### File: chapters/chapter2_polynomials/sub_chapters/__pycache__/__init__.cpython-312.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/sub_chapters/zeroes_relationship/__init__.py ###
"""
chapters.chapter2_polynomials.sub_chapters.zeroes_relationship package
"""

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/__pycache__/interpret_query_polynomial.cpython-310.pyc ###

### File: chapters/chapter2_polynomials/__pycache__/interpret_query_polynomial.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xfe in position 8: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/__pycache__/__init__.cpython-310.pyc ###

### File: chapters/chapter2_polynomials/__pycache__/__init__.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xe3 in position 16: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/__pycache__/main_router.cpython-310.pyc ###

### File: chapters/chapter2_polynomials/__pycache__/main_router.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xb1 in position 8: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter2_polynomials/__pycache__/__init__.cpython-312.pyc ###

### File: chapters/chapter2_polynomials/__pycache__/__init__.cpython-312.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte]

--------------------------------------------------------------------------------

### File: chapters/chapter11_areas_circles/plot_circles.py ###
import matplotlib.pyplot as plt
import numpy as np
import os

# Define π = 22/7 for calculations
PI = 22/7

def plot_sector(radius, angle, save_name="sector_plot.png"):
    """Plot a sector of a circle with given radius and angle."""
    # Create figure and axis
    fig, ax = plt.subplots(figsize=(10, 10))
    
    # Plot the circle
    circle = plt.Circle((0, 0), radius, fill=False, color='blue')
    ax.add_artist(circle)
    
    # Calculate sector points
    theta = np.linspace(0, np.radians(angle), 100)
    x = radius * np.cos(theta)
    y = radius * np.sin(theta)
    
    # Plot the sector
    ax.fill_between(x, 0, y, color='lightblue', alpha=0.3)
    ax.plot(x, y, 'b-')
    
    # Plot radius lines
    ax.plot([0, radius], [0, 0], 'b-')
    ax.plot([0, radius*np.cos(np.radians(angle))], 
            [0, radius*np.sin(np.radians(angle))], 'b-')
    
    # Add angle arc
    arc_radius = radius * 0.3
    arc_theta = np.linspace(0, np.radians(angle), 100)
    arc_x = arc_radius * np.cos(arc_theta)
    arc_y = arc_radius * np.sin(arc_theta)
    ax.plot(arc_x, arc_y, 'r-')
    
    # Add labels
    ax.text(radius/2, -radius/10, f'r = {radius} cm', ha='center')
    ax.text(arc_radius/2, arc_radius/2, f'θ = {angle}°', ha='center')
    
    # Calculate and display area
    area = (angle/360) * PI * radius**2
    ax.text(-radius, radius, f'Area = {area:.2f} cm²', 
            bbox=dict(facecolor='white', alpha=0.8))
    
    # Set equal aspect ratio and limits
    ax.set_aspect('equal')
    ax.set_xlim(-radius*1.2, radius*1.2)
    ax.set_ylim(-radius*1.2, radius*1.2)
    
    # Remove axes
    ax.axis('off')
    
    # Create plots directory if it doesn't exist
    os.makedirs('chapters/chapter11_areas_circles/plots', exist_ok=True)
    
    # Save the plot
    plt.savefig(f'chapters/chapter11_areas_circles/plots/{save_name}', 
                bbox_inches='tight', dpi=300)
    plt.close()
    
    return f'chapters/chapter11_areas_circles/plots/{save_name}'

def plot_segment(radius, angle, save_name="segment_plot.png"):
    """Plot a segment of a circle with given radius and angle."""
    # Create figure and axis
    fig, ax = plt.subplots(figsize=(10, 10))
    
    # Plot the circle
    circle = plt.Circle((0, 0), radius, fill=False, color='blue')
    ax.add_artist(circle)
    
    # Calculate segment points
    theta = np.linspace(0, np.radians(angle), 100)
    x = radius * np.cos(theta)
    y = radius * np.sin(theta)
    
    # Plot the segment
    ax.fill_between(x, 0, y, color='lightgreen', alpha=0.3)
    ax.plot(x, y, 'b-')
    
    # Plot chord
    chord_x = [radius, radius*np.cos(np.radians(angle))]
    chord_y = [0, radius*np.sin(np.radians(angle))]
    ax.plot(chord_x, chord_y, 'b-')
    
    # Add angle arc
    arc_radius = radius * 0.3
    arc_theta = np.linspace(0, np.radians(angle), 100)
    arc_x = arc_radius * np.cos(arc_theta)
    arc_y = arc_radius * np.sin(arc_theta)
    ax.plot(arc_x, arc_y, 'r-')
    
    # Add labels
    ax.text(radius/2, -radius/10, f'r = {radius} cm', ha='center')
    ax.text(arc_radius/2, arc_radius/2, f'θ = {angle}°', ha='center')
    
    # Calculate and display area
    sector_area = (angle/360) * PI * radius**2
    triangle_area = 0.5 * radius**2 * np.sin(np.radians(angle))
    segment_area = sector_area - triangle_area
    ax.text(-radius, radius, f'Area = {segment_area:.2f} cm²', 
            bbox=dict(facecolor='white', alpha=0.8))
    
    # Set equal aspect ratio and limits
    ax.set_aspect('equal')
    ax.set_xlim(-radius*1.2, radius*1.2)
    ax.set_ylim(-radius*1.2, radius*1.2)
    
    # Remove axes
    ax.axis('off')
    
    # Create plots directory if it doesn't exist
    os.makedirs('chapters/chapter11_areas_circles/plots', exist_ok=True)
    
    # Save the plot
    plt.savefig(f'chapters/chapter11_areas_circles/plots/{save_name}', 
                bbox_inches='tight', dpi=300)
    plt.close()
    
    return f'chapters/chapter11_areas_circles/plots/{save_name}'

--------------------------------------------------------------------------------

### File: chapters/chapter11_areas_circles/plots/sector_plot.png ###

### File: chapters/chapter11_areas_circles/plots/sector_plot.png ###
[Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte]

--------------------------------------------------------------------------------

### File: chapters/chapter11_areas_circles/__pycache__/plot_circles.cpython-310.pyc ###

### File: chapters/chapter11_areas_circles/__pycache__/plot_circles.cpython-310.pyc ###
[Error reading file: 'utf-8' codec can't decode byte 0xc5 in position 9: invalid continuation byte]

--------------------------------------------------------------------------------

### File: knowledge_base/__init__.py ###
"""
knowledge_base package
"""

--------------------------------------------------------------------------------

### File: knowledge_base/search_engine/__init__.py ###
"""
knowledge_base.search_engine package
"""

--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter3_linear_equations/concept_explanations.json ###
{
  "concept_explanations": {
    "sample_topic": []
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter3_linear_equations/long_answer_questions.json ###
{
  "long_answer_questions": {
    "sample_topic": []
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter3_linear_equations/numerical_problems.json ###
{
  "numerical_problems": {
    "sample_topic": []
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter3_linear_equations/short_answer_questions.json ###
{
  "short_answer_questions": {
    "sample_topic": [
      {
        "id": "chapter3_linear_equations_short_001",
        "question": "Sample short answer question for Linear Equations",
        "answer": "Sample detailed answer with explanation",
        "steps": [
          "Step 1: Identify the problem type",
          "Step 2: Apply appropriate method",
          "Step 3: Calculate the result"
        ],
        "difficulty": "medium",
        "marks": 3,
        "time_limit": "5 minutes",
        "keywords": [
          "sample",
          "keywords"
        ]
      }
    ]
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter3_linear_equations/mcq_questions.json ###
{
  "mcq_questions": {
    "sample_topic": [
      {
        "id": "chapter3_linear_equations_mcq_001",
        "question": "Sample MCQ question for Linear Equations",
        "options": {
          "A": "Option A",
          "B": "Option B",
          "C": "Option C",
          "D": "Option D"
        },
        "correct_answer": "A",
        "explanation": "Sample explanation for the correct answer",
        "difficulty": "easy",
        "marks": 1,
        "time_limit": "1 minute"
      }
    ]
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter1_real_numbers/concept_explanations.json ###
{
  "concept_explanations": {
    "sample_topic": []
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter1_real_numbers/long_answer_questions.json ###
{
  "long_answer_questions": {
    "sample_topic": []
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter1_real_numbers/numerical_problems.json ###
{
  "numerical_problems": {
    "sample_topic": []
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter1_real_numbers/short_answer_questions.json ###
{
  "short_answer_questions": {
    "sample_topic": [
      {
        "id": "chapter1_real_numbers_short_001",
        "question": "Sample short answer question for Real Numbers",
        "answer": "Sample detailed answer with explanation",
        "steps": [
          "Step 1: Identify the problem type",
          "Step 2: Apply appropriate method",
          "Step 3: Calculate the result"
        ],
        "difficulty": "medium",
        "marks": 3,
        "time_limit": "5 minutes",
        "keywords": [
          "sample",
          "keywords"
        ]
      }
    ]
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter1_real_numbers/mcq_questions.json ###
{
  "mcq_questions": {
    "sample_topic": [
      {
        "id": "chapter1_real_numbers_mcq_001",
        "question": "Sample MCQ question for Real Numbers",
        "options": {
          "A": "Option A",
          "B": "Option B",
          "C": "Option C",
          "D": "Option D"
        },
        "correct_answer": "A",
        "explanation": "Sample explanation for the correct answer",
        "difficulty": "easy",
        "marks": 1,
        "time_limit": "1 minute"
      }
    ]
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter6_triangles/concept_explanations.json ###
{
  "concept_explanations": {
    "sample_topic": []
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter6_triangles/long_answer_questions.json ###
{
  "long_answer_questions": {
    "sample_topic": []
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter6_triangles/numerical_problems.json ###
{
  "numerical_problems": {
    "sample_topic": []
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter6_triangles/short_answer_questions.json ###
{
  "short_answer_questions": {
    "sample_topic": [
      {
        "id": "chapter6_triangles_short_001",
        "question": "Sample short answer question for Triangles",
        "answer": "Sample detailed answer with explanation",
        "steps": [
          "Step 1: Identify the problem type",
          "Step 2: Apply appropriate method",
          "Step 3: Calculate the result"
        ],
        "difficulty": "medium",
        "marks": 3,
        "time_limit": "5 minutes",
        "keywords": [
          "sample",
          "keywords"
        ]
      }
    ]
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter6_triangles/mcq_questions.json ###
{
  "mcq_questions": {
    "sample_topic": [
      {
        "id": "chapter6_triangles_mcq_001",
        "question": "Sample MCQ question for Triangles",
        "options": {
          "A": "Option A",
          "B": "Option B",
          "C": "Option C",
          "D": "Option D"
        },
        "correct_answer": "A",
        "explanation": "Sample explanation for the correct answer",
        "difficulty": "easy",
        "marks": 1,
        "time_limit": "1 minute"
      }
    ]
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter2_polynomials/concept_explanations.json ###
{
  "concept_explanations": {
    "sample_topic": []
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter2_polynomials/long_answer_questions.json ###
{
  "long_answer_questions": {
    "sample_topic": []
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter2_polynomials/numerical_problems.json ###
{
  "numerical_problems": {
    "sample_topic": []
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter2_polynomials/short_answer_questions.json ###
{
  "short_answer_questions": {
    "sample_topic": [
      {
        "id": "chapter2_polynomials_short_001",
        "question": "Sample short answer question for Polynomials",
        "answer": "Sample detailed answer with explanation",
        "steps": [
          "Step 1: Identify the problem type",
          "Step 2: Apply appropriate method",
          "Step 3: Calculate the result"
        ],
        "difficulty": "medium",
        "marks": 3,
        "time_limit": "5 minutes",
        "keywords": [
          "sample",
          "keywords"
        ]
      }
    ]
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/question_bank/chapter2_polynomials/mcq_questions.json ###
{
  "mcq_questions": {
    "sample_topic": [
      {
        "id": "chapter2_polynomials_mcq_001",
        "question": "Sample MCQ question for Polynomials",
        "options": {
          "A": "Option A",
          "B": "Option B",
          "C": "Option C",
          "D": "Option D"
        },
        "correct_answer": "A",
        "explanation": "Sample explanation for the correct answer",
        "difficulty": "easy",
        "marks": 1,
        "time_limit": "1 minute"
      }
    ]
  }
}
--------------------------------------------------------------------------------

### File: knowledge_base/generators/__init__.py ###
"""
knowledge_base.generators package
"""

--------------------------------------------------------------------------------
